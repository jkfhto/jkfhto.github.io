<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Event LoopEvent Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。进程和线程基本概念拿出在教科书里的概念： 1、调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位； 2、并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行； 3、拥有资源：进程是拥有资源的一个独立单位，线">
<meta name="keywords" content="Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="Event Loop 运行机制">
<meta property="og:url" content="https://jkfhto.github.io/2019-10-14/Javascript/Event-Loop-运行机制/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="Event LoopEvent Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。进程和线程基本概念拿出在教科书里的概念： 1、调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位； 2、并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行； 3、拥有资源：进程是拥有资源的一个独立单位，线">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://jkfhto.github.io/images/EventLoop3.jpg">
<meta property="og:image" content="https://jkfhto.github.io/images/EventLoop.jpg">
<meta property="og:image" content="https://jkfhto.github.io/images/EventLoop2.jpg">
<meta property="og:updated_time" content="2019-10-19T04:37:26.304Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Event Loop 运行机制">
<meta name="twitter:description" content="Event LoopEvent Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。进程和线程基本概念拿出在教科书里的概念： 1、调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位； 2、并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行； 3、拥有资源：进程是拥有资源的一个独立单位，线">
<meta name="twitter:image" content="https://jkfhto.github.io/images/EventLoop3.jpg">
  <link rel="canonical" href="https://jkfhto.github.io/2019-10-14/Javascript/Event-Loop-运行机制/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Event Loop 运行机制 | 个人博客</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home  //首页"></i>首页</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags  //标签"></i>标签</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th  //分类"></i>分类</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive  //归档"></i>归档</a>

  </li>
      
    
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">
        
          <i class="fa fa-search fa-fw"></i>
        
        搜索
        </a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jkfhto.github.io/2019-10-14/Javascript/Event-Loop-运行机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jkfhto">
      <meta itemprop="description" content="ARE YOU READY TO DIE">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            Event Loop 运行机制
            

          
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-14 23:01:28" itemprop="dateCreated datePublished" datetime="2019-10-14T23:01:28+08:00">2019-10-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-19 12:37:26" itemprop="dateModified" datetime="2019-10-19T12:37:26+08:00">2019-10-19</time>
              </span>
            
          

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019-10-14/Javascript/Event-Loop-运行机制/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019-10-14/Javascript/Event-Loop-运行机制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。</p><h2 id="进程和线程基本概念"><a href="#进程和线程基本概念" class="headerlink" title="进程和线程基本概念"></a>进程和线程基本概念</h2><p>拿出在教科书里的概念：</p><ul>
<li>1、调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li>
<li>2、并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</li>
<li>3、拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源；</li>
<li>4、系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。进程和线程的关系：</li>
</ul><a id="more"></a>


<p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p>
<p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p>
<p>处理机分给线程，即真正在处理机上运行的是线程；</p>
<p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体。</p>
<p>基本总结，一个进程可以有多个线程，线程之间可以相互通信。</p>
<p>进程是 CPU资源分配的最小单位；线程是 CPU调度的最小单位。</p>
<h3 id="图示解析"><a href="#图示解析" class="headerlink" title="图示解析"></a>图示解析</h3><p><img src="/images/EventLoop3.jpg" alt="进程和线程"></p>
<ul>
<li>进程好比图中的工厂，有单独的专属自己的工厂资源。</li>
<li>线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n的关系。也就是说一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>
<li>工厂的空间是工人们共享的，这象征一个进程的内存空间是共享的，每个线程都可用这些共享内存。</li>
<li>多个工厂之间独立存在。</li>
</ul>
<h3 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h3><ul>
<li>多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</li>
<li>多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li>
</ul>
<p>以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p>
<p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p>
<ul>
<li>GUI 渲染线程</li>
<li>JavaScript引擎线程</li>
<li>定时触发器线程</li>
<li>事件触发线程</li>
<li>异步http请求线程</li>
</ul>
<h3 id="1-GUI渲染线程"><a href="#1-GUI渲染线程" class="headerlink" title="1.GUI渲染线程"></a>1.GUI渲染线程</h3><p>主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。<br>当界面需要重绘或者由于某种操作引发回流时，将执行该线程。<br>该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。</p>
<h3 id="2-JS引擎线程"><a href="#2-JS引擎线程" class="headerlink" title="2.JS引擎线程"></a>2.JS引擎线程</h3><p>该线程当然是主要负责处理 JavaScript脚本，执行代码。<br>也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。<br>当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。</p>
<h3 id="3-定时器触发线程"><a href="#3-定时器触发线程" class="headerlink" title="3.定时器触发线程"></a>3.定时器触发线程</h3><p>负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。<br>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。</p>
<h3 id="4-事件触发线程"><a href="#4-事件触发线程" class="headerlink" title="4.事件触发线程"></a>4.事件触发线程</h3><p>主要负责将准备好的事件交给 JS引擎线程执行。</p>
<p>比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。</p>
<h3 id="5-异步http请求线程"><a href="#5-异步http请求线程" class="headerlink" title="5.异步http请求线程"></a>5.异步http请求线程</h3><p>负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。</p>
<p>主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。</p>
<h2 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h2><p>JS 执行是单线程的，意味着 JS 在执行代码的时候一次只能处理一个任务，必须按队列顺序逐个执行。JS 的主要功效是处理前端交互，其中就包括操作 DOM 节点。试想若 JS 是多线程，在处理网页交互时，一个线程需要删除 DOM 节点，另一个线程却是要操作同一个 DOM 节点，这样该如何判断先执行哪个线程？但若队列中存在多个任务，上一个任务的执行会阻塞下一个任务，导致代码执行效率低下。就像 AJAX 请求线程，发出请求后需要等待响应结果，期间 CPU 却是空闲的。对此，JS的事件循环机制（Event Loop）很好地解决了问题。</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里所谓的单线程指的是主线程是单线程的,所以在Node中主线程依旧是单线程的。</span><br></pre></td></tr></table></figure>

<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>JavaScript 将任务分为两种：同步任务和异步任务。</p>
<ul>
<li>同步任务：执行完后能立即得出结果的任务。同步任务在主线程中执行，上一个任务的执行会阻塞下一个任务，在执行过程中产生堆栈。堆中存储复杂数据类型（Object），栈中存储基本数据类型（String、Number、Boolean、Null、Undefined、Symbol）。</li>
<li>异步任务：执行后无法立即得出结果，需要等待一段时间获得相应的任务。其中又分为宏任务（Macrotask）和微任务（Microtask）。<ul>
<li>宏任务：script（整体代码）、setTimeout、setInterval、setImmediate、I/O操作（mouse click、keypress、network event）、UI渲染、requestAnimationTrame等。</li>
<li>微任务：Promise.then、MutationObserver、process.nextTick()等。</li>
</ul>
</li>
</ul>
<h2 id="浏览器-Event-Loop-过程解析"><a href="#浏览器-Event-Loop-过程解析" class="headerlink" title="浏览器 Event Loop 过程解析"></a>浏览器 Event Loop 过程解析</h2><p>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>
<p>JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p>
<p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p>
<ul>
<li><p>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</p>
</li>
<li><p>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</p>
</li>
<li><p>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的（如下图所示）。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</p>
</li>
<li><p>执行渲染操作，更新界面（敲黑板划重点）。</p>
</li>
<li><p>检查是否存在 Web worker 任务，如果有，则对其进行处理 。</p>
</li>
<li><p>上述过程循环往复，直到两个队列都清空</p>
</li>
</ul>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<p>执行过程分析：</p>
<p>全局上下文 <strong><em>（script 标签）</em></strong> 被推入调用栈，同步代码执行。打印 <strong><em>script start</em></strong>，遇到 <strong><em>setTimeout</em></strong>，推入到<strong><em>macro 队列</em></strong>。遇到<strong><em>Promise.resolve().then</em></strong>推入到<strong><em>micro 队列</em></strong>，遇到同步代码。打印 <strong><em>script end</em></strong>。</p>
<p><strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>promise1</em></strong>，遇到 <strong><em>then</em></strong>，推入到<strong><em>macro 队列</em></strong>。<strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>promise2</em></strong>。<strong><em>micro 队列</em></strong> 清空。</p>
<p><strong><em>macro 队列</em></strong> 执行出队列操作，打印 <strong><em>setTimeout</em></strong>，<strong><em>macro 队列</em></strong> 清空。</p>
<h3 id="更复杂的例子"><a href="#更复杂的例子" class="headerlink" title="更复杂的例子"></a>更复杂的例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="comment">// async2().then(function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log('async1 end')</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise3'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2 end</span></span><br><span class="line"><span class="comment">// Promise1</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// promise3</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<p>执行过程分析：</p>
<p>全局上下文 <strong><em>（script 标签）</em></strong> 被推入调用栈，同步代码执行。打印 <strong><em>script start</em></strong>，遇到 <strong><em>setTimeout</em></strong>，推入到<strong><em>macro 队列</em></strong>。执行 <strong><em>async1</em></strong> ，打印 <strong><em>async1 start</em></strong> 。执行 <strong><em>await async2()</em></strong>，相当于先执行 <strong><em>async2</em></strong> 这个 <strong><em>Promise</em></strong> 函数，打印 <strong><em>async2 end</em></strong>，然后执行 <strong><em>then</em></strong>，<strong><em>micro</em></strong> 任务 <strong><em>console.log(‘async1 end’)</em></strong> 入队列。遇到 <strong><em>new Promise</em></strong>，同步任务，打印 <strong><em>Promise1</em></strong>，执行 <strong><em>resolve()</em></strong>，<strong><em>micro</em></strong> 任务 <strong><em>console.log(‘promise2’)</em></strong> 入队列。遇到同步任务，打印 <strong><em>script end</em></strong>；</p>
<p><strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>async1 end</em></strong>，然后打印 <strong><em>promise2</em></strong>，遇到 <strong><em>then</em></strong>，<strong><em>console.log(‘promise3’)</em></strong>，推入到<strong><em>macro 队列</em></strong>。<strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>promise3</em></strong>。<strong><em>micro 队列</em></strong> 清空。</p>
<p><strong><em>macro 队列</em></strong> 执行出队列操作，打印 <strong><em>setTimeout</em></strong>，<strong><em>macro 队列</em></strong> 清空。</p>
<h2 id="NodeJS-Event-Loop-过程解析"><a href="#NodeJS-Event-Loop-过程解析" class="headerlink" title="NodeJS Event Loop 过程解析"></a>NodeJS Event Loop 过程解析</h2><p><img src="/images/EventLoop.jpg" alt="Event Loop"></p>
<p>Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。</p>
<p><img src="/images/EventLoop2.jpg" alt="Event Loop2"></p>
<h3 id="Node-js的运行机制如下"><a href="#Node-js的运行机制如下" class="headerlink" title="Node.js的运行机制如下:"></a>Node.js的运行机制如下:</h3><ul>
<li>V8引擎解析JavaScript脚本。</li>
<li>解析后的代码，调用Node API。</li>
<li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li>V8引擎再将结果返回给用户。</li>
</ul>
<p>Node的Event loop一共分为6个阶段，每个细节具体如下：</p>
<ul>
<li>timers: 执行setTimeout和setInterval中到期的callback。</li>
<li>pending callback: 执行延迟到下一个循环迭代的 I/O 回调。</li>
<li>idle, prepare: 仅在内部使用。</li>
<li>poll: 最重要的阶段，执行pending callback，检索新的 I/O 事件;执行与 I/O 相关的回调，在适当的情况下回阻塞在这个阶段。</li>
<li>check: 执行setImmediate() 设定的callbacks。</li>
<li>close callbacks: 执行close事件的callback，例如socket.on(‘close’[,fn])或者http.server.on(‘close, fn)。</li>
</ul>
<h3 id="timers"><a href="#timers" class="headerlink" title="timers"></a>timers</h3><p>执行 <strong><em>setTimeout</em></strong> 和 <strong><em>setInterval</em></strong> 中到期的 <strong><em>callback</em></strong>，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行<strong><em>callback</em></strong> 回调，但是由于 <strong><em>system的调度</em></strong> 可能会延时，达不到预期时间。</p>
<h3 id="pending-callbacks"><a href="#pending-callbacks" class="headerlink" title="pending callbacks"></a>pending callbacks</h3><p>此阶段执行某些系统操作的回调，例如TCP错误的类型。 例如，如果TCP套接字在尝试连接时收到ECONNREFUSED，则某些* nix系统希望等待报告错误。 这将在pending callbacks阶段执行。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 阶段有两个重要的功能：</p>
<ul>
<li>执行与 I/O 相关的回调</li>
<li>然后，处理 poll 队列里的事件</li>
</ul>
<p>当事件循环进入 <strong><em>poll</em></strong> 阶段并且在 <strong><em>timers</em></strong> 队列中没有可以执行定时器时，将发生以下两种情况之一</p>
<ul>
<li>如果 <strong><em>poll</em></strong> 队列不为空，事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制。遇到 <strong><em>setImmediate</em></strong> 将其回调放入 <strong><em>setImmediate</em></strong> 队列。</li>
<li>如果poll队列为空，则会发生以下情况：<ul>
<li>如果有 <strong><em>setImmediate()</em></strong> 回调，则会立即停止执行 <strong><em>poll</em></strong> 阶段并进入执行 <strong><em>check</em></strong> 阶段以执行 <strong><em>setImmediate</em></strong> 回调，清空 <strong><em>check</em></strong>队列。执行完<strong><em>setImmediate</em></strong> ，事件循环将绕回 timers 阶段</li>
<li>如果没有 <strong><em>setImmediate()</em></strong> 回调，一方面将等待 <strong><em>I/O</em></strong> 相关的回调被添加到 <strong><em>poll</em></strong> 队列中，然后立即执行。另一方面如果一个或多个计时器回调已准备就绪，则事件循环将绕回 <strong><em>timers</em></strong> 阶段以执行这些计时器的回调。简言之就是，<strong><em>I/O</em></strong> 相关的回调和 <strong><em>timers</em></strong> 相关的回调谁先有结果就先执行谁。</li>
</ul>
</li>
</ul>
<h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p>此阶段允许人员在 <strong><em>poll</em></strong> 阶段完成后立即执行回调。如果 <strong><em>poll</em></strong> 阶段变为空闲状态，并且脚本已排队使用 setImmediate()，则事件循环继续到 <strong><em>check</em></strong> 阶段而不是等待。</p>
<p><strong><em>setImmediate()</em></strong> 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个 <strong><em>libuv API</em></strong> 来安排回调在 <strong><em>poll</em></strong> 阶段完成后执行。</p>
<p>通常，在执行代码时，事件循环最终将达到 <strong><em>poll</em></strong> 阶段，等待传入连接、请求等。如果已经调度了回调setImmediate()，并且轮询阶段变为空闲，则它将结束并且到达check阶段，而不是等待poll事件。</p>
<h3 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h3><p>如果 <strong><em>socket</em></strong> 或 <strong><em>handle</em></strong> 处理函数突然关闭（例如 socket.destroy()），则’close’ 事件将在这个阶段发出。否则它将通过 process.nextTick() 发出。</p>
<h3 id="setImmediate-的setTimeout-的区别"><a href="#setImmediate-的setTimeout-的区别" class="headerlink" title="setImmediate() 的setTimeout()的区别"></a>setImmediate() 的setTimeout()的区别</h3><p>setImmediate() 和 setTimeout() 很类似，但何时调用行为完全不同。</p>
<ul>
<li>setImmediate()：设计用于在当前poll阶段完成后check阶段执行脚本 。</li>
<li>setTimeout()：安排在经过最小（ms）后运行的脚本，在timers阶段执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码的执行结果，受到进程性能的限制。其结果也不一致。</p>
<p>如果在I / O周期内移动两个调用，则始终首先执行 <strong><em>setImmediate</em></strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>主要原因是在 <strong><em>I/O</em></strong> 阶段读取文件后，事件循环会先进入 <strong><em>poll</em></strong> 阶段，发现有 <strong><em>setImmediate</em></strong> 需要执行，会立即进入check阶段执行<strong><em>setImmediate</em></strong> 的回调。</p>
<p>然后再进入 <strong><em>timers</em></strong> 阶段，执行 <strong><em>setTimeout</em></strong>，打印 <strong><em>timeout</em></strong>。</p>
<h3 id="Process-nextTick"><a href="#Process-nextTick" class="headerlink" title="Process.nextTick()"></a>Process.nextTick()</h3><p>当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p>
<h3 id="一个完整的-NodeJS-Event-Loop-过程"><a href="#一个完整的-NodeJS-Event-Loop-过程" class="headerlink" title="一个完整的 NodeJS Event Loop 过程"></a>一个完整的 <strong><em>NodeJS Event Loop</em></strong> 过程</h3><p>一个完整的 <strong><em>NodeJS Event Loop</em></strong> 过程，可以概括为以下阶段：</p>
<ul>
<li>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li>
<li>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</li>
<li>上一步我们出队的是一个 <strong><em>macro-task</em></strong>，这一步我们处理的是 <strong><em>micro-task</em></strong>。会逐个执行队列中的任务并把它出队，直到队列被清空。同时请注意， <strong><em>Process.nextTick</em></strong> 的优先级高于 <strong><em>Promise.then</em></strong></li>
<li>进入 <strong><em>timers</em></strong> 阶段，执行 <strong><em>setTimeout</em></strong> 和 <strong><em>setInterval</em></strong> 中到期的 <strong><em>callback</em></strong>。</li>
<li>如果 <strong><em>timers</em></strong> 阶段，没有 <strong><em>setTimeout</em></strong> 和 <strong><em>setInterval</em></strong> 到期的回调，会进入 <strong><em>poll</em></strong> 阶段。当事件循环进入poll阶段并且在timers中没有可以执行定时器时，将发生以下两种情况之一。<ul>
<li>如果 <strong><em>poll</em></strong> 队列不为空，事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制。遇到 <strong><em>setImmediate</em></strong> 将其回调放入 <strong><em>setImmediate</em></strong> 队列。</li>
<li>如果poll队列为空，则会发生以下情况：<ul>
<li>如果有 <strong><em>setImmediate()</em></strong> 回调，则会立即停止执行 <strong><em>poll</em></strong> 阶段并进入执行 <strong><em>check</em></strong> 阶段以执行 <strong><em>setImmediate</em></strong> 回调，清空 <strong><em>check</em></strong>队列。执行完<strong><em>setImmediate</em></strong> ，事件循环将绕回 timers 阶段</li>
<li>如果没有 <strong><em>setImmediate()</em></strong> 回调，一方面将等待 <strong><em>I/O</em></strong> 相关的回调被添加到 <strong><em>poll</em></strong> 队列中，然后立即执行。另一方面如果一个或多个计时器回调已准备就绪，则事件循环将绕回 <strong><em>timers</em></strong> 阶段以执行这些计时器的回调。简言之就是，<strong><em>I/O</em></strong> 相关的回调和 <strong><em>timers</em></strong> 相关的回调谁先有结果就先执行谁。</li>
</ul>
</li>
</ul>
</li>
<li>注意，<strong><em>pending callback</em></strong>，<strong><em>idle, prepare</em></strong> 这两个阶段我们通常不用考虑。</li>
<li>同时请注意，如果node版本为v11.x，会执行一个 <strong><em>macro-task</em></strong>，然后处理 <strong><em>micro-task</em></strong>。会逐个执行 <strong><em>micro-task</em></strong> 队列中的任务并把它出队，直到队列被清空，与浏览器效果类似。如果node版本为v11.x以下版本，会执行完所有的 <strong><em>macro-task</em></strong>，清空 <strong><em>macro-task</em></strong> 队列。然后，执行 <strong><em>macro-task</em></strong>，清空 <strong><em>micro-task</em></strong> 队列。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> endTime = +<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout用时共计："</span> + (endTime - beginTime) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">fs.readFile(path.resolve(__dirname, <span class="string">'./test copy.js'</span>), () =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> endTime = +<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"readFile1用时共计："</span> + (endTime - beginTime) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'aaaa'</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">fs.readFile(path.resolve(__dirname, <span class="string">'./test copy.js'</span>), () =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> endTime = +<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"readFile2用时共计："</span> + (endTime - beginTime) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bbb'</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate2'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况1</span></span><br><span class="line"><span class="comment">// readFile1用时共计：3ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// timeout用时共计：14ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// readFile2用时共计：15ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况2</span></span><br><span class="line"><span class="comment">// timeout用时共计：3ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// readFile1用时共计：12ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// readFile2用时共计：13ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况3</span></span><br><span class="line"><span class="comment">// readFile2用时共计：2ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"><span class="comment">// timeout用时共计：12ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// readFile1用时共计：12ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况4</span></span><br><span class="line"><span class="comment">// readFile1用时共计：2ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// readFile2用时共计：9ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"><span class="comment">// timeout用时共计：10ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.zhufengpeixun.cn/main/course/index.html" target="_blank" rel="noopener">珠峰前端架构师</a></li>
<li><a href="https://juejin.im/post/5c3d8956e51d4511dc72c200" target="_blank" rel="noopener">一次弄懂Event Loop（彻底解决此类面试问题）</a></li>
<li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">The Node.js Event Loop, Timers, and process.nextTick()</a></li>
<li><a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218" target="_blank" rel="noopener">浏览器与Node的事件循环(Event Loop)有何区别?</a></li>
</ul>

    </div>

    
    
    
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:16px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Javascript/" rel="tag"><i class="fa fa-tag"></i> Javascript</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019-10-14/Javascript/AOP-面向切片编程/" rel="next" title="AOP 面向切片编程">
                  <i class="fa fa-chevron-left"></i> AOP 面向切片编程
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019-10-16/前端性能优化/从输入-URL-到页面加载完成，发生了什么？/" rel="prev" title="从输入 URL 到页面加载完成，发生了什么？">
                  从输入 URL 到页面加载完成，发生了什么？ <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Event-Loop"><span class="nav-number">1.</span> <span class="nav-text">Event Loop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程和线程基本概念"><span class="nav-number">2.</span> <span class="nav-text">进程和线程基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图示解析"><span class="nav-number">2.1.</span> <span class="nav-text">图示解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多进程与多线程"><span class="nav-number">2.2.</span> <span class="nav-text">多进程与多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器内核"><span class="nav-number">3.</span> <span class="nav-text">浏览器内核</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-GUI渲染线程"><span class="nav-number">3.1.</span> <span class="nav-text">1.GUI渲染线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JS引擎线程"><span class="nav-number">3.2.</span> <span class="nav-text">2.JS引擎线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-定时器触发线程"><span class="nav-number">3.3.</span> <span class="nav-text">3.定时器触发线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-事件触发线程"><span class="nav-number">3.4.</span> <span class="nav-text">4.事件触发线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-异步http请求线程"><span class="nav-number">3.5.</span> <span class="nav-text">5.异步http请求线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么JavaScript是单线程？"><span class="nav-number">4.</span> <span class="nav-text">为什么JavaScript是单线程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务"><span class="nav-number">5.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器-Event-Loop-过程解析"><span class="nav-number">6.</span> <span class="nav-text">浏览器 Event Loop 过程解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#举个例子"><span class="nav-number">6.1.</span> <span class="nav-text">举个例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更复杂的例子"><span class="nav-number">6.2.</span> <span class="nav-text">更复杂的例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NodeJS-Event-Loop-过程解析"><span class="nav-number">7.</span> <span class="nav-text">NodeJS Event Loop 过程解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-js的运行机制如下"><span class="nav-number">7.1.</span> <span class="nav-text">Node.js的运行机制如下:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timers"><span class="nav-number">7.2.</span> <span class="nav-text">timers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pending-callbacks"><span class="nav-number">7.3.</span> <span class="nav-text">pending callbacks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll"><span class="nav-number">7.4.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#check"><span class="nav-number">7.5.</span> <span class="nav-text">check</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#close-callbacks"><span class="nav-number">7.6.</span> <span class="nav-text">close callbacks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setImmediate-的setTimeout-的区别"><span class="nav-number">7.7.</span> <span class="nav-text">setImmediate() 的setTimeout()的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Process-nextTick"><span class="nav-number">7.8.</span> <span class="nav-text">Process.nextTick()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个完整的-NodeJS-Event-Loop-过程"><span class="nav-number">7.9.</span> <span class="nav-text">一个完整的 NodeJS Event Loop 过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="jkfhto">
  <p class="site-author-name" itemprop="name">jkfhto</p>
  <div class="site-description" itemprop="description">ARE YOU READY TO DIE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/jkfhto" title="GitHub &rarr; https://github.com/jkfhto" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jkfhto</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">
      
    主题 – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.1
  </div>
-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>
<script src="/js/next-boot.js?v=7.4.1"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>








  <script src="/js/local-search.js?v=7.4.1"></script>














  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'alQVMWPnOOe4lPVXKRWqDTsQ-gzGzoHsz',
    appKey: 'RleUsHgziBnyz6c72sCfUduo',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
