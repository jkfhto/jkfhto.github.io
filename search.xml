<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TypeScript配置文件</title>
    <url>/2020-04-07/TypeScript/TypeScript%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="TypeScript配置文件"><a href="#TypeScript配置文件" class="headerlink" title="TypeScript配置文件"></a>TypeScript配置文件</h2><p>当我们使用 tsc 命令编译项目，且没有指定输入文件时，编译器就会去查找 tsconfig.json 文件。如果在当前目录没找到，就会逐级向父文件夹查找。我们也可以通过在 tsc 命令中加上–project 参数，来指定一个包含 tsconfig.json 文件的目录。如果命令行上指定了输入文件时，tsconfig.json 的配置会被忽略。</p><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 直接在项目根目录下执行tsc命令，会自动根据tsconfig.json配置项编译</span><br><span class="line">tsc</span><br><span class="line"># 指定要编译的项目，即tsconfig.json所在文件目录</span><br><span class="line">tsc --project ./dir/project</span><br><span class="line"># 指定要编译的文件，忽略tsconfig.json文件配置</span><br><span class="line">tsc ./src/main.ts</span><br></pre></td></tr></table></figure>

<h2 id="主要配置项"><a href="#主要配置项" class="headerlink" title="主要配置项"></a>主要配置项</h2><p>tsconfig.json 文件里有几个主要的配置项：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compileOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"files"</span>: [],</span><br><span class="line">  <span class="attr">"include"</span>: [],</span><br><span class="line">  <span class="attr">"exclude"</span>: [],</span><br><span class="line">  <span class="attr">"extends"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="compileOnSave"><a href="#compileOnSave" class="headerlink" title="compileOnSave"></a>compileOnSave</h3><p><code>compileOnSave</code> 的值是 <code>true</code> 或 <code>false</code>。如果设为 <code>true</code>，当我们编辑了项目中文件并保存的时候，编辑器会根据 tsconfig.json 的配置重新生成文件，不过这个要编辑器支持。</p>
<h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p><code>files</code> 可以配置一个数组列表，里面包含输入文件的相对或绝对路径。编译器在编译的时候只会编译包含在 <code>files</code> 中列出的文件。如果不指定，则取决于有没有设置 <code>include</code> 选项；如果没有 <code>include</code> 选项，则默认会编译根目录以及所有子目录中的文件。这里列出的路径必须是 <code>指定文件</code>，而 <code>不是某个文件夹</code>，而且 <code>不能使用*、?、**/等通配符</code>。</p>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p><code>include</code> 也可以指定要编译的路径列表，但和 <code>files</code> 的区别在于，这里的路径 <code>可以是文件夹，也可以是文件</code>，可以使用相对和绝对路径，而且<code>可以使用通配符</code>。比如”./src”即表示要编译 src 文件夹下的所有文件以及子文件夹的文件。</p>
<h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h3><p><code>exclude</code> 表示要排除的、不编译的文件，它也可以指定一个列表，规则和 <code>include</code> 一样，可以是文件可以是文件夹，可以是相对路径或绝对路径，可以使用通配符。</p>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p><code>extends</code> 可以通过指定一个其它的 <code>tsconfig.json</code> 文件路径，来继承这个配置文件里的配置，继承来的文件配置会 <code>覆盖当前文件定义的配置</code>。TS 在 3.2 版本开始，支持继承一个来自 Node.js 包的 tsconfig.json 配置文件。</p>
<h3 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h3><p>它用来 <code>设置编译选项</code>。</p>
<p>我们先来看第一类，<code>一些比较基本的配置</code>：</p>
<h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><p><code>target</code> 用于 <code>指定编译之后的版本目标</code>，可选值有：ES3(默认值)、ES5、ES2015、ES2016、ES2017、ESNEXT。如果不配置 target 项，<code>默认是将代码转译为 ES3 的版本</code>，如果设为 ESNEXT，则为最新 ES 规范版本。</p>
<h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p><code>module</code> 用来 <code>指定要使用的模块标准</code>，可选值有commonjs、amd、system、umd、es2015(或写 es6)。如果不设置 module 选项，则如果 target 设为 ES6，那么 module 默认值为 ES6，否则是 commonjs。</p>
<h4 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h4><p><code>lib</code> 用于 <code>指定要包含在编译中的库文件</code>。如果你要使用一些 ES6 的新语法，你需要引入 ES6 这个库，或者也可以写 ES2015。如果没有指定 lib 配置，默认会加载一些库，而 <code>加载什么库是受 target 影响的</code>。如果 target 为 ES5，默认包含的库有DOM、ES5和ScriptHost；如果 target 是 ES6，默认引入的库有DOM、ES6、DOM.Iterable和ScriptHost。</p>
<h4 id="allowJs"><a href="#allowJs" class="headerlink" title="allowJs"></a>allowJs</h4><p><code>allowJs</code> 设置的值为 <code>true</code> 或 <code>fals</code>e<code>，用来</code>指定是否允许编译 JS 文件`，默认是 false，即不编译 JS 文件。</p>
<h4 id="checkJs"><a href="#checkJs" class="headerlink" title="checkJs"></a>checkJs</h4><p><code>checkJs</code> 的值为 <code>true</code> 或 <code>false</code>，用来 <code>指定是否检查和报告 JS 文件中的错误</code>，默认是 false。</p>
<h4 id="declaration"><a href="#declaration" class="headerlink" title="declaration"></a>declaration</h4><p><code>declaration</code> 的值为 <code>true</code> 或 <code>false</code>，用来 <code>指定是否在编译的时候生成响应的&quot;.d.ts&quot;声明文件</code>。如果设为 true，编译每个 ts 文件之后会生成一个 js 文件和一个声明文件。但是 <code>declaration 和 allowJs 不能同时设为 true</code>。</p>
<h4 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h4><p>sourceMap 的值为 <code>true</code> 或 <code>false</code>，用来 <code>指定编译时是否生成.map 文件</code>。</p>
<h4 id="outFile"><a href="#outFile" class="headerlink" title="outFile"></a>outFile</h4><p><code>outFile</code> 用于 <code>指定将输出文件合并为一个文件</code>，<code>它的值为一个文件路径名</code>，比如设置为”./dist/main.js”，则输出的文件为一个 main.js 文件。但是要注意，<code>只有设置 module 的值为 amd 和 system 模块时才支持这个配置</code>。</p>
<h4 id="outDir"><a href="#outDir" class="headerlink" title="outDir"></a>outDir</h4><p><code>outDir</code> 用来 <code>指定输出文件夹</code>，<code>值为一个文件夹路径字符串</code>，输出的文件都将放置在这个文件夹。</p>
<h4 id="rootDir"><a href="#rootDir" class="headerlink" title="rootDir"></a>rootDir</h4><p>用来 <code>指定编译文件的根目录</code>，编译器会在根目录查找入口文件，如果编译器发现以 <code>rootDir</code> 的值作为根目录查找入口文件并不会把所有文件加载进去的话会报错，但是不会停止编译。</p>
<h4 id="removeComments"><a href="#removeComments" class="headerlink" title="removeComments"></a>removeComments</h4><p><code>removeComments</code> 值为 <code>true</code> 或 <code>false</code>，用于 <code>指定是否将编译后的文件中的注释删掉</code>，设为 true 的话即删掉注释，默认为 false。</p>
<h4 id="noEmit"><a href="#noEmit" class="headerlink" title="noEmit"></a>noEmit</h4><p><code>不生成编译文件</code>，这个一般很少用了。</p>
<h4 id="importHelpers"><a href="#importHelpers" class="headerlink" title="importHelpers"></a>importHelpers</h4><p><code>importHelpers</code> 的值为 <code>true</code> 或 <code>false</code>，<code>指定是否引入 tslib 里的辅助工具函数</code>，默认 Wie。</p>
<h4 id="isolatedModules"><a href="#isolatedModules" class="headerlink" title="isolatedModules"></a>isolatedModules</h4><p><code>isolatedModules</code> 的值为 <code>true</code> 或 <code>false</code>，<code>指定是否将每个文件作为单独的模块</code>，默认为 true，它不可以和 <code>declaration</code> 同时设定。</p>
<p>第二类是和<code>严格类型检查</code>相关的，开启了这些检查 <code>如果有错会报错</code>：</p>
<h4 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h4><p><code>noImplicitAny</code> 的值为 <code>true</code> 或 <code>false</code>，如果我们没有为一些值设置明确的类型，编译器会默认这个值为 any 类型，<code>如果将 noImplicitAny 设为 true，则如果没有设置明确的类型会报错</code>，默认值为 false。</p>
<h4 id="alwaysStrict"><a href="#alwaysStrict" class="headerlink" title="alwaysStrict"></a>alwaysStrict</h4><p><code>alwaysStrict</code> 的值为 <code>true</code> 或 <code>false</code>，<code>指定始终以严格模式检查每个模块</code>，并且在编译之后的 JS 文件中加入”use strict”字符串，用来告诉浏览器该 JS 为严格模式。</p>
<h4 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h4><p><code>strictNullChecks</code> 的值为 <code>true</code> 或 <code>false</code>，<code>当设为 true 时，null 和 undefined 值不能赋值给非这两种类型的值</code>，别的类型的值也不能赋给它们。 除了 any 类型，还有个例外就是 undefined 可以赋值给 void 类型。</p>
<h4 id="strictFunctionTypes"><a href="#strictFunctionTypes" class="headerlink" title="strictFunctionTypes"></a>strictFunctionTypes</h4><p><code>strictFunctionTypes</code> 的值为 <code>true</code> 或 <code>false</code>，<code>用来指定是否使用函数参数双向协变检查</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funcA = <span class="function"><span class="keyword">function</span>(<span class="params">arg: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> funcB = <span class="function"><span class="keyword">function</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">void</span> </span>&#123;&#125;;</span><br><span class="line">funcA = funcB;</span><br></pre></td></tr></table></figure>

<p>如果开启了 strictFunctionTypes，这个赋值就会报错，默认为 false</p>
<h4 id="strictPropertyInitialization"><a href="#strictPropertyInitialization" class="headerlink" title="strictPropertyInitialization"></a>strictPropertyInitialization</h4><p><code>strictPropertyInitialization</code> 的值为 <code>true</code> 或 <code>false</code>，<code>设为 true 后会检查类的非 undefined 属性是否已经在构造函数里初始化</code>，如果要开启这项，<code>需要同时开启 strictNullChecks</code>，默认为 false。</p>
<h4 id="strictBindCallApply"><a href="#strictBindCallApply" class="headerlink" title="strictBindCallApply"></a>strictBindCallApply</h4><p><code>strictBindCallApply</code> 的值为 <code>true</code> 或 <code>false</code>，<code>设为 true 后会对 bind、call 和 apply 绑定方法参数的检测是严格检测的</code>，如下面的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = foo.apply(<span class="keyword">this</span>, [<span class="number">1</span>]); <span class="comment">// error Property '1' is missing in type '[number]' but required in type '[number, string]'</span></span><br><span class="line"><span class="keyword">let</span> b = foo.apply(<span class="keyword">this</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// error 不能将类型“number”分配给类型“string”</span></span><br><span class="line"><span class="keyword">let</span> ccd = foo.apply(<span class="keyword">this</span>, [<span class="number">1</span>, <span class="string">"a"</span>]); <span class="comment">// right</span></span><br><span class="line"><span class="keyword">let</span> ccsd = foo.apply(<span class="keyword">this</span>, [<span class="number">1</span>, <span class="string">"a"</span>, <span class="number">2</span>]); <span class="comment">// right</span></span><br></pre></td></tr></table></figure>

<h4 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h4><p><code>strict</code> 的值为 <code>true</code> 或 <code>false</code>，<code>用于指定是否启动所有类型检查</code>，<code>如果设为 true 则会同时开启前面这几个严格类型检查</code>，默认为 false。</p>
<p>第三类为额外的一些检查，<code>开启了这些检查如果有错会提示不会报错</code>：</p>
<h4 id="noUnusedLocals"><a href="#noUnusedLocals" class="headerlink" title="noUnusedLocals"></a>noUnusedLocals</h4><p><code>noUnusedLocals</code> 的值为 <code>true</code> 或 <code>false</code>，<code>用于检查是否有定义了但是没有使用的变量</code>，对于这一点的检测，使用 ESLint 可以在你书写代码的时候做提示，你可以配合使用。它的默认值为 false。</p>
<h4 id="noUnusedParameters"><a href="#noUnusedParameters" class="headerlink" title="noUnusedParameters"></a>noUnusedParameters</h4><p><code>noUnusedParameters</code> 的值为 <code>true</code> 或 <code>false</code>，<code>用于检查是否有在函数体中没有使用的参数</code>，这个也可以配合 ESLint 来做检查，它默认是 false。</p>
<h4 id="noImplicitReturns"><a href="#noImplicitReturns" class="headerlink" title="noImplicitReturns"></a>noImplicitReturns</h4><p><code>noImplicitReturns</code> 的值为 <code>true</code> 或 <code>false</code>，<code>用于检查函数是否有返回值</code>，设为 true 后，如果函数没有返回值则会提示，默认为 false。</p>
<h4 id="noFallthroughCasesInSwitch"><a href="#noFallthroughCasesInSwitch" class="headerlink" title="noFallthroughCasesInSwitch"></a>noFallthroughCasesInSwitch</h4><p><code>noFallthroughCasesInSwitch</code> 的值为 <code>true</code> 或 <code>false</code>，<code>用于检查 switch 中是否有 case 没有使用 break 跳出 switch</code>，默认为 false。</p>
<p>接下来是<code>模块解析相关</code>的：</p>
<h4 id="moduleResolution"><a href="#moduleResolution" class="headerlink" title="moduleResolution"></a>moduleResolution</h4><p><code>moduleResolution 用于选择模块解析策略</code>，有”node”和”classic”两种类型。</p>
<h4 id="baseUrl"><a href="#baseUrl" class="headerlink" title="baseUrl"></a>baseUrl</h4><p><code>baseUrl 用于设置解析非相对模块名称的基本目录</code>，相对模块不会受 baseUrl 的影响。</p>
<h4 id="paths"><a href="#paths" class="headerlink" title="paths"></a>paths</h4><p><code>paths 用于设置模块名到基于 baseUrl 的路径映射</code>，比如这样配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    "baseUrl": ".", // 如果使用paths，必须设置baseUrl</span><br><span class="line">    "paths": &#123;</span><br><span class="line">      "jquery": ["node_modules/jquery/dist/jquery"] // 此处映射是相对于"baseUrl"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有<code>当我们要为没有声明文件的第三方模块写声明文件时</code>，我们可以先如下设置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    "baseUrl": ".", // 如果使用paths，必须设置baseUrl</span><br><span class="line">    "paths": &#123;</span><br><span class="line">      "*": ["./node_modules/@types/*", "./typings/*"]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>tsconfig.json</code> 文件所在的目录里建一个 <code>typings 文件夹</code>，然后为要写声明文件的模块建一个同名文件夹，比如我们要为 make-dir 这个模块写声明文件，那么就在 typings 文件夹下新建一个文件夹，命名为 make-dir，然后在 make-dir 文件夹新建一个 index.d.ts 声明文件来为这个模块补充声明。</p>
<h4 id="rootDirs"><a href="#rootDirs" class="headerlink" title="rootDirs"></a>rootDirs</h4><p><code>rootDirs</code> <code>可以指定一个路径列表</code>，在构建时编译器会将这个路径列表中的路径内容都放到一个文件夹中。</p>
<h4 id="typeRoots"><a href="#typeRoots" class="headerlink" title="typeRoots"></a>typeRoots</h4><p><code>typeRoots</code> <code>用来指定声明文件或文件夹的路径列表</code>，如果指定了此项，则只有在这里列出的声明文件才会被加载。</p>
<h4 id="types"><a href="#types" class="headerlink" title="types"></a>types</h4><p><code>types</code> <code>用来指定需要包含的模块</code>，只有在这里列出的模块声明文件才会被加载进来。</p>
<h4 id="allowSyntheticDefaultImports"><a href="#allowSyntheticDefaultImports" class="headerlink" title="allowSyntheticDefaultImports"></a>allowSyntheticDefaultImports</h4><p><code>allowSyntheticDefaultImports</code> 的值为 <code>true</code> 或 <code>fals</code>e，<code>用来指定允许从没有默认导出的模块中默认导入</code>。</p>
<p>接下来的是 <code>source map</code> 的一些配置项：</p>
<h4 id="sourceRoot"><a href="#sourceRoot" class="headerlink" title="sourceRoot"></a>sourceRoot</h4><p><code>sourceRoot</code> <code>用于指定调试器应该找到 TypeScript 文件而不是源文件位置</code>，这个值会被写进.map 文件里。</p>
<h4 id="mapRoot"><a href="#mapRoot" class="headerlink" title="mapRoot"></a>mapRoot</h4><p><code>mapRoot</code> <code>用于指定调试器找到映射文件而非生成文件的位置，指定 map 文件的根路径</code>，该选项会影响.map 文件中的 sources 属性。</p>
<h4 id="inlineSourceMap"><a href="#inlineSourceMap" class="headerlink" title="inlineSourceMap"></a>inlineSourceMap</h4><p><code>inlineSourceMap</code> 值为 <code>tru</code>e 或 <code>false</code>，<code>指定是否将 map 文件的内容和 js 文件编译在同一个 js 文件中</code>。如果设为 true，则 map 的内容会以 <code>//# sourceMappingURL=</code> 然后接 base64 字符串的形式插入在 js 文件底部。</p>
<h4 id="inlineSources"><a href="#inlineSources" class="headerlink" title="inlineSources"></a>inlineSources</h4><p><code>inlineSources</code> 的值是 <code>true</code> 或 <code>false</code>，<code>用于指定是否进一步将.ts 文件的内容也包含到输出文件中</code>。</p>
<p>最后还有两个其他的配置项：</p>
<h4 id="experimentalDecorators"><a href="#experimentalDecorators" class="headerlink" title="experimentalDecorators"></a>experimentalDecorators</h4><p><code>experimentalDecorators</code> 的值是 <code>true</code> 或 <code>false</code>，<code>用于指定是否启用实验性的装饰器特性</code>。</p>
<h4 id="emitDecoratorMetadata"><a href="#emitDecoratorMetadata" class="headerlink" title="emitDecoratorMetadata"></a>emitDecoratorMetadata</h4><p><code>emitDecoratorMetadata</code> 的值为 <code>true</code> 或 <code>false</code>，<code>用于指定是否为装饰器提供元数据支持</code>。关于元数据，也是 ES6 的新标准，可以通过 Reflect 提供的静态方法获取元数据，如果需要使用 Reflect 的一些方法，需要引入 ES2015.Reflect 这个库。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TypeScript配置文件包含六个顶级配置项：<code>compileOnSave</code>、<code>files</code>、<code>include</code>、<code>exclude</code>、<code>extends</code>和<code>compilerOptions</code>，其中我们 <code>最常用的是compilerOptions</code>，<code>用来配置编译选项</code>。有一些参数是只能在 <code>tsconfig.json</code> 文件里配置的，而有一些则既可以在tsconfig.json文件配置，也可以在tsc命令行中指定，具体一个参数可以在哪里指定，可以参考<a href="https://www.tslang.cn/docs/handbook/compiler-options.html" target="_blank" rel="noopener">编译选项列表</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/35" target="_blank" rel="noopener">零基础学透 TypeScript</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript高级类型</title>
    <url>/2020-04-03/TypeScript/TypeScript%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><p>TypeScript为了保障语言的灵活性，而引入的一些语言特效。这些特性有助于开发者应对复杂，多变的开发场景。</p><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型是将多个类型合并为一个类型。 新的类型拥有所有类型的特性。我们大多是在对象混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p><a id="more"></a>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> DogInterface &#123;</span><br><span class="line">    run(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> CatInterface &#123;</span><br><span class="line">    jump(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交叉类型</span></span><br><span class="line"><span class="keyword">let</span> pet: DogInterface &amp; CatInterface = &#123;</span><br><span class="line">    run() &#123;&#125;,</span><br><span class="line">    jump() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>变量的类型并不确定，可以为多个类型中的一个。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Dog <span class="keyword">implements</span> DogInterface &#123;</span><br><span class="line">  run() &#123; &#125;</span><br><span class="line">  eat() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">implements</span> CatInterface &#123;</span><br><span class="line">  jump() &#123; &#125;</span><br><span class="line">  eat() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Master &#123; Boy, Girl &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPet</span>(<span class="params">master: Master</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pet = master === Master.Boy ? <span class="keyword">new</span> Dog() : <span class="keyword">new</span> Cat();</span><br><span class="line">  <span class="comment">// 类型“Dog | Cat”上不存在属性“run”。类型“Cat”上不存在属性“run”。</span></span><br><span class="line">  <span class="comment">// pet.run()</span></span><br><span class="line">  <span class="comment">// 类型“Dog | Cat”上不存在属性“jump”。类型“Dog”上不存在属性“jump”。</span></span><br><span class="line">  <span class="comment">// pet.jump()</span></span><br><span class="line">  <span class="comment">// 类型保护</span></span><br><span class="line">  <span class="keyword">if</span> (pet <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">    pet.run()</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    pet.jump()</span><br><span class="line">  &#125;</span><br><span class="line">  pet.eat()</span><br><span class="line">  <span class="keyword">return</span> pet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的联合类型可能有点复杂：如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，<code>Dog</code> 具有一个 <code>run</code> 方法，我们不能确定一个 <code>Cat | Dog</code> 类型的变量是否有 <code>jump</code> 方法。 如果变量在运行时是 <code>Dog</code> 类型，那么调用 <code>pet.jump()</code> 就出错了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: <span class="string">"square"</span>;</span><br><span class="line">    size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">    kind: <span class="string">"rectangle"</span>;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: <span class="string">"circle"</span>;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>:</span><br><span class="line">            <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>:</span><br><span class="line">            <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(area(&#123;kind: <span class="string">'circle'</span>, radius: <span class="number">1</span>&#125;))</span><br></pre></td></tr></table></figure>

<p>上面的方法，如果遗漏了 <code>circle</code> 计算面试的实现逻辑，程序是不会报错的。如果想用TypeScript约束这种错误，进行错误提示可以使用下面的方法：</p>
<ul>
<li>设置函数返回值类型</li>
<li>设置never类型，设置default</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置函数返回值类型 "strictNullChecks": true</span></span><br><span class="line"><span class="comment">// 返回undefined会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"square"</span>:</span><br><span class="line">      <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"rectangle"</span>:</span><br><span class="line">      <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置default</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>:</span><br><span class="line">            <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>:</span><br><span class="line">            <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'circle'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 检测s是不是never类型，不是never类型，说明前面的分支判断有遗漏，会报错</span></span><br><span class="line">            <span class="keyword">return</span> <span class="function">(<span class="params">(<span class="params">e: never</span>) =&gt; &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="params">e</span>)&#125;</span>)(<span class="params">s</span>)</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>有些时候不仅需要限定变量的类型，而且还需要限定变量的取值在某个范围之类。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量联合类型</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="string">'a'</span> | <span class="string">'b'</span> | <span class="string">'c'</span></span><br><span class="line"><span class="keyword">let</span> c: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>索引类型会使用 <code>keyof T</code>， 索引类型查询操作符。</p>
<p>使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的JavaScript模式是从对象中选取属性的子集。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'11'</span>,</span><br><span class="line">  age: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>(<span class="params">obj: <span class="built_in">any</span>, keys: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> obj[key])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getValues(obj, [<span class="string">'sex'</span>]))</span><br></pre></td></tr></table></figure>

<p>在上面的代码中 <code>obj</code> 对象没有 <code>sex</code> 属性，TypeScript没有报错，如果想TypeScript进行相关报错提示，可以使用索引类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, keys: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> keys.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'Jarid'</span>,</span><br><span class="line">    age: <span class="number">35</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> strings: <span class="built_in">string</span>[] = getValues(person, [<span class="string">'name'</span>]); <span class="comment">// ok, string[]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码使用 <code>泛型变量 T</code> 约束 <code>obj对象</code> ，使用<code>泛型变量 K</code> 约束 <code>keys数组</code> ，并给 <code>K</code> 增加 <code>类型约束</code>，让它继承 <code>obj</code> 所有属性的<code>联合类型</code>。函数的返回值是一个数组，数组的元素的类型就是 <code>obj对象</code> 的属性 <code>K</code> 对应的类型。</p>
<p>编译器会检查 <code>name</code> 是否真的是 obj的一个属性。 本例还引入了几个新的类型操作符。 首先是 <code>keyof T</code>， 索引类型查询操作符。 对于任何类型 T， keyof T的结果为 T上已知的公共属性名的联合。 例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> personProps: keyof Person; <span class="comment">// 'name' | 'age'</span></span><br></pre></td></tr></table></figure>

<p>第二个操作符是 T[K]， 索引访问操作符。 </p>
<h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>一个常见的需求是将一个已知的类型每个属性都变为可选的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> PersonPartial &#123;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者我们想要一个只读版本：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> PersonReadonly &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span>;</span><br><span class="line">    readonly age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这在JavaScript里经常出现，TypeScript提供了从旧类型中创建新类型的一种方式 — <code>映射类型</code>。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。 例如，你可以令每个属性成为 readonly类型或可选的。 下面是一些例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只读</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像下面这样使用：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Person&gt;;</span><br><span class="line"><span class="keyword">type</span> ReadonlyPerson = Readonly&lt;Person&gt;;</span><br></pre></td></tr></table></figure>

<p>下面来看看最简单的映射类型和它的组成部分：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Keys = <span class="string">'option1'</span> | <span class="string">'option2'</span>;</span><br><span class="line"><span class="keyword">type</span> Flags = &#123; [K <span class="keyword">in</span> Keys]: <span class="built_in">boolean</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>它的语法与索引签名的语法类型，内部使用了 <code>for .. in</code>。 具有三个部分：</p>
<p>类型变量 <code>K</code>，它会依次绑定到每个属性。<br>字符串字面量联合的<code>Keys</code>，它包含了要迭代的属性名的集合。<br>属性的结果类型。<br>在个简单的例子里， <code>Keys</code>是硬编码的的属性名列表并且属性类型永远是 <code>boolean</code>，因此这个映射类型等同于：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Flags = &#123;</span><br><span class="line">    option1: <span class="built_in">boolean</span>;</span><br><span class="line">    option2: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见的映射类型"><a href="#常见的映射类型" class="headerlink" title="常见的映射类型"></a>常见的映射类型</h3><ul>
<li>Readonly：只读</li>
<li>Partial：可选</li>
<li>Pick：抽取子集</li>
<li>Record</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Obj &#123;</span><br><span class="line">    a: <span class="built_in">string</span>;</span><br><span class="line">    b: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只读</span></span><br><span class="line"><span class="keyword">type</span> ReadonlyObj = Readonly&lt;Obj&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选</span></span><br><span class="line"><span class="keyword">type</span> PartialObj = Partial&lt;Obj&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽取obj子集</span></span><br><span class="line"><span class="keyword">type</span> PickObj = Pick&lt;Obj, <span class="string">'a'</span> | <span class="string">'b'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RecordObj = Record&lt;<span class="string">'x'</span> | <span class="string">'y'</span>, Obj&gt;</span><br></pre></td></tr></table></figure>

<p><code>Readonly</code>， <code>Partial</code>和 <code>Pick</code>是 <code>同态</code> 的，意思是只作用于obj属性而不会引入新的属性。</p>
<p><code>Record</code> 映射会引入新属性，属于 <code>非同态</code> 映射类型。</p>
<h3 id="Readonly的实现原理"><a href="#Readonly的实现原理" class="headerlink" title="Readonly的实现原理"></a>Readonly的实现原理</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T readonly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出Readonly是一个可索引类型的泛型接口</p>
<ul>
<li>1)索引签名为P in keyof T :其中keyof T,表示类型T所有属性的联合类型</li>
<li>2)P in :相当于执行了一个for in操作,会把变量P依次绑定到T的所有属性上</li>
<li>3)索引签名的返回值就是一个索引访问操作符 : T[P]  这里代表属性P所指定的类型</li>
<li>4)最后再加上Readonly就把所有的属性变成了只读,这就是Readonly的实现原理</li>
</ul>
<h3 id="Partial的实现原理"><a href="#Partial的实现原理" class="headerlink" title="Partial的实现原理"></a>Partial的实现原理</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T optional</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可选和只读映射类型的实现原理几乎一样,知识把所有属性变为可选</p>
<h3 id="Pick映射类型的实现原理"><a href="#Pick映射类型的实现原理" class="headerlink" title="Pick映射类型的实现原理"></a>Pick映射类型的实现原理</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * From T, pick a set of properties whose keys are in the union K</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Pick映射类型有两个参数:</p>
<ul>
<li>第一个参数T,表示要抽取的目标对象</li>
<li>第二个参数K,具有一个约束:K一定要来自T所有属性字面量的联合类型,</li>
<li>即映射得到的新类型的属性一定要从K中选取</li>
</ul>
<h3 id="Record映射类型的实现原理"><a href="#Record映射类型的实现原理" class="headerlink" title="Record映射类型的实现原理"></a>Record映射类型的实现原理</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a type with a set of properties K of type T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RecordObj = Record&lt;<span class="string">'x'</span> | <span class="string">'y'</span>, Obj&gt;</span><br></pre></td></tr></table></figure>

<p>第一个参数是预定义的新属性，比如x，y。属性不来自Obj。</p>
<p>第二个参数就是已知类型Obj。</p>
<p>映射出的新类型所具有的属性由Record的第一个属性指定</p>
<p>而这些属性类型为第二个参数指定的已知类型</p>
<p>总结：<code>映射类型本质上，是预先定义的泛型接口，通常还会结合索引类型，获取对象的属性和属性值，从而将一个对象映射成我们想要的结构</code>。</p>
<h2 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h2><p>条件类型是一种由条件表达式所决定的类型。</p>
<p>条件类型使类型具有了不唯一性,同样增加了语言的灵活性。</p>
<h3 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T extends U ? X : Y</span><br></pre></td></tr></table></figure>

<p>若类型T可被赋值给类型U,那么结果类型就是X类型，否则就是Y类型</p>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件类型</span></span><br><span class="line"><span class="keyword">type</span> TypeName&lt;T&gt; = </span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">'string'</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">'number'</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">'boolean'</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">'undefined'</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">Function</span> ? <span class="string">'Function'</span> :</span><br><span class="line">    <span class="string">'object'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类型T1为条件类型,传入参数string,指定t1为string类型</span></span><br><span class="line"><span class="keyword">type</span> T1 = TypeName&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="comment">// 定义类型T2为条件类型,传入参数string[]</span></span><br><span class="line"><span class="keyword">type</span> T2 = TypeName&lt;<span class="built_in">string</span>[]&gt;</span><br></pre></td></tr></table></figure>

<h3 id="分步式条件类型"><a href="#分步式条件类型" class="headerlink" title="分步式条件类型"></a>分步式条件类型</h3><p>当类型T为联合类型时:</p>
<p>T为类型A和类型B的联合类型，结果类型会变成多个条件类型的联合类型，如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(A | B) <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure>

<p>可以进行拆解:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(A <span class="keyword">extends</span> U ? X : Y) | (B <span class="keyword">extends</span> U ? X : Y)</span><br></pre></td></tr></table></figure>

<p>这时定义的变量就会被推断为联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T3 = TypeName&lt;<span class="built_in">string</span> | <span class="built_in">string</span>[]&gt;</span><br></pre></td></tr></table></figure>

<p>传入 <code>string | string[]</code> 联合类型，T3被推断为 <code>&quot;string&quot; | &quot;object&quot;</code> 的联合类型。</p>
<h4 id="类型过滤"><a href="#类型过滤" class="headerlink" title="类型过滤"></a>类型过滤</h4><p>利用分步式条件类型以实现对类型的过滤</p>
<p>定义一个类型 <code>Diff</code>:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果T可以被赋值给U，结果类型为never类型，否则为T类型</span></span><br><span class="line"><span class="keyword">type</span> Diff&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T</span><br></pre></td></tr></table></figure>

<p>定义一个类型 <code>T4</code>:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T4 = Diff&lt;<span class="string">'a'</span> | <span class="string">'b'</span> | <span class="string">'c'</span>, <span class="string">'a'</span> | <span class="string">'e'</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>T4</code> 被推断了 <code>&quot;b&quot; | &quot;c&quot;</code>联合类型。</p>
<p>按照 <code>分步式条件类型</code> 拆解逻辑分析:</p>
<ul>
<li>1）首先 Diff被拆解为多个条件类型的联合类型：<code>Diff&lt;&quot;a&quot;, &quot;a&quot; | &quot;e&quot;&gt; | Diff&lt;&quot;b&quot;, &quot;a&quot; | &quot;e&quot;&gt; | Diff&lt;&quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;</code></li>
<li>2）进行条件类型判断<ul>
<li><code>&quot;a&quot;</code> 可以被赋值给字面量联合类型 <code>&quot;a&quot; | &quot;e&quot;</code>，返回never。</li>
<li><code>&quot;b&quot;</code> 不可以被赋值给字面量联合类型 <code>&quot;a&quot; | &quot;e&quot;</code>，返回 <code>&quot;b&quot;</code>。</li>
<li><code>&quot;c&quot;</code> 不可以被赋值给字面量联合类型 <code>&quot;a&quot; | &quot;e&quot;</code>，返回 <code>&quot;c&quot;</code></li>
<li>返回 <code>never | &quot;b&quot; | &quot;c&quot;</code></li>
</ul>
</li>
<li>3）最后，never和b，c的联合类型为’b’ | ‘c’</li>
</ul>
<p><code>Diff</code> 类型作用:</p>
<p><code>可以从类型T中过滤掉可以被赋值给类型U的类型</code>。</p>
<h4 id="基于-Diff-类型进行扩展"><a href="#基于-Diff-类型进行扩展" class="headerlink" title="基于 Diff 类型进行扩展"></a>基于 Diff 类型进行扩展</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果T可以被赋值给U，结果类型为never类型，否则为T类型</span></span><br><span class="line"><span class="keyword">type</span> Diff&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T</span><br></pre></td></tr></table></figure>

<p>可以基于 <code>Diff</code> 类型从T中移除不需要的类型，如undefined和null</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Diff扩展:从T中过滤掉undefined和null</span></span><br><span class="line"><span class="keyword">type</span> NotNull&lt;T&gt; = Diff&lt;T, <span class="literal">undefined</span> | <span class="literal">null</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤掉undefined和null，T5的类型就变成了string和number</span></span><br><span class="line"><span class="keyword">type</span> T5 = NotNull&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span> | <span class="literal">null</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>T5</code> 会过滤 <code>undefined</code> 和 <code>null</code> 类型，推断为 <code>string | number</code> 联合类型。</p>
<p>上边实现的 <code>Diff</code> 和 <code>NotNull</code> 类型，Ts库内置类型已经实现了相关功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Diff的内置类型叫做Exclude&lt;T, U&gt;</span><br><span class="line">NotNull的内置类型叫做NonNullable&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>此外,官方还预置了一些条件类型,如: <code>Extract&lt;T, U&gt;</code> 和 <code>Exclude&lt;T, U&gt;</code> 和 <code>ReturnType&lt;T&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Extract和Exclude相反</span><br><span class="line">Exclude：是从类型T中过滤掉可以赋值给类型U的类型</span><br><span class="line">Extract：可以从类型T中抽取出可以赋值给U的类型</span><br><span class="line">ReturnType：接受一个函数类型，并返回这个函数的返回值类型。</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T6 = Extract&lt;<span class="string">'a'</span> | <span class="string">'b'</span> | <span class="string">'c'</span>, <span class="string">'a'</span> | <span class="string">'e'</span>&gt;</span><br><span class="line"><span class="keyword">type</span> T7 = Exclude&lt;<span class="string">'a'</span> | <span class="string">'b'</span> | <span class="string">'c'</span>, <span class="string">'a'</span> | <span class="string">'e'</span>&gt;</span><br><span class="line"><span class="keyword">type</span> T8 = ReturnType&lt;<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never;</span><br></pre></td></tr></table></figure>

<p>类型推断 <code>T6</code> 为 <code>&quot;a&quot;</code>，类型。<br>类型推断 <code>T7</code> 为 <code>&#39;b&#39; | &#39;c&#39;</code> 联合类型。<br>类型推断 <code>T8</code> 为 <code>string</code> 类型。</p>
<h4 id="ReturnType源码分析"><a href="#ReturnType源码分析" class="headerlink" title="ReturnType源码分析"></a>ReturnType源码分析</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain the return type of a function type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T extends (...args: any) =&gt; any:</span><br><span class="line">  ReturnType要求参数T可以赋值给一个函数，这个函数有任意的参数，返回值类型也是任意的</span><br><span class="line">  由于函数返回值类型不确定，这里使用了infer关键字，表示待推断，延迟推断，需要根据实际的情况确定</span><br><span class="line"></span><br><span class="line">infer R ? R : any:</span><br><span class="line">  (infer R)，返回值类型 R 此时是不能确定的，只有在函数执行之后才知道，是一种延迟推断，所以用 infer 修饰。</span><br><span class="line">  如果实际类型是R，那么结果类型就是R，否则返回值类型就是any</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/211" target="_blank" rel="noopener">TypeScript开发实战</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript泛型</title>
    <url>/2020-04-02/TypeScript/TypeScript%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><p>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p><a id="more"></a>

<p>通俗理解：泛型就是解决 类 接口 方法的复用性、以及对不特定数据类型的支持(类型校验)</p>
<p><code>泛型</code>：不预先确定的数据类型，具体的类型在使用的时候才能确定。</p>
<p><code>泛型变量（类型参数）</code>是代表类型的参数。</p>
<h3 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h3><ul>
<li>函数和类可以支持多种类型，增加的程序的可扩展性</li>
<li>不必写多条函数重载，冗长的联合类型声明，增强代码的可读性</li>
<li>灵活控制类型之间的约束 </li>
</ul>
<h3 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个打印函数 只支持字符串参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">value: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载 参数支持字符串，字符串数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">value: <span class="built_in">string</span></span>): <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">value: <span class="built_in">string</span>[]</span>): <span class="title">string</span>[]</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">value: <span class="built_in">any</span></span>) </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">console</span>.<span class="title">log</span>(<span class="params">value</span>)</span>;</span></span><br><span class="line"><span class="function">  <span class="title">return</span> <span class="title">value</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型 参数支持字符串，字符串数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">string</span>[]</span>): <span class="title">string</span> | <span class="title">string</span>[] </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用any类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>any</code> 类型会导致这个函数可以接收任何类型的 arg 参数，但是这样就丢失了一些信息：忽略了输入参数类型和返回值类型必须一致，当调用者看到 <code>log</code> 函数时完全无法获知这种 <code>约束关系</code>。</p>
<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了 <code>类型参数</code>，它是一种特殊的变量，只用于表示 <code>类型</code> 而不是 <code>值</code>。</p>
<p>泛型函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span>  </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">log&lt;<span class="built_in">string</span>[]&gt;([<span class="string">'a'</span>, <span class="string">',b'</span>, <span class="string">'c'</span>])</span><br><span class="line">log([<span class="string">'a'</span>, <span class="string">',b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>

<p>这个版本的 <code>log</code> 函数叫做 <code>泛型</code>，因为它可以适用于多个类型。 不同于使用 any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>
<p>定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">log&lt;<span class="built_in">string</span>[]&gt;([<span class="string">'a'</span>, <span class="string">',b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>

<p>第二种方法更普遍。利用了<code>类型推断</code> – 即编译器会根据传入的参数自动地帮助我们确定 T 的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">log([<span class="string">'a'</span>, <span class="string">',b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>

<h3 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h3><p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span>  </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型定义函数类型</span></span><br><span class="line"><span class="keyword">let</span> myLog: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = log</span><br></pre></td></tr></table></figure>

<p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型定义函数类型</span></span><br><span class="line"><span class="keyword">let</span> myLog: &lt;U&gt;<span class="function">(<span class="params">arg: U</span>) =&gt;</span> U = log</span><br></pre></td></tr></table></figure>

<p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型定义函数类型</span></span><br><span class="line"><span class="keyword">let</span> myLog: &#123;&lt;T&gt;(arg: T) : T&#125; = log</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型约束了函数接口</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Log&#123;</span><br><span class="line">  &lt;T&gt;(arg: T) : T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myLog: Log = log</span><br></pre></td></tr></table></figure>

<p>上面的例子泛型仅仅约束了一个函数，我们甚至可以把泛型参数当作整个接口的一个参数，来约束接口的其他成员。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;</code> 而不只是 <code>Dictionary</code> ）。这样接口里的其它成员也能知道这个参数的类型了。</p>
<p>当泛型变量约束了整个接口时，在实现时必须指定类型。或在接口定义时指定一个默认类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Log&lt;T&gt; &#123;</span><br><span class="line">  (arg: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定默认string 类型的泛型接口</span></span><br><span class="line"><span class="keyword">interface</span> Log2&lt;T = string&gt; &#123;</span><br><span class="line">  (arg: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须指定类型</span></span><br><span class="line"><span class="keyword">let</span> myLog1: Log&lt;<span class="built_in">string</span>&gt; = log</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myLog2: Log&lt;<span class="built_in">number</span>&gt; = log</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认类型</span></span><br><span class="line"><span class="keyword">let</span> myLog3: Log2 = log</span><br></pre></td></tr></table></figure>

<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类看上去与泛型接口差不多。 泛型类使用（ <code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p>
<p>泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>
<p>实例化时可以指定类型，相应的方法，属性会受到泛型约束。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Log&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 静态成员不能引用类类型参数。</span></span><br><span class="line">  <span class="comment">// static run(value: T) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(value)</span></span><br><span class="line">  <span class="comment">//   return value</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  run(value: T) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化时可以指定类型</span></span><br><span class="line"><span class="keyword">let</span> log1=<span class="keyword">new</span> Log&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line"><span class="comment">// 泛型约束函数参数</span></span><br><span class="line">log1.run(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化没有指定参数</span></span><br><span class="line"><span class="keyword">let</span> log2 = <span class="keyword">new</span> Log()</span><br><span class="line"><span class="comment">// 函数调用可以传递任意类型参数</span></span><br><span class="line">log2.run(<span class="number">11</span>)</span><br><span class="line">log2.run(<span class="string">'111'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>在泛型函数内部使用类型变量时， 由于事先并不知道它是那种类型， 所以不能随意操作它的属性和方法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 类型“T”上不存在属性“length”。</span></span><br><span class="line">  <span class="built_in">console</span>.log(value.length);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数中 类型 T 上不一定存在 length 属性， 所以编译的时候就报错了。</p>
<p>这时，我们可以的对泛型进行约束，对这个函数传入的值约束必须包含 length 的属性， 这就是泛型约束:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Length&#123;</span><br><span class="line">  length:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Length</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value.length);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'111'</span>)</span><br><span class="line"><span class="comment">// 类型“11”的参数不能赋给类型“Length”的参数。</span></span><br><span class="line">log(<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>我们定义一个接口来描述约束条件，创建一个包含 <code>.length</code> 属性的接口，使用这个接口和 <code>extends</code> 关键字来实现约束。</p>
<h4 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h4><p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj 上，因此我们需要在这两个类型之间使用约束。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt; (<span class="params">obj: T, key: K </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123;a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">getProperty(x, <span class="string">'a'</span>) <span class="comment">// okay</span></span><br><span class="line">getProperty(x, <span class="string">'m'</span>) <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>泛型不仅可以保持类型的一致性，又不失程序的灵活性，同时也可以通过泛型约束，控制类型之间的约束。从代码的上来看，可读性，简洁性，远优于函数重载，联合类型声明以及 any 类型的声明。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/330.html" target="_blank" rel="noopener">基于TypeScript从零重构axios</a></li>
<li><a href="https://time.geekbang.org/course/intro/211" target="_blank" rel="noopener">TypeScript开发实战</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript类型检查机制</title>
    <url>/2020-04-02/TypeScript/TypeScript%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="类型检查机制"><a href="#类型检查机制" class="headerlink" title="类型检查机制"></a>类型检查机制</h2><p>TypeScript编译器在做类型检查时，所秉承的一些原则，以及表现出的一些行为。</p><p>作用：辅助开发，提高开发效率。</p><ul>
<li>类型推断</li>
<li>类型兼容性</li>
<li>类型保护</li>
</ul><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>不需要指定变量的类型（函数返回值的类型），TypeScript可以根据某些规则自动的为其推断出一个类型。</p><ul>
<li>基础类型推断</li>
<li>最佳通用类型推断</li>
<li>上下文类型推断</li>
</ul><a id="more"></a>




<p>基础类型推断，最佳通用类型推断 都是从右往左的推断，根据表达式右侧的值来推测表达式左侧变量的类型。</p>
<p>上下文类型推断是从左往右的推断，通常出现在 <code>事件处理</code> 中。</p>
<p>当<code>类型推断</code>不符合你的要求的时候，你可以使用 <code>类型断言 as</code>。</p>
<p><code>类型断言</code> 可以增加代码的灵活性，在改造旧代码时非常有效，但是类型断言要 <code>避免滥用</code> ，要对自己 <code>上下文</code> 充足的 <code>预判</code> ，<code>没有任何根据的类型断言</code>，会给你的代码 <code>安全隐患</code>。</p>
<h3 id="基础类型推断"><a href="#基础类型推断" class="headerlink" title="基础类型推断"></a>基础类型推断</h3><p>这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化变量 x:number</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认参数值 x:number</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">x=1</span>)=&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定函数返回值 z:number</span></span><br><span class="line"><span class="keyword">let</span> z = <span class="function">(<span class="params">x = 1</span>) =&gt;</span> &#123; x + <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h3><p>当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = [<span class="number">0</span>, <span class="number">1</span>, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure>

<p>为了推断 x 的类型，我们必须考虑所有元素的类型。 这里有两种选择：number 和 null。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>
<p>由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  numLegs: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Lion <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zoo = [<span class="keyword">new</span> Dog(), <span class="keyword">new</span> Lion()]</span><br></pre></td></tr></table></figure>

<p>这里，我们想让 zoo 被推断为 Animal[] 类型，但是这个数组里没有对象是 Animal 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> zoo: Animal[] = [<span class="keyword">new</span> Dog(), <span class="keyword">new</span> Lion()]</span><br></pre></td></tr></table></figure>

<p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Dog | Lion)[]</code></p>
<h3 id="上下文类型推断"><a href="#上下文类型推断" class="headerlink" title="上下文类型推断"></a>上下文类型推断</h3><p>有些时候，TypeScript 类型推断会按另外一种方式，我们称作 <code>上下文类型</code>；上下文类型的出现和表达式的类型以及所处的位置相关。通常出现在 <code>事件处理</code> 中，比如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">mouseEvent</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mouseEvent.clickTime)  <span class="comment">// Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子会得到一个类型错误，TypeScript 类型检查器使用 window.onmousedown 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 mouseEvent 参数的类型了，所以 mouseEvent 访问了一个不存在的属性，就报错了。</p>
<p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">mouseEvent:<span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mouseEvent.clickTime)  <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。</p>
<p>上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createZoo</span>(<span class="params"></span>): <span class="title">Animal</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">new</span> Bee(), <span class="keyword">new</span> Lion()]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zoo = createZoo()</span><br></pre></td></tr></table></figure>

<p>这个例子里，最佳通用类型有 3 个候选者：Animal，Bee 和 Lion。 其中，Animal 会被做为最佳通用类型。</p>
<h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><p>当一个 <code>类型Y（源类型）</code>可以被赋值给另一个 <code>类型X（目标类型）</code> 时，可以说类型X兼容类型Y。</p>
<p>源类型必须具备目标类型的 <code>必要属性</code>。</p>
<p>口诀：</p>
<ul>
<li>结构之间兼容：成员少的兼容成员多的</li>
<li>函数之间兼容：参数多的兼容参数少的</li>
</ul>
<p>TypeScript允许在类型兼容的变量之间相互赋值，这个特性增加了语言的 <code>灵活性</code>。</p>
<h3 id="接口兼容性"><a href="#接口兼容性" class="headerlink" title="接口兼容性"></a>接口兼容性</h3><p>接口之间相互兼容时，成员少的可以兼容成员多的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口兼容性</span></span><br><span class="line"><span class="keyword">interface</span> X &#123;</span><br><span class="line">  a: <span class="built_in">any</span>;</span><br><span class="line">  b: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Y &#123;</span><br><span class="line">  a: <span class="built_in">any</span>;</span><br><span class="line">  b: <span class="built_in">any</span>;</span><br><span class="line">  c: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x: X = &#123; a: <span class="number">1</span>, b: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">let</span> y: Y = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span> &#125;</span><br><span class="line">x = y</span><br><span class="line"><span class="comment">// Property 'c' is missing in type 'X' but required in type 'Y'.</span></span><br><span class="line">y = x</span><br></pre></td></tr></table></figure>

<h3 id="函数兼容性"><a href="#函数兼容性" class="headerlink" title="函数兼容性"></a>函数兼容性</h3><p>判断两个函数是不是兼容，通常发生在两个函数相互赋值的情况下，也就是函数作为参数的情况下。当给下面的高阶函数 <code>hof</code> 传递 <code>参数</code> 时，就会判断 <code>参数</code> 和 <code>Handler</code> 是不是类型兼容。<code>Handler 是目标类型</code>，<code>参数 是源类型</code>。</p>
<p>要目标类型，兼容源类型需要满足3个条件：</p>
<ul>
<li>1）参数个数<ul>
<li>目标函数的参数个数要多于源函数的参数个数</li>
<li>固定参数可以兼容剩余参数，可选参数</li>
<li>可选参数不兼容固定参数 ，剩余参数。可以设置 <code>strictFunctionTypes:false</code> 实现兼容</li>
<li>剩余参数兼容固定参数，可选参数</li>
</ul>
</li>
<li>2）参数类型<ul>
<li>目标函数的参数类型要包含源函数的参数类型</li>
</ul>
</li>
<li>3）函数返回值<ul>
<li>成员少的可以兼容多的</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数兼容性</span></span><br><span class="line"><span class="keyword">type</span> Handler = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hof</span>(<span class="params">handler: Handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1)参数个数</span></span><br><span class="line"><span class="keyword">let</span> handler1 = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> &#123; &#125;</span><br><span class="line">hof(handler1)</span><br><span class="line"><span class="keyword">let</span> handler2 = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span></span>) =&gt;</span> &#123; &#125;</span><br><span class="line"><span class="comment">// 类型“(a: number, b: number, c: number) =&gt; void”的参数不能赋给类型“Handler”的参数。</span></span><br><span class="line"><span class="comment">// hof(handler2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选参数和剩余参数</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">p1: <span class="built_in">number</span>, p2: <span class="built_in">number</span></span>) =&gt;</span> &#123; &#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="function">(<span class="params">p1?: <span class="built_in">number</span>, p2?: <span class="built_in">number</span></span>) =&gt;</span> &#123; &#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="function">(<span class="params">...args: <span class="built_in">number</span>[]</span>) =&gt;</span> &#123; &#125;</span><br><span class="line">a = b</span><br><span class="line">a = c</span><br><span class="line"><span class="comment">// 可选参数不兼容固定参数 ，剩余参数</span></span><br><span class="line"><span class="comment">// b = a</span></span><br><span class="line"><span class="comment">// b = c</span></span><br><span class="line">c = a</span><br><span class="line">c = b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2)参数类型</span></span><br><span class="line"><span class="keyword">let</span> handler3 = <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> &#123; &#125;</span><br><span class="line"><span class="comment">// hof(handler3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p3d = <span class="function">(<span class="params">point: Point3D</span>) =&gt;</span> &#123; &#125;</span><br><span class="line"><span class="keyword">let</span> p2d = <span class="function">(<span class="params">point: Point2D</span>) =&gt;</span> &#123; &#125;</span><br><span class="line">p3d = p2d</span><br><span class="line"><span class="comment">// 成员少的可以兼容多的</span></span><br><span class="line"><span class="comment">// p2d = p3d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3) 返回值类型</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; name: <span class="string">'Alice'</span> &#125;)</span><br><span class="line"><span class="keyword">let</span> g = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; name: <span class="string">'Alice'</span>, location: <span class="string">'Beijing'</span> &#125;)</span><br><span class="line">f = g</span><br><span class="line"><span class="comment">// 不能将类型“() =&gt; &#123; name: string; &#125;”分配给类型“() =&gt; &#123; name: string; location: string; &#125;”。Property 'location' is missing in type '&#123; name: string; &#125;' but required in type '&#123; name: string; location: string; &#125;'.</span></span><br><span class="line"><span class="comment">// g = f</span></span><br></pre></td></tr></table></figure>

<h3 id="函数重载兼容性"><a href="#函数重载兼容性" class="headerlink" title="函数重载兼容性"></a>函数重载兼容性</h3><p>函数重载包括两个部分，一部分是重载列表，一部分是具体实现。<code>列表中的函数是目标函数</code>，<code>具体实现是源函数</code>。程序运行时，编译器会查找重载列表，使用第一个匹配的定义，来执行源函数。</p>
<p>在函数重载中，目标函数参数个数多于或者等于源函数参数个数。并且返回值也要兼容目标函数返回值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数重载 </span></span><br><span class="line"><span class="comment">// 重载列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function">// 具体实现</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123; &#125;</span></span></span><br><span class="line"><span class="function"><span class="function">// <span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">a: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="function">// <span class="title">This</span> <span class="title">overload</span> <span class="title">signature</span> <span class="title">is</span> <span class="title">not</span> <span class="title">compatible</span> <span class="title">with</span> <span class="title">its</span> <span class="title">implementation</span> <span class="title">signature</span>.</span></span></span><br><span class="line"><span class="function"><span class="function">// <span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span>, c: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="function">// <span class="title">This</span> <span class="title">overload</span> <span class="title">signature</span> <span class="title">is</span> <span class="title">not</span> <span class="title">compatible</span> <span class="title">with</span> <span class="title">its</span> <span class="title">implementation</span> <span class="title">signature</span>.</span></span></span><br><span class="line"><span class="function"><span class="function">// <span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">a: <span class="built_in">any</span>, b: <span class="built_in">any</span></span>) </span>&#123;&#125;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="枚举类型兼容性"><a href="#枚举类型兼容性" class="headerlink" title="枚举类型兼容性"></a>枚举类型兼容性</h3><p>枚举类型和数字类型是完全兼容的。枚举之间是完全不兼容的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举兼容性</span></span><br><span class="line"><span class="keyword">enum</span> Fruit &#123; Apple, Banana &#125;</span><br><span class="line"><span class="keyword">enum</span> Color &#123; Red, Yellow &#125;</span><br><span class="line"><span class="keyword">let</span> fruit: Fruit.Apple = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> no: <span class="built_in">number</span> = Fruit.Apple</span><br><span class="line"><span class="comment">// 不能将类型“Fruit.Apple”分配给类型“Color.Red”。</span></span><br><span class="line"><span class="keyword">let</span> color: Color.Red = Fruit.Apple</span><br></pre></td></tr></table></figure>

<h3 id="类兼容性"><a href="#类兼容性" class="headerlink" title="类兼容性"></a>类兼容性</h3><p>比较两个类的兼容性时，类的构造函数和静态成员不参与比较。</p>
<p>如果两个类具有相同的实例成员，它们的实例就可以完全相互兼容。</p>
<p>当类中有私有成员时，这两个类就不相互兼容了，只有父类和子类之间可以相互兼容。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类兼容性</span></span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">p: <span class="built_in">number</span>, q: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">  id: <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> B &#123;</span><br><span class="line">  <span class="keyword">static</span> s = <span class="number">1</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">p: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">  id: <span class="built_in">number</span> = <span class="number">2</span></span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span> = <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> C <span class="keyword">extends</span> A &#123; &#125;</span><br><span class="line"><span class="keyword">let</span> aa = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> bb = <span class="keyword">new</span> B(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 不能将类型“B”分配给类型“A”。类型具有私有属性“name”的单独声明。</span></span><br><span class="line">aa = bb</span><br><span class="line"><span class="comment">// 不能将类型“A”分配给类型“B”。类型具有私有属性“name”的单独声明。</span></span><br><span class="line">bb = aa</span><br><span class="line"><span class="keyword">let</span> cc = <span class="keyword">new</span> C(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">aa = cc</span><br><span class="line">cc = aa</span><br></pre></td></tr></table></figure>

<h3 id="泛型兼容性"><a href="#泛型兼容性" class="headerlink" title="泛型兼容性"></a>泛型兼容性</h3><p>泛型接口中，只有泛型变量被接口成员使用才影响泛型的兼容性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;</span><br><span class="line">  value: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1: Empty&lt;<span class="built_in">number</span>&gt; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2: Empty&lt;<span class="built_in">string</span>&gt; = &#123;&#125;;</span><br><span class="line"><span class="comment">// 不能将类型“Empty&lt;string&gt;”分配给类型“Empty&lt;number&gt;”。不能将类型“string”分配给类型“number”。</span></span><br><span class="line">obj1 = obj2</span><br></pre></td></tr></table></figure>

<p>上面如果 泛型变量 T 如果没有被成员变量使用则兼容</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// value: T //没有使用泛型变量 T</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1: Empty&lt;<span class="built_in">number</span>&gt; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2: Empty&lt;<span class="built_in">string</span>&gt; = &#123;&#125;;</span><br><span class="line">obj1 = obj2</span><br></pre></td></tr></table></figure>

<p>如果两个泛型函数的定义相同，但是没有指定类型参数，那么它们之间也是可以互相兼容的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> log1 = &lt;T&gt;(x: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'x'</span>)</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> log2 = &lt;U&gt;(y: U): <span class="function"><span class="params">U</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'y'</span>)</span><br><span class="line">  <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">log1 = log2</span><br></pre></td></tr></table></figure>

<h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>TypeScript能够在特定的区块中保证变量属于某种确定的类型。</p>
<p>可以在此区块中引用此类型的属性，或者调用此类型的方法。</p>
<p>问题引入</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Type &#123; Strong, Week &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> JavaScript &#123;</span><br><span class="line">  helloJavaScript() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello JavaScript'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  js: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLanguage</span>(<span class="params"><span class="keyword">type</span>: Type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lang = <span class="keyword">type</span> === Type.Strong ? <span class="keyword">new</span> Java() : <span class="keyword">new</span> JavaScript();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型“Java | JavaScript”上不存在属性“helloJava”。类型“JavaScript”上不存在属性“helloJava”。</span></span><br><span class="line">  <span class="comment">// if (lang.helloJava) &#123;</span></span><br><span class="line">  <span class="comment">//   lang.helloJava();</span></span><br><span class="line">  <span class="comment">// &#125; else &#123;</span></span><br><span class="line">  <span class="comment">//   // 类型“Java | JavaScript”上不存在属性“helloJavaScript”。类型“Java”上不存在属性“helloJavaScript”。</span></span><br><span class="line">  <span class="comment">//   lang.helloJavaScript();</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// 类型断言</span></span><br><span class="line">  <span class="keyword">if</span> ((lang <span class="keyword">as</span> Java).helloJava)&#123;</span><br><span class="line">    (lang <span class="keyword">as</span> Java).helloJava();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    (lang <span class="keyword">as</span> JavaScript).helloJavaScript();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getLanguage(Type.Week)</span><br></pre></td></tr></table></figure>

<p>上面的代码使用类型断言，代码可读性很差，使用 <code>类型保护</code> 机制可以解决这个问题，可以提前预判变量的类型。</p>
<p>可以通过下面的方法解决：</p>
<ul>
<li>instanceof：判断实例是不是属于某个类</li>
<li>in：判断一个属性是否属于某个对象</li>
<li>typeof：判断一个变量的类型</li>
<li>类型保护函数：某些判断可能不是一条语句能够搞定的，需要更多复杂的逻辑，适合封装到一个函数内</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Type &#123; Strong, Week &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Java &#123;</span><br><span class="line">    helloJava() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello Java'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    java: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> JavaScript &#123;</span><br><span class="line">    helloJavaScript() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello JavaScript'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    js: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型保护函数</span></span><br><span class="line"><span class="comment">// lang is Java：类型谓词</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isJava</span>(<span class="params">lang: Java | JavaScript</span>): <span class="title">lang</span> <span class="title">is</span> <span class="title">Java</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (lang <span class="keyword">as</span> Java).helloJava !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLanguage</span>(<span class="params"><span class="keyword">type</span>: Type, x: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lang = <span class="keyword">type</span> === Type.Strong ? <span class="keyword">new</span> Java() : <span class="keyword">new</span> JavaScript();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isJava(lang)) &#123;</span><br><span class="line">        lang.helloJava();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lang.helloJavaScript();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if ((lang as Java).helloJava) &#123;</span></span><br><span class="line">    <span class="comment">//     (lang as Java).helloJava();</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     (lang as JavaScript).helloJavaScript();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// instanceof</span></span><br><span class="line">    <span class="comment">// if (lang instanceof Java) &#123;</span></span><br><span class="line">    <span class="comment">//     lang.helloJava()</span></span><br><span class="line">    <span class="comment">//     // lang.helloJavaScript()</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     lang.helloJavaScript()</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// in</span></span><br><span class="line">    <span class="comment">// if ('java' in lang) &#123;</span></span><br><span class="line">    <span class="comment">//     lang.helloJava()</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     lang.helloJavaScript()</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// typeof</span></span><br><span class="line">    <span class="comment">// if (typeof x === 'string') &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(x.length)</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(x.toFixed(2))</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lang;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getLanguage(Type.Week, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/330.html" target="_blank" rel="noopener">基于TypeScript从零重构axios</a></li>
<li><a href="https://time.geekbang.org/course/intro/211" target="_blank" rel="noopener">TypeScript开发实战</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript类</title>
    <url>/2020-04-02/TypeScript/TypeScript%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>在TypeScript中，<code>类的成员属性</code> 都是 <code>实例</code> 属性，而不是原型属性，<code>类的成员方法</code> 都是 <code>原型</code> 方法。</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><ul>
<li>派生类的构造函数必须包含 <code>super</code> 调用。</li>
<li>访问派生类的构造函数中的 <code>this</code> 前，必须调用 <code>super</code>。</li>
<li><code>super</code> 代表父类的实例</li>
<li>调用 <code>super()</code>，会执行基类的构造函数</li>
</ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Dog &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  run() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog= <span class="keyword">new</span> Dog(<span class="string">'11'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Husky <span class="keyword">extends</span> Dog &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>,color: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 报错 派生类的构造函数必须包含 "super" 调用。访问派生类的构造函数中的 "this" 前，必须调用 "super"。</span></span><br><span class="line">    <span class="comment">// super(name);</span></span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line">  color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<h3 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h3><ul>
<li>public: 所有人可见（默认）。</li>
<li>private: 只能被类本身调用，不能被类的实例调用，也不能被子类调用。当成员被标记成 private 时，它就不能在声明它的类的外部访问</li>
<li>protected: 只能在类或类的子类中调用，不能被类的实例调用。</li>
<li>readonly: 只读，只读属性必须初始化。</li>
<li>static: 静态属性，只能通过类名访问，可以被继承。</li>
<li>除了类的成员可以添加修饰符，构造函数参数也可以添加修饰符</li>
</ul>
<h4 id="private修饰符"><a href="#private修饰符" class="headerlink" title="private修饰符"></a>private修饰符</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性“name”为私有属性，只能在类“Animal”中访问。</span></span><br><span class="line"><span class="keyword">new</span> Animal(<span class="string">'Cat'</span>).name</span><br></pre></td></tr></table></figure>

<p>当给类的构造函数添加 <code>private</code> 修饰符，表示这个类既不能实例化，也不能继承。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类“Animal”的构造函数是私有的，仅可在类声明中访问。</span></span><br><span class="line"><span class="keyword">new</span> Animal(<span class="string">"Cat"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法扩展类“Animal”。类构造函数标记为私有。</span></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="protected修饰符"><a href="#protected修饰符" class="headerlink" title="protected修饰符"></a>protected修饰符</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">protected</span> name:<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">"Cat"</span>);</span><br><span class="line"><span class="comment">// 属性“name”受保护，只能在类“Animal”及其子类中访问。</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'1111'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当给类的构造函数添加 <code>protected</code> 修饰符时，表示这个类不能被实例化，只能被继承。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">protected</span> name:<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类“Animal”的构造函数是受保护的，仅可在类声明中访问。</span></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">"Cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal.name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'1111'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>只能被继承不能实例化。抽象类可以包含成员的实现细节。 <code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<p>抽象类中可以定义一个方法的具体实现，这样就实现了方法的复用。</p>
<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符。</p>
<p>抽象类中抽象方法，可在不同子类中实现类的多态。</p>
<p>子类必须实现抽象类的抽象方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"eat"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> sleep(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法创建抽象类的实例。</span></span><br><span class="line"><span class="comment">// let animal = new Animal();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"1111"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 子类必须实现抽象类的抽象方法</span></span><br><span class="line">  sleep() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"dog sleep"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">'111'</span>);</span><br><span class="line">dog.eat();</span><br></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在父类中定义一个抽象方法，在多个子类中对这个方法有不同的实现。在程序运行时，会根据不同的对象，执行不同的操作，这样就实现了运行时绑定。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/330.html" target="_blank" rel="noopener">基于TypeScript从零重构axios</a></li>
<li><a href="https://time.geekbang.org/course/intro/211" target="_blank" rel="noopener">TypeScript开发实战</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript函数</title>
    <url>/2020-04-01/TypeScript/TypeScript%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。</p><ul>
<li>TypeSCript中函数实参，形参个数必须一一对应，且类型也一一对应。</li>
<li>函数必选参数不能位于可选参数之后。</li>
<li>函数必选参数前的参数如果要取默认值需要赋值undefined占位，必选参数后的参数获取默认值不需要传undefined。</li>
<li>在 JavaScript 里，你可以使用 arguments 来访问所有传入的参数。在 TypeScript 里，你可以把所有参数收集到一个变量里，剩余参数会被当做个数不限的可选参数。</li>
</ul><a id="more"></a>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用变量定义函数类型</span></span><br><span class="line"><span class="keyword">let</span> add1: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名定义函数类型</span></span><br><span class="line"><span class="keyword">type</span> add2 = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数类型接口定义函数类型</span></span><br><span class="line"><span class="keyword">interface</span> add3 &#123;</span><br><span class="line">    (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeScript 的类型系统会推断出参数类型，函数的返回值类型是通过其返回值推断出来的</span></span><br><span class="line"><span class="keyword">let</span> add: add3 = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应有 2 个参数，但获得 3 个。</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必选参数不能位于可选参数后。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add4</span>(<span class="params">x:<span class="built_in">number</span>,y?:<span class="built_in">number</span>,z:<span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y ? x + y : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必选参数前的参数如果要取默认值需要赋值undefined占位，必选参数后的参数获取默认值不需要传undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add5</span>(<span class="params">x: <span class="built_in">number</span>, y = 0, z: <span class="built_in">number</span>, q = 1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z + q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>在C++或者java等静态语言中，两个函数名称相同，但是参数类型不同或者参数个数不同，就实现了函数重载。</p>
<p>函数重载的好处是：不需要为功能相似的函数起不同的名称，增强了函数的可读性。</p>
<p>函数重载一般在实现时用any类型</p>
<p>编译器选择正确的检查类型时，它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...rest: <span class="built_in">number</span>[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...rest: <span class="built_in">string</span>[]</span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...rest: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = rest[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> first === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rest.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> first === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rest.join(<span class="string">''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">//3 </span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)) <span class="comment">// 'abc'</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/330.html" target="_blank" rel="noopener">基于TypeScript从零重构axios</a></li>
<li><a href="https://time.geekbang.org/course/intro/211" target="_blank" rel="noopener">TypeScript开发实战</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript接口</title>
    <url>/2020-04-01/TypeScript/TypeScript%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口可以约束对象，函数，类的结构和类型，这是一种代码协作的契约，必须遵守，不能改变。</p><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p><ul>
<li>接口关键字：interface</li>
<li>类型断言：用as 或者&lt;&gt;的形式 ，后者在react中使用会出问题</li>
<li>可选属性：通过？来设置</li>
<li>只读属性：通过readonly 来设置</li>
<li>当不确定接口中属性个数时需要使用 <code>索引签名</code></li>
<li>索引签名包括<code>字符串索引签名</code>和<code>数字索引签名</code></li>
<li>当接口中定义了一个索引后，例如设置了 【x:string】= string，就不能设置y：number了。因为设置了【x:string】= string相当于这个接口的字符串索引返回值都是字符串，而y：number违背这一原则，冲突了</li>
<li>可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。因为 数字索引或转化为字符串索引，而转化的这部分索引对应的值的类型范围 超过了 字符串索引类型的范围，就会报错，相当于超出范围。</li>
</ul><a id="more"></a>


<h3 id="readonly-vs-const"><a href="#readonly-vs-const" class="headerlink" title="readonly vs const"></a>readonly vs const</h3><p>做为变量使用的话用 const，若做为属性则使用 readonly。</p>
<h3 id="对象类型接口"><a href="#对象类型接口" class="headerlink" title="对象类型接口"></a>对象类型接口</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>; <span class="comment">// 可选属性</span></span><br><span class="line">  width?: <span class="built_in">number</span>; <span class="comment">// 可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123; color: <span class="string">"white"</span>, area: <span class="number">100</span> &#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型“&#123; colour: string; width: number; &#125;”的参数不能赋给类型“SquareConfig”的参数。</span></span><br><span class="line"><span class="comment">// 对象文字只能指定已知的属性，但“colour”中不存在类型“SquareConfig”。是否要写入 color?</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<p>绕过这种检测的方式有三种：</p>
<ul>
<li>将对象字面量赋值给一个变量，直接操作变量</li>
<li>使用<code>类型断言</code></li>
<li>使用<code>索引签名</code></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将对象字面量赋值给一个变量</span></span><br><span class="line"><span class="keyword">let</span> config = &#123; colour: <span class="string">"red"</span>, width: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型断言</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; width: <span class="number">100</span>, opacity: <span class="number">0.5</span> &#125; <span class="keyword">as</span> SquareConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用索引签名</span></span><br><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用变量定义函数类型</span></span><br><span class="line"><span class="keyword">let</span> add1: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名定义函数类型</span></span><br><span class="line"><span class="keyword">type</span> add2 = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数类型接口定义函数类型</span></span><br><span class="line"><span class="keyword">interface</span> add3 &#123;</span><br><span class="line">    (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeScript 的类型系统会推断出参数类型，函数的返回值类型是通过其返回值推断出来的</span></span><br><span class="line"><span class="keyword">let</span> add: add3 = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure>

<h3 id="类类型接口"><a href="#类类型接口" class="headerlink" title="类类型接口"></a>类类型接口</h3><p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p>
<ul>
<li>类实现接口时，必须实现接口中所有属性和方法</li>
<li>类可以扩展新的属性和方法</li>
<li>接口只能约束类的公有成员</li>
<li>接口不能约束类的构造函数</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Human &#123;</span><br><span class="line">    <span class="comment">// 类“Asian”错误实现接口“Human”。类型“Asian”提供的内容与签名“new (name: string): void”不匹配。</span></span><br><span class="line">    <span class="comment">// new(name: string): void</span></span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    eat(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Asian <span class="keyword">implements</span> Human &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    <span class="comment">// 类“Asian”错误实现接口“Human”。属性“eat”在类型“Asian”中是私有属性，但在类型“Human”中不是。</span></span><br><span class="line">    <span class="comment">// private eat() &#123;&#125;</span></span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">    age: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">    sleep() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &#123;&#125; <span class="keyword">as</span> Square</span><br><span class="line">square.color = <span class="string">'blue'</span></span><br><span class="line">square.sideLength = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">  penWidth: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &#123;&#125; <span class="keyword">as</span> Square</span><br><span class="line">square.color = <span class="string">'blue'</span></span><br><span class="line">square.sideLength = <span class="number">10</span></span><br><span class="line">square.penWidth = <span class="number">5.0</span></span><br></pre></td></tr></table></figure>

<h3 id="混合类型接口"><a href="#混合类型接口" class="headerlink" title="混合类型接口"></a>混合类型接口</h3><p>一个接口既可以定义一个函数也可以像对象一样拥有属性和方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个类库接口 </span></span><br><span class="line"><span class="comment">// lib是一个函数，并且拥有version属性，doSomeThing方法</span></span><br><span class="line"><span class="keyword">interface</span> Lib&#123;</span><br><span class="line">    (): <span class="built_in">void</span>;</span><br><span class="line">    version: <span class="built_in">string</span>;</span><br><span class="line">    doSomeThing(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLib</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lib: Lib = <span class="function">(<span class="params">(<span class="params"></span>) =&gt; &#123;&#125;</span>) <span class="params">as</span> <span class="params">Lib</span>; // 类型断言</span></span><br><span class="line"><span class="function">  <span class="params">lib</span>.<span class="params">version</span> = "1.0";</span></span><br><span class="line"><span class="function">  <span class="params">lib</span>.<span class="params">doSomeThing</span> = <span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> lib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>接口把类的成员都进行了抽象，也就是只有类的结果，而没有具体实现。</p>
<p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<p>注意，这么做的目的是限定接口的使用范围，并不会真正为这个接口添加类的私有和受保护属性（实际上接口也没有这种类型的属性），而这个限定范围就是：只能由子类来实现这个接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Parent &#123;</span><br><span class="line">  state = <span class="number">1</span></span><br><span class="line">  <span class="keyword">private</span> state2 = <span class="number">0</span></span><br><span class="line">  <span class="keyword">protected</span> state3 = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> ChildInterface <span class="keyword">extends</span> Parent &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> Child1 <span class="keyword">extends</span> Parent <span class="keyword">implements</span> ChildInterface &#123;</span><br><span class="line">  showMsg() &#123;</span><br><span class="line">    <span class="comment">// console.log(this.state2); // 属性“state2”为私有属性，只能在类“Parent”中访问。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state3) <span class="comment">// 可以访问来自接口的被保护属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类“Child2”错误实现接口“ChildInterface”。Type 'Child2' is missing the following properties from type 'ChildInterface': state, state2, state3</span></span><br><span class="line"><span class="keyword">class</span> Child2 <span class="keyword">implements</span> ChildInterface &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例对象可以访问父类的私有或受保护的成员</span></span><br><span class="line"><span class="keyword">let</span> bus = <span class="keyword">new</span> Child1()</span><br><span class="line">bus.showMsg()</span><br><span class="line"><span class="comment">// Bus &#123;state: 1, state2: 0, state3: 3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bus)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/330.html" target="_blank" rel="noopener">基于TypeScript从零重构axios</a></li>
<li><a href="https://time.geekbang.org/course/intro/211" target="_blank" rel="noopener">TypeScript开发实战</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript基础类型</title>
    <url>/2020-04-01/TypeScript/TypeScript%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="类型基础"><a href="#类型基础" class="headerlink" title="类型基础"></a>类型基础</h2><p>强类型语言：不允许改变变量的数据类型，除非进行强制类型转换。</p><p>弱类型语言：变量可以被赋予为不同的数据类型。</p><p>静态类型：在编译阶段确定所有变量的类型。</p><p>动态类型：在执行阶段确定所有变量的类型。</p><h3 id="静态类型与动态类型对比"><a href="#静态类型与动态类型对比" class="headerlink" title="静态类型与动态类型对比"></a>静态类型与动态类型对比</h3><table>
<thead>
<tr>
<th>静态类型语言</th>
<th>动态类型语言</th>
</tr>
</thead>
<tbody><tr>
<td>对类型极其严格</td>
<td>对类型宽松</td>
</tr>
<tr>
<td>立即发现错误</td>
<td>bug隐藏比较深</td>
</tr>
<tr>
<td>运行时性能好</td>
<td>运行时性能差</td>
</tr>
<tr>
<td>自文档化</td>
<td>可读性差</td>
</tr>
</tbody></table><a id="more"></a>




<p>动态类型语言支持者：</p>
<ul>
<li>性能是可以改善的（V8引擎），语言灵活性更重要</li>
<li>隐藏的错误可以通过单元测试发现</li>
<li>文档可以通过工具生成</li>
</ul>
<h2 id="TypeScript基础类型"><a href="#TypeScript基础类型" class="headerlink" title="TypeScript基础类型"></a>TypeScript基础类型</h2><p>TypeScript增加了 <code>void</code>，<code>any</code>，<code>never</code>，<code>元组</code>，<code>枚举</code>，<code>高级类型</code></p>
<h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p>作用：相当于强类型语言中的类型申明<br>语法：（变量名/函数）: type</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isBoolean: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0x14</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b10100</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o24</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">'bob'</span></span><br><span class="line">name = <span class="string">'smith'</span></span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h3><p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 和 <code>void</code> 相似，它们的本身的类型用处不是很大：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p>
<p>然而，当你指定了 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。</p>
<h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1: symbol=Symbol()</span><br><span class="line"><span class="keyword">let</span> s2: symbol=Symbol();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(s1===s2)</span><br></pre></td></tr></table></figure>

<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p><code>Object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code> 之外的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: <span class="built_in">Object</span> = &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// 类型“Object”上不存在属性“x”。</span></span><br><span class="line">obj.x</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2: &#123; x: <span class="built_in">number</span>, y: <span class="built_in">number</span> &#125; = &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;</span><br><span class="line">obj2.x</span><br></pre></td></tr></table></figure>

<h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>] <span class="comment">// OK</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>] <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)) <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)) <span class="comment">// Error, 'number' 不存在 'substr' 方法</span></span><br></pre></td></tr></table></figure>

<p>当访问一个越界的元素，会使用联合类型替代：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">'world'</span> <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()) <span class="comment">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span> <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>

<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>
<p><strong>注意</strong>：自从 TyeScript 3.1 版本之后，访问越界元素会报错，我们不应该再使用该特性。</p>
<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量。</p>
<p>通过 <code>any</code> 类型，实现对js的兼容</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line">notSure = <span class="string">'maybe a string instead'</span></span><br><span class="line">notSure = <span class="literal">false</span> <span class="comment">// 也可以是个 boolean</span></span><br></pre></td></tr></table></figure>

<p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">'free'</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'This is my warning message'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p><code>never</code> 永远不会有返回值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</p>
<p><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code>never</code> 的子类型或可以赋值给<code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>
<p>下面是一些返回 <code>never</code> 类型的函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> error(<span class="string">"Something failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死循环函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<p><code>enum</code> 是一组有名字的常量的集合。</p>
<h4 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数字枚举</span></span><br><span class="line"><span class="keyword">enum</span> Role &#123;</span><br><span class="line">  Reporter = <span class="number">1</span>, <span class="comment">//如果不赋值，默认是0，后面的枚举成员值递增</span></span><br><span class="line">  Developer,</span><br><span class="line">  Maintainer,</span><br><span class="line">  Owner,</span><br><span class="line">  Guest</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Role.Reporter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cannot assign to 'Reporter' because it is a read-only property.</span></span><br><span class="line">Role.Reporter = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="comment">// 反向映射</span></span><br><span class="line"><span class="keyword">var</span> Role;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Role</span>) </span>&#123;</span><br><span class="line">    Role[Role[<span class="string">"Reporter"</span>] = <span class="number">1</span>] = <span class="string">"Reporter"</span>;</span><br><span class="line">    Role[Role[<span class="string">"Developer"</span>] = <span class="number">2</span>] = <span class="string">"Developer"</span>;</span><br><span class="line">    Role[Role[<span class="string">"Maintainer"</span>] = <span class="number">3</span>] = <span class="string">"Maintainer"</span>;</span><br><span class="line">    Role[Role[<span class="string">"Owner"</span>] = <span class="number">4</span>] = <span class="string">"Owner"</span>;</span><br><span class="line">    Role[Role[<span class="string">"Guest"</span>] = <span class="number">5</span>] = <span class="string">"Guest"</span>;</span><br><span class="line">&#125;)(Role || (Role = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串枚举</span></span><br><span class="line"><span class="comment">// 不支持反向映射</span></span><br><span class="line"><span class="keyword">enum</span> Message &#123;</span><br><span class="line">    Success = <span class="string">'恭喜你，成功了'</span>,</span><br><span class="line">    Fail = <span class="string">'抱歉，失败了'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h4><p><code>数字枚举</code>，<code>字符串枚举</code> 混用，构成异构枚举，容易造成混淆，不推荐使用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Answer &#123;</span><br><span class="line">    N,</span><br><span class="line">    Y = <span class="string">'Yes'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h4><p>为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 <code>const</code> 枚举。 常量枚举通过在枚举上使用 <code>const</code> 修饰符来定义。</p>
<p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。常量枚举不允许包含计算成员。</p>
<p>常量枚举不允许包含计算成员。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常量枚举</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br></pre></td></tr></table></figure>

<h4 id="枚举成员"><a href="#枚举成员" class="headerlink" title="枚举成员"></a>枚举成员</h4><p>枚举成员的值是只读属性，不允许修改。</p>
<p>枚举成员类型分为常量枚举（const member），需要被计算的枚举成员（computed member）</p>
<p>常量枚举包括三种情况：</p>
<ul>
<li>没有初始值</li>
<li>对已有枚举成员的引用</li>
<li>常量表达式</li>
</ul>
<p>常量枚举成员会在编译时计算出结果，以常量的形式出现在运行时环境</p>
<p>需要被计算的枚举成员（computed member），是非常量的表达式，这些枚举成员的值不会在编译阶段计算，而会保留到程序的执行阶段计算</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Char &#123;</span><br><span class="line">  <span class="comment">// const member</span></span><br><span class="line">  a,</span><br><span class="line">  b = Char.a,</span><br><span class="line">  c = <span class="number">1</span> + <span class="number">3</span>,</span><br><span class="line">  <span class="comment">// computed member</span></span><br><span class="line">  d = <span class="built_in">Math</span>.random(),</span><br><span class="line">  e = <span class="string">"123"</span>.length,</span><br><span class="line">  <span class="comment">// computed member后的枚举成员必须赋予初始值</span></span><br><span class="line">  f = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">var</span> Char;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Char</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// const member</span></span><br><span class="line">    Char[Char[<span class="string">"a"</span>] = <span class="number">0</span>] = <span class="string">"a"</span>;</span><br><span class="line">    Char[Char[<span class="string">"b"</span>] = <span class="number">0</span>] = <span class="string">"b"</span>;</span><br><span class="line">    Char[Char[<span class="string">"c"</span>] = <span class="number">4</span>] = <span class="string">"c"</span>;</span><br><span class="line">    <span class="comment">// computed member</span></span><br><span class="line">    Char[Char[<span class="string">"d"</span>] = <span class="built_in">Math</span>.random()] = <span class="string">"d"</span>;</span><br><span class="line">    Char[Char[<span class="string">"e"</span>] = <span class="string">"123"</span>.length] = <span class="string">"e"</span>;</span><br><span class="line">    <span class="comment">// computed member后的枚举成员必须赋予初始值</span></span><br><span class="line">    Char[Char[<span class="string">"f"</span>] = <span class="number">4</span>] = <span class="string">"f"</span>;</span><br><span class="line">&#125;)(Char || (Char = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">'this is a string'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length</span><br></pre></td></tr></table></figure>

<p>另一个为 <code>as</code> 语法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">'this is a string'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br></pre></td></tr></table></figure>

<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 <code>as</code> 语法断言是被允许的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/330.html" target="_blank" rel="noopener">基于TypeScript从零重构axios</a></li>
<li><a href="https://time.geekbang.org/course/intro/211" target="_blank" rel="noopener">TypeScript开发实战</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript library starter</title>
    <url>/2020-03-24/TypeScript/TypeScript-library-starter/</url>
    <content><![CDATA[<h2 id="TypeScript-library-starter"><a href="#TypeScript-library-starter" class="headerlink" title="TypeScript library starter"></a>TypeScript library starter</h2><p>一个开源的 TypeScript 开发基础库的脚手架工具，可以帮助我们快速初始化一个 TypeScript 项目。<a href="https://github.com/alexjoverm/typescript-library-starter" target="_blank" rel="noopener">官网</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># YOURFOLDERNAME 项目名称</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/alexjoverm/typescript-library-starter.git YOURFOLDERNAME</span><br><span class="line"><span class="built_in">cd</span> YOURFOLDERNAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run npm install and write your library name when asked. That's all!</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>通过 git clone 把项目代码拉取到本地，并指定项目名称，然后运行 npm install 安装依赖。</p>
<h2 id="项目目录介绍"><a href="#项目目录介绍" class="headerlink" title="项目目录介绍"></a>项目目录介绍</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── CONTRIBUTING.md  </span><br><span class="line">├── LICENSE ├── README.md  </span><br><span class="line">├── code-of-conduct.md  </span><br><span class="line">├── node_modules  </span><br><span class="line">├── package-lock.json  </span><br><span class="line">├── package.json  </span><br><span class="line">├── rollup.config.ts // rollup 配置文件  </span><br><span class="line">├── src // 源码目录  </span><br><span class="line">├── test // 测试目录  </span><br><span class="line">├── tools // 发布到 GitHup pages 以及 发布到 npm 的一些配置脚本工具  </span><br><span class="line">├── tsconfig.json // TypeScript 编译配置文件  </span><br><span class="line">└── tslint.json // TypeScript lint 文件</span><br></pre></td></tr></table></figure>

<h2 id="优秀工具集成"><a href="#优秀工具集成" class="headerlink" title="优秀工具集成"></a>优秀工具集成</h2><p>使用 TypeScript library starter 创建的项目集成了很多优秀的开源工具：</p>
<p>使用  <strong><a href="https://rollupjs.org/" target="_blank" rel="noopener">RollupJS</a></strong> 帮助我们打包。<br>使用 <strong><a href="https://github.com/prettier/prettier" target="_blank" rel="noopener">Prettier</a></strong> 和 <strong><a href="https://palantir.github.io/tslint/" target="_blank" rel="noopener">TSLint</a></strong> 帮助我们格式化代码以及保证代码风格一致性。<br>使用 <strong><a href="http://typedoc.org/" target="_blank" rel="noopener">TypeDoc</a></strong> 帮助我们自动生成文档并部署到 GitHub pages。<br>使用 <strong><a href="http://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a></strong> 帮助我们做单元测试。<br>使用 <strong><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">Commitizen</a></strong> 帮助我们生成规范化的提交注释。<br>使用 <strong><a href="https://github.com/semantic-release/semantic-release" target="_blank" rel="noopener">Semantic release</a></strong> 帮助我们管理版本和发布。<br>使用 <strong><a href="https://github.com/typicode/husky" target="_blank" rel="noopener">husky</a></strong> 帮助我们更简单地使用 git hooks。<br>使用 <strong><a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener">Conventional changelog</a></strong> 帮助我们通过代码提交信息自动生成 change log。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://juejin.im/post/5cce87b851882541b07a9bfe" target="_blank" rel="noopener">从今天开始，拿起 TypeScript 做一个轮子的制造者</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript介绍</title>
    <url>/2020-03-18/TypeScript/TypeScript%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="Typescript-介绍"><a href="#Typescript-介绍" class="headerlink" title="Typescript  介绍"></a>Typescript  介绍</h2><ul>
<li>TypeScript 是由微软开发的一款开源的编程语言。</li>
<li>TypeScript 是 Javascript 的超集，遵循最新的 ES6、Es5 规范。TypeScript 扩展了 JavaScript的语法。</li>
</ul><h2 id="Typescript-安装-编译"><a href="#Typescript-安装-编译" class="headerlink" title="Typescript 安装 编译"></a>Typescript 安装 编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br><span class="line">tsc helloworld.ts</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="VSCode-配置"><a href="#VSCode-配置" class="headerlink" title="VSCode 配置"></a>VSCode 配置</h2><h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><p>打开VSCode之后在编辑器左侧找到这个拓展按钮，点击，然后在搜索框内搜索关键字”Chinese”。直接点击install安装，安装完成后重启VSCode即可。</p>
<h3 id="编辑器配置"><a href="#编辑器配置" class="headerlink" title="编辑器配置"></a>编辑器配置</h3><h3 id="TypeScript相关插件"><a href="#TypeScript相关插件" class="headerlink" title="TypeScript相关插件"></a>TypeScript相关插件</h3><p><a href="https://marketplace.visualstudio.com/items?itemName=eg2.tslint" target="_blank" rel="noopener">TSLint(deprecated)</a>，通过tslint.json配置，对你的写TypeScript代码风格进行检查和提示的插件。</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=prograhammer.tslint-vue" target="_blank" rel="noopener">TSLint Vue</a>，如果你使用TypeScript开发Vue项目，而且要使用TSLint对代码质量进行把控，那你应该需要这个插件。</p>
<h3 id="框架相关"><a href="#框架相关" class="headerlink" title="框架相关"></a>框架相关</h3><p>如果你使用Vue进行项目开发，那Vue相关的插件也是需要的，比如<a href="https://marketplace.visualstudio.com/items?itemName=hollowtree.vue-snippets" target="_blank" rel="noopener">Vue 2 Snippets</a>。</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=octref.vetur" target="_blank" rel="noopener">Vetur</a>插件是Vue的开发辅助工具，安装它之后会得到代码高亮、输入辅助等功能。</p>
<h3 id="提升开发体验"><a href="#提升开发体验" class="headerlink" title="提升开发体验"></a>提升开发体验</h3><p><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag" target="_blank" rel="noopener">Auto Close Tag</a>插件会自动帮你补充HTML闭合标签，比如你输完<button>的后面的尖括号后，插件会自动帮你补充</button>；</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag" target="_blank" rel="noopener">Auto Rename Tag</a>插件会在你修改HTML标签名的时候，自动帮你把它对应的闭标签同时修改掉；</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer" target="_blank" rel="noopener">Bracket Pair Colorizer</a>插件会将你的括号一对一对地用颜色进行区分，这样你就不会被多层嵌套的括号搞晕了，来看看它的样子；</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=spywhere.guides" target="_blank" rel="noopener">Guides</a>插件能够帮你在代码缩进的地方用竖线展示出索引对应的位置，而且点击代码，它还会将统一代码块范围的代码用统一颜色竖线标出；</p>
<h2 id="基于-VSCode-搭建-Typescript-开发环境"><a href="#基于-VSCode-搭建-Typescript-开发环境" class="headerlink" title="基于 VSCode  搭建 Typescript 开发环境"></a>基于 VSCode  搭建 Typescript 开发环境</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>新建一个文件夹“test”，作为项目根目录，进入这个文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">cd test</span><br></pre></td></tr></table></figure>

<h3 id="安装TypeScript"><a href="#安装TypeScript" class="headerlink" title="安装TypeScript"></a>安装TypeScript</h3><p>全局安装typescript：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install typescript -g</span><br></pre></td></tr></table></figure>

<p>进入项目根目录，生成typescript配置文件；在项目根目录多了一个 tsconfig.json 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure>

<p>因为我们要搭配使用webpack进行编译和本地开发，所以要在项目里安装一下typescript：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install typescript</span><br></pre></td></tr></table></figure>

<h3 id="配置TSLint"><a href="#配置TSLint" class="headerlink" title="配置TSLint"></a>配置TSLint</h3><p>全局安装TSLint：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install tslint  -g</span><br></pre></td></tr></table></figure>

<p>进入项目根目录，生成 tslint 配置文件；在项目根目录多了一个 tslint.json 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tslint -i</span><br></pre></td></tr></table></figure>

<p>tslint.json 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;defaultSeverity&quot;: &quot;error&quot;,</span><br><span class="line">  &quot;extends&quot;: [</span><br><span class="line">    &quot;tslint:recommended&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;jsRules&quot;: &#123;&#125;,</span><br><span class="line">  &quot;rules&quot;: &#123;&#125;,</span><br><span class="line">  &quot;rulesDirectory&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>defaultSeverity：是提醒级别，如果为error则会报错，如果为warning则会警告，如果设为off则关闭，那TSLint就关闭了；</li>
<li>extends：可指定继承指定的预设配置规则；</li>
<li>jsRules“用来配置对.js和.jsx文件的校验，配置规则的方法和下面的rules一样；</li>
<li>rules”是重点了，我们要让TSLint根据怎样的规则来检查代码，都是在这个里面配置，比如当我们不允许代码中使用eval方法时，就要在这里配置”no-eval”: true；</li>
<li>rulesDirectory：可以指定规则配置文件，这里指定相对路径。</li>
</ul>
<p>你可以参照<a href="https://palantir.github.io/tslint/usage/configuration/" target="_blank" rel="noopener">TSLint配置说明</a>了解他们的用途。如果你想要查看某条规则的配置及详情，可以参照<a href="https://palantir.github.io/tslint/rules/" target="_blank" rel="noopener">TSLint规则说明</a>。</p>
<h3 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h3><p>安装 webpack、webpack-cli 和 webpack-dev-server，：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli webpack-dev-server -D</span><br></pre></td></tr></table></figure>

<p>安装cross-env，并且后面跟着一个参数 NODE_ENV=development，这个用来在 webpack.config.js 里通过 process.env.NODE_ENV 来获取当前是开发还是生产环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install cross-env</span><br></pre></td></tr></table></figure>

<p>webpack.config.js配置文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">"clean-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 指定入口文件</span></span><br><span class="line">  <span class="comment">// 这里我们在src文件夹下创建一个index.ts</span></span><br><span class="line">  entry: <span class="string">"./src/index.ts"</span>,</span><br><span class="line">  <span class="comment">// 指定输出文件名</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"main.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 自动解析一下拓展，当我们要引入src/index.ts的时候，只需要写src/index即可</span></span><br><span class="line">    <span class="comment">// 后面我们讲TS模块解析的时候，写src也可以</span></span><br><span class="line">    extensions: [<span class="string">".tsx"</span>, <span class="string">".ts"</span>, <span class="string">".js"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 配置以.ts/.tsx结尾的文件都用ts-loader解析</span></span><br><span class="line">    <span class="comment">// 这里我们用到ts-loader，所以要安装一下</span></span><br><span class="line">    <span class="comment">// npm install ts-loader -D</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">        use: <span class="string">"ts-loader"</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 指定编译后是否生成source-map，这里判断如果是生产打包环境则不生产source-map</span></span><br><span class="line">  devtool: process.env.NODE_ENV === <span class="string">"production"</span> ? <span class="literal">false</span> : <span class="string">"inline-source-map"</span>,</span><br><span class="line">  <span class="comment">// 这里使用webpack-dev-server，进行本地开发调试</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">"./dist"</span>,</span><br><span class="line">    stats: <span class="string">"errors-only"</span>,</span><br><span class="line">    compress: <span class="literal">false</span>,</span><br><span class="line">    host: <span class="string">"localhost"</span>,</span><br><span class="line">    port: <span class="number">8089</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里用到两个插件，所以首先我们要记着安装</span></span><br><span class="line">  <span class="comment">// npm install html-webpack-plugin clean-webpack-plugin -D</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 这里在编译之前先删除dist文件夹</span></span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns: [<span class="string">"./dist"</span>]</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 这里我们指定编译需要用模板，模板文件是./src/template/index.html，所以接下来我们要创建一个index.html文件</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">"./src/template/index.html"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构建指令</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"cross-env NODE_ENV=development webpack-dev-server --mode=development --config ./build/webpack.config.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack --mode=production --config ./build/webpack.config.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.html 模板</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>TS-Learning<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>index.ts 脚本</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h1 = <span class="built_in">document</span>.createElement(<span class="string">"h1"</span>);</span><br><span class="line">h1.innerHTML = <span class="string">"Hello, I am Lison"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(h1);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins权限管理</title>
    <url>/2019-11-07/jenkins/Jenkins%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h2><p>打开浏览器，输入本机的ip地址并登陆</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`http://192.168.155.128:18080/`</span><br></pre></td></tr></table></figure><p>输入账号，密码，登录。</p><h2 id="进入权限管理界面"><a href="#进入权限管理界面" class="headerlink" title="进入权限管理界面"></a>进入权限管理界面</h2><p>系统管理-》全局安全设置  进入全局安全设置界面</p><ul>
<li><strong>安全域</strong> ：配置哪些用户可以访问</li>
<li><strong>授权策略</strong> ：配置这些用户的权限，读写，操作，可以访问什么等</li>
</ul><p><img src="/images/%E5%85%A8%E5%B1%80%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE.png" alt="全局安全配置"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意需要新进行相关插件的安装，才能支持相关的安全域和授权策略。</span><br><span class="line">插件可以通过系统管理-》插件管理 界面进行安装。</span><br></pre></td></tr></table></figure><a id="more"></a>








<h2 id="基于-Role-Based-Strategy-角色的权限管理"><a href="#基于-Role-Based-Strategy-角色的权限管理" class="headerlink" title="基于  Role-Based Strategy  角色的权限管理"></a>基于  Role-Based Strategy  角色的权限管理</h2><ul>
<li>安装 Role-based Authorization Strategy 插件</li>
</ul>
<p>在全局安全设置界面，选择 <strong>Role-Based Strategy</strong>，然后保存。退出到系统管理界面，点击 <strong>Manage and Assign Roles</strong> ，进入角色管理界面。就可以基于角色进行权限管理。</p>
<p><img src="/images/Role-Based-Strategy.png" alt="Role-Based-Strategy"></p>
<h3 id="管理角色"><a href="#管理角色" class="headerlink" title="管理角色"></a>管理角色</h3><ul>
<li><strong>Global roles</strong> ： <strong>全局角色</strong>（全局角色可以对jenkins系统进行设置与项目的操作） </li>
<li><strong>Project roles</strong> ： <strong>项目角色</strong>（项目角色只能对项目进行操作) <ul>
<li>“dev-.*”：只能操作dev开头的项目</li>
<li>“test-.*”：只能操作test开头的项目</li>
</ul>
</li>
</ul>
<p><img src="/images/%E7%AE%A1%E7%90%86%E8%A7%92%E8%89%B2.png" alt="管理角色"></p>
<p><img src="/images/%E9%A1%B9%E7%9B%AE.png" alt="项目"></p>
<h3 id="分配角色"><a href="#分配角色" class="headerlink" title="分配角色"></a>分配角色</h3><p>创建了两个用户，<strong>developer1</strong>，<strong>tester1</strong>。并赋予相应的权限。</p>
<p><img src="/images/%E5%88%86%E9%85%8D%E8%A7%92%E8%89%B2.png" alt="分配角色"></p>
<h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><p> 我们需要 <strong>全局安全配置</strong> 中设置为允许用户注册。 </p>
<p><img src="/images/%E6%96%B0%E5%BB%BA%E7%94%A8%E6%88%B7.png" alt="新建用户"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Docker 安装 Jenkins</title>
    <url>/2019-11-07/docker/%E5%9F%BA%E4%BA%8EDocker-%E5%AE%89%E8%A3%85-Jenkins/</url>
    <content><![CDATA[<h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name jenkins_test -itd -p 18080:8080 -p 50000:50000 jenkins/jenkins:lts</span><br></pre></td></tr></table></figure><ul>
<li>name：容器名称</li>
<li>itd：增加交互式终端</li>
</ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul>
<li><p>端口冲突：修改端口，再执行安装命令</p>
</li>
<li><p>容器名称冲突，容器已经存在：停止容器，删除容器再安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止容器</span></span><br><span class="line">docker stop container</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器</span></span><br><span class="line">docker rm container</span><br></pre></td></tr></table></figure>

</li>
</ul><a id="more"></a>



<h2 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps | grep jenkins_test</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81.png" alt="查看运行状态"></p>
<h2 id="打印容器信息"><a href="#打印容器信息" class="headerlink" title="打印容器信息"></a>打印容器信息</h2><p>红色框指向管理员密码，用于登录jenkins时使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f jenkins_test</span><br></pre></td></tr></table></figure>

<p>![打印容器信息]/images/打印容器信息.png)</p>
<h2 id="防火墙开启端口"><a href="#防火墙开启端口" class="headerlink" title="防火墙开启端口"></a>防火墙开启端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=18080/tcp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h2 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h2><p>打开浏览器，输入本机的ip地址并登陆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`http://192.168.155.128:18080/`</span><br></pre></td></tr></table></figure>

<p>密码对应于上面红框的数据。输入密码，登录。安装推荐的插件。安装完插件，创建管理员即可。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Compose</title>
    <url>/2019-11-06/docker/Docker-Compose/</url>
    <content><![CDATA[<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><a id="more"></a>

<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<h2 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h2><p>在 Linux 64 位系统上直接下载对应的二进制包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加速地址 curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 授权</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span></span><br></pre></td></tr></table></figure>

<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>删除二进制文件即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rm /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>

<h2 id="Compose-模板文件"><a href="#Compose-模板文件" class="headerlink" title="Compose 模板文件"></a>Compose 模板文件</h2><p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">"5000:5000"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure>

<h3 id="Compose-模板文件-1"><a href="#Compose-模板文件-1" class="headerlink" title="Compose 模板文件"></a><a href="https://yeasy.gitbooks.io/docker_practice/content/compose/compose_file.html" target="_blank" rel="noopener">Compose 模板文件</a></h3><h2 id="运行-compose-项目"><a href="#运行-compose-项目" class="headerlink" title="运行 compose 项目"></a>运行 compose 项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/compose/introduction.html" target="_blank" rel="noopener">Docker Compose</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 安装 Docker CE</title>
    <url>/2019-11-06/Linux/CentOS-%E5%AE%89%E8%A3%85-Docker-CE/</url>
    <content><![CDATA[<h2 id="CentOS-安装-Docker-CE"><a href="#CentOS-安装-Docker-CE" class="headerlink" title="CentOS 安装 Docker CE"></a>CentOS 安装 Docker CE</h2><blockquote>
<p>警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker.</p>
</blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。</p><a id="more"></a>

<h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<h2 id="使用-yum-安装"><a href="#使用-yum-安装" class="headerlink" title="使用 yum 安装"></a>使用 yum 安装</h2><p>执行以下命令安装依赖包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ sudo yum-config-manager \</span></span><br><span class="line"><span class="comment">#     --add-repo \</span></span><br><span class="line"><span class="comment">#     https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure>

<h3 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h3><p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure>

<h2 id="启动-Docker-CE"><a href="#启动-Docker-CE" class="headerlink" title="启动 Docker CE"></a>启动 Docker CE</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<h2 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h2><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p>
<p>建立 <code>docker</code> 组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure>

<p>将当前用户加入 <code>docker</code> 组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<p>退出当前终端并重新登录，进行如下测试。</p>
<h2 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image <span class="string">'hello-world:latest'</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">d1725b59e92d: Pull complete</span><br><span class="line">Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>

<p>若能正常输出以上信息，则说明安装成功。</p>
<h2 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h2><p>请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p>
<ul>
<li>vi  <code>/etc/docker/daemon.json</code></li>
<li>点击键盘 i 键，进入insert状态</li>
<li>写入如下内容</li>
<li>点击 esc 按键，输入 :wq 保存</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重新启动服务"><a href="#重新启动服务" class="headerlink" title="重新启动服务"></a>重新启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h3><p>执行 <code>$ docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://dockerhub.azk8s.cn/</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/install/centos.html" target="_blank" rel="noopener">CentOS 安装 Docker CE</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Docker搭建GitLab</title>
    <url>/2019-11-05/docker/%E5%9F%BA%E4%BA%8EDocker%E6%90%AD%E5%BB%BAGitLab/</url>
    <content><![CDATA[<h2 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h2><p>Docker 容器数据应该存储于卷中，在这里我们使用最简单的本地命名卷：</p><ul>
<li><code>gitlab-config</code> 存储 GitLab 配置信息</li>
<li><code>gitlab-data</code> 存储数据库</li>
<li><code>gitlab-logs</code> 存储日志</li>
</ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">  --hostname gitlab.example.com \</span><br><span class="line">  --publish 13443:443 --publish 13880:80 --publish 13822:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  --volume /srv/gitlab/config:/etc/gitlab \</span><br><span class="line">  --volume /srv/gitlab/logs:/var/log/gitlab \</span><br><span class="line">  --volume /srv/gitlab/data:/var/opt/gitlab \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><a id="more"></a>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">--hostname  <span class="comment">//虚拟机地址或云服务器地址</span></span><br><span class="line">--publish <span class="comment">// 设置端口 13443:443 13443代表宿主机上的端口 修改端口防止443，80，22端口占用</span></span><br></pre></td></tr></table></figure>

<p>下载并启动一个GitLab CE容器，并发布访问SSH，HTTP和HTTPS所需的端口。 配置 (etc) 、 日志 (log) 、数据 (data) 三个文件夹，放到容器之外， 便于日后升级，放在 <strong>/srv/gitlab/</strong> 目录。 系统重启后，容器将自动“重启”。</p>
<h3 id="查找GitLab镜像"><a href="#查找GitLab镜像" class="headerlink" title="查找GitLab镜像"></a>查找GitLab镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search gitlab</span><br></pre></td></tr></table></figure>

<h2 id="安装中文镜像"><a href="#安装中文镜像" class="headerlink" title="安装中文镜像"></a>安装中文镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --hostname gitlab.example.com \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    -p 443:443 \</span><br><span class="line">    -p 22:22 \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --restart unless-stopped \</span><br><span class="line">    -v gitlab-config:/etc/gitlab \</span><br><span class="line">    -v gitlab-logs:/var/log/gitlab \</span><br><span class="line">    -v gitlab-data:/var/opt/gitlab \</span><br><span class="line">    --network gitlab-net \</span><br><span class="line">    twang2218/gitlab-ce-zh:11.1.4</span><br></pre></td></tr></table></figure>

<p>如果需要进入容器修改配置文件，可以用 <code>docker exec</code> 命令进入容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it gitlab bash</span></span><br><span class="line">root@09f6e32c528c:/# vi /etc/gitlab/gitlab.rb</span><br><span class="line">root@09f6e32c528c:/# gitlab-ctl reconfigure</span><br><span class="line">Starting Chef Client, version 12.12.15</span><br><span class="line">resolving cookbooks for run list: ["gitlab"]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如需停止服务，直接运行 <code>docker stop gitlab</code>。</p>
<p>如需卸载服务及相关内容，可以执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop gitlab</span><br><span class="line">docker rm gitlab</span><br><span class="line">docker network rm gitlab-net</span><br><span class="line">docker volume rm gitlab-config gitlab-datagitlab-logs</span><br></pre></td></tr></table></figure>

<h2 id="防火墙开启端口"><a href="#防火墙开启端口" class="headerlink" title="防火墙开启端口"></a>防火墙开启端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=13880/tcp</span><br><span class="line">firewall-cmd --permanent --add-port=13822/tcp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h2 id="Docker-can’t-connect-to-docker-daemon"><a href="#Docker-can’t-connect-to-docker-daemon" class="headerlink" title="Docker can’t connect to docker daemon"></a>Docker can’t connect to docker daemon</h2><ol>
<li><p>创建 docker 组.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>将用户添加到 docker 组.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $(whoami)</span><br></pre></td></tr></table></figure>
</li>
<li><p>注销并重新登录以确保docker以正确的权限运行.</p>
</li>
<li><p>启动docker.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="数据存储在哪里"><a href="#数据存储在哪里" class="headerlink" title="数据存储在哪里?"></a>数据存储在哪里?</h2><table>
<thead>
<tr>
<th align="left">Local location</th>
<th align="left">Container location</th>
<th align="left">Usage</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>/srv/gitlab/data</code></td>
<td align="left"><code>/var/opt/gitlab</code></td>
<td align="left">用于存储应用程序数据</td>
</tr>
<tr>
<td align="left"><code>/srv/gitlab/logs</code></td>
<td align="left"><code>/var/log/gitlab</code></td>
<td align="left">用于存储日志</td>
</tr>
<tr>
<td align="left"><code>/srv/gitlab/config</code></td>
<td align="left"><code>/etc/gitlab</code></td>
<td align="left">用于存储GitLab配置文件</td>
</tr>
</tbody></table>
<p>您可以微调这些目录以满足您的要求</p>
<h2 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h2><p>打开浏览器，输入本机的ip地址并登陆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`http://192.168.138.128:13880/`</span><br></pre></td></tr></table></figure>

<p>默认帐户的用户名是root，第一次访问时，将被重定向到密码重置屏幕,登录后，您可以更改用户名。</p>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="停止镜像"><a href="#停止镜像" class="headerlink" title="停止镜像"></a>停止镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop container</span><br></pre></td></tr></table></figure>

<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>需要停止了，才能删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm container</span><br></pre></td></tr></table></figure>

<h3 id="重新启动镜像"><a href="#重新启动镜像" class="headerlink" title="重新启动镜像"></a>重新启动镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart container</span><br></pre></td></tr></table></figure>

<h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start container</span><br></pre></td></tr></table></figure>

<h3 id="获取容器的日志"><a href="#获取容器的日志" class="headerlink" title="获取容器的日志"></a>获取容器的日志</h3><p>docker logs : 获取容器的日志，可以根据日志信息，找到错误信息，解决相关问题</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>

<p>OPTIONS说明：</p>
<ul>
<li>-f : 跟踪日志输出</li>
<li>–since :显示某个开始时间的所有日志</li>
<li>-t : 显示时间戳</li>
<li>–tail :仅列出最新N条容器日志</li>
</ul>
<h3 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h3><p><strong>docker ps :</strong> 列出容器</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>

<p>OPTIONS说明：</p>
<ul>
<li><strong>-a :</strong>显示所有的容器，包括未运行的。</li>
<li><strong>-f :</strong>根据条件过滤显示的内容。</li>
<li><strong>–format :</strong>指定返回值的模板文件。</li>
<li><strong>-l :</strong>显示最近创建的容器。</li>
<li><strong>-n :</strong>列出最近创建的n个容器。</li>
<li><strong>–no-trunc :</strong>不截断输出。</li>
<li><strong>-q :</strong>静默模式，只显示容器编号。</li>
<li><strong>-s :</strong>显示总的文件大小。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://hub.docker.com/r/twang2218/gitlab-ce-zh" target="_blank" rel="noopener">GitLab 中文社区版</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2019-11-03/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p><img src="/images/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="Linux目录结构"></p><h2 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title="Linux文件属性"></a>Linux文件属性</h2><p><img src="/images/Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.png" alt="Linux文件属性"></p><ul>
<li>第0位确定文件类型<ul>
<li>当为[ <strong>d</strong> ]则是目录</li>
<li>当为[ <strong>-</strong> ]则是文件；</li>
<li>若是[ <strong>l</strong> ]则表示为链接文档(link file)；</li>
<li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li>
<li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
</li>
<li>第1-3位确定属主（该文件的所有者，创建该文件的用户）拥有该文件的权限。</li>
<li>第4-6位确定属组（所有者的同组用户，创建该文件的用户所在的用户组）拥有该文件的权限。</li>
<li>第7-9位确定其他用户（与创建该文件的用户所处用户组不同的用户）拥有该文件的权限。</li>
<li>其中，第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</li>
<li>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</li>
<li>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</li>
</ul><a id="more"></a>


<h3 id="Linux文件属主和属组"><a href="#Linux文件属主和属组" class="headerlink" title="Linux文件属主和属组"></a>Linux文件属主和属组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www /]# ls -l</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x 2 root  root  4096 Feb 15 14:46 cron</span><br><span class="line">drwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</p>
<p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p>
<h3 id="Linux-文件基本属性"><a href="#Linux-文件基本属性" class="headerlink" title="Linux 文件基本属性"></a><a href="https://www.runoob.com/linux/linux-file-attr-permission.html" target="_blank" rel="noopener">Linux 文件基本属性</a></h3><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><ul>
<li>CentOS7默认安装了firewalld防火墙</li>
<li>利用防火墙，我们可以允许或限制数据的传输</li>
</ul>
<h3 id="管理防火墙"><a href="#管理防火墙" class="headerlink" title="管理防火墙"></a>管理防火墙</h3><ul>
<li><p>查看，启动，关闭，重启防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 查看</span><br><span class="line">firewall-cmd --state</span><br><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">service firewall start</span><br><span class="line"><span class="meta">#</span> 关闭</span><br><span class="line">service firewall stop</span><br><span class="line"><span class="meta">#</span> 重启</span><br><span class="line">service firewall restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>端口管理 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 打开443/TCP端口</span><br><span class="line">firewall-cmd --add-port=443/tcp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 永久打开3690/TCP端口</span><br><span class="line">firewall-cmd --permanent --add-port=3690/tcp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 永久打开端口好像需要reload一下，临时打开好像不用，如果用了reload临时打开的端口就失效了</span><br><span class="line"><span class="meta">#</span> 其它服务也可能是这样的，这个没有测试</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看防火墙，添加的端口也可以看到</span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看所有打开的端口：</span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 阻止通过tcp访问443 删除端口</span><br><span class="line">firewall-cmd --remove-port=443/tcp</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="文档型"><a href="#文档型" class="headerlink" title="文档型"></a>文档型</h2><p>文件相关命令（touch，cat，echo，rm，vi，cd）</p>
<h2 id="硬件型"><a href="#硬件型" class="headerlink" title="硬件型"></a>硬件型</h2><p>磁盘/进程/服务/网络</p>
<h2 id="功能型"><a href="#功能型" class="headerlink" title="功能型"></a>功能型</h2><p>压缩/解压，下载，远程</p>
<h2 id="发行版本信息-lsb-release"><a href="#发行版本信息-lsb-release" class="headerlink" title="发行版本信息 lsb_release"></a>发行版本信息 lsb_release</h2><p>显示发行版本信息</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>LSB是Linux Standard Base的缩写， <strong>lsb_release命令</strong> 用来显示LSB和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v参数。</p>
<ul>
<li>-v 显示版本信息。</li>
<li>-i 显示发行版的id。</li>
<li>-d 显示该发行版的描述信息。</li>
<li>-r 显示当前系统是发行版的具体版本号。</li>
<li>-c 发行版代号。</li>
<li>-a 显示上面的所有信息。</li>
<li>-h 显示帮助信息。</li>
</ul>
<h2 id="显示系统信息-uname"><a href="#显示系统信息-uname" class="headerlink" title="显示系统信息 uname"></a>显示系统信息 uname</h2><p>Linux uname命令用于显示系统信息。</p>
<p>uname可显示电脑以及操作系统的相关信息。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname [-amnrsv][--help][--version]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-a或–all 　显示全部的信息。</li>
<li>-m或–machine 　显示电脑类型。</li>
<li>-n或-nodename 　显示在网络上的主机名称。</li>
<li>-r或–release 　显示操作系统的发行编号。</li>
<li>-s或–sysname 　显示操作系统名称。</li>
<li>-v 　显示操作系统的版本。</li>
<li>–help 　显示帮助。</li>
<li>–version 　显示版本信息。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>显示系统信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> uname -a</span><br><span class="line">Linux snail-hnlinux 2.6.32-21-generic #32-Ubuntu SMP Fri Apr 16 08:10:02 UTC 2010 i686 GNU/Linux</span><br></pre></td></tr></table></figure>

<p>显示计算机类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> uname -m</span><br><span class="line">i686</span><br></pre></td></tr></table></figure>

<p>显示计算机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> uname -n</span><br><span class="line">snail-hnlinux</span><br></pre></td></tr></table></figure>

<p>显示操作系统发行编号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> uname -r</span><br><span class="line">2.6.32-21-generic</span><br></pre></td></tr></table></figure>

<p>显示操作系统名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> uname -s</span><br><span class="line">Linux</span><br></pre></td></tr></table></figure>

<p>显示系统时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> uname -v</span><br><span class="line"><span class="meta">#</span>32-Ubuntu SMP Fri Apr 16 08:10:02 UTC 2014</span><br></pre></td></tr></table></figure>

<h2 id="磁盘使用情况-df"><a href="#磁盘使用情况-df" class="headerlink" title="磁盘使用情况 df"></a>磁盘使用情况 df</h2><p>Linux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df [选项]... [FILE]...</span><br></pre></td></tr></table></figure>

<ul>
<li>文件-a, –all 包含所有的具有 0 Blocks 的文件系统</li>
<li>文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks</li>
<li>文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)</li>
<li>文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024</li>
<li>文件-i, –inodes 列出 inode 资讯，不列出已使用 block</li>
<li>文件-k, –kilobytes 就像是 –block-size=1024</li>
<li>文件-l, –local 限制列出的文件结构</li>
<li>文件-m, –megabytes 就像 –block-size=1048576</li>
<li>文件–no-sync 取得资讯前不 sync (预设值)</li>
<li>文件-P, –portability 使用 POSIX 输出格式</li>
<li>文件–sync 在取得资讯前 sync</li>
<li>文件-t, –type=TYPE 限制列出文件系统的 TYPE</li>
<li>文件-T, –print-type 显示文件系统的形式</li>
<li>文件-x, –exclude-type=TYPE 限制列出文件系统不要显示 TYPE</li>
<li>文件-v (忽略)</li>
<li>文件–help 显示这个帮手并且离开</li>
<li>文件–version 输出版本资讯并且离开</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>显示文件系统的磁盘使用情况统计：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df </span><br><span class="line">Filesystem     1K-blocks    Used     Available Use% Mounted on </span><br><span class="line">/dev/sda6       29640780 4320704     23814388  16%     / </span><br><span class="line">udev             1536756       4     1536752    1%     /dev </span><br><span class="line">tmpfs             617620     888     616732     1%     /run </span><br><span class="line">none                5120       0     5120       0%     /run/lock </span><br><span class="line">none             1544044     156     1543888    1%     /run/shm</span><br></pre></td></tr></table></figure>

<p>第一列指定文件系统的名称，第二列指定一个特定的文件系统1K-块1K是1024字节为单位的总内存。用和可用列正在使用中，分别指定的内存量。</p>
<p>使用列指定使用的内存的百分比，而最后一栏”安装在”指定的文件系统的挂载点。</p>
<p>df也可以显示磁盘使用的文件系统信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df test </span><br><span class="line">Filesystem     1K-blocks    Used      Available Use% Mounted on </span><br><span class="line">/dev/sda6       29640780    4320600   23814492  16%       /</span><br></pre></td></tr></table></figure>

<p>用一个-i选项的df命令的输出显示inode信息而非块使用量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -i </span><br><span class="line">Filesystem      Inodes    IUsed    IFree     IUse% Mounted on </span><br><span class="line">/dev/sda6      1884160    261964   1622196   14%        / </span><br><span class="line">udev           212748     560      212188    1%         /dev </span><br><span class="line">tmpfs          216392     477      215915    1%         /run </span><br><span class="line">none           216392     3        216389    1%         /run/lock </span><br><span class="line">none           216392     8        216384    1%         /run/shm</span><br></pre></td></tr></table></figure>

<p>显示所有的信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df --total </span><br><span class="line">Filesystem     1K-blocks    Used    Available Use% Mounted on </span><br><span class="line">/dev/sda6       29640780 4320720    23814372  16%     / </span><br><span class="line">udev             1536756       4    1536752   1%      /dev </span><br><span class="line">tmpfs             617620     892    616728    1%      /run </span><br><span class="line">none                5120       0    5120      0%      /run/lock </span><br><span class="line">none             1544044     156    1543888   1%      /run/shm </span><br><span class="line">total           33344320 4321772    27516860  14%</span><br></pre></td></tr></table></figure>

<p>我们看到输出的末尾，包含一个额外的行，显示总的每一列。</p>
<p>-h选项，通过它可以产生可读的格式df命令的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df -h </span><br><span class="line">Filesystem      Size  Used   Avail Use% Mounted on </span><br><span class="line">/dev/sda6       29G   4.2G   23G   16%     / </span><br><span class="line">udev            1.5G  4.0K   1.5G   1%     /dev </span><br><span class="line">tmpfs           604M  892K   603M   1%     /run </span><br><span class="line">none            5.0M     0   5.0M   0%     /run/lock </span><br><span class="line">none            1.5G  156K   1.5G   1%     /run/shm</span><br></pre></td></tr></table></figure>

<p>我们可以看到输出显示的数字形式的’G’（千兆字节），”M”（兆字节）和”K”（千字节）。</p>
<p>这使输出容易阅读和理解，从而使显示可读的。请注意，第二列的名称也发生了变化，为了使显示可读的”大小”。</p>
<h2 id="显示-process信息-top"><a href="#显示-process信息-top" class="headerlink" title="显示 process信息 top"></a>显示 process信息 top</h2><p>Linux top命令用于实时显示 process 的动态。</p>
<p>使用权限：所有使用者。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s</li>
<li>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行</li>
<li>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来</li>
<li>s : 安全模式，将交谈式指令取消, 避免潜在的危机</li>
<li>i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程</li>
<li>n : 更新的次数，完成后将会退出 top</li>
<li>b : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>显示进程信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> top</span><br></pre></td></tr></table></figure>

<p>显示完整命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> top -c</span><br></pre></td></tr></table></figure>

<p>以批处理模式显示程序信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> top -b</span><br></pre></td></tr></table></figure>

<p>以累积模式显示程序信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> top -S</span><br></pre></td></tr></table></figure>

<p>设置信息更新次数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -n 2</span><br><span class="line"></span><br><span class="line">//表示更新两次后终止更新显示</span><br></pre></td></tr></table></figure>

<p>设置信息更新时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> top -d 3</span><br><span class="line"></span><br><span class="line">//表示更新周期为3秒</span><br></pre></td></tr></table></figure>

<p>显示指定的进程信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> top -p 139</span><br><span class="line"></span><br><span class="line">//显示进程号为139的进程信息，CPU、内存占用率等</span><br></pre></td></tr></table></figure>

<p>显示更新十次后退出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -n 10</span><br></pre></td></tr></table></figure>

<p>使用者将不能利用交谈式指令来对行程下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -s</span><br></pre></td></tr></table></figure>

<p>将更新显示二次的结果输入到名称为 top.log 的档案里</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -n 2 -b &lt; top.log</span><br></pre></td></tr></table></figure>

<h2 id="切换工作目录-cd"><a href="#切换工作目录-cd" class="headerlink" title="切换工作目录 cd"></a>切换工作目录 cd</h2><p>Linux cd命令用于切换当前工作目录至 dirName(目录参数)。</p>
<p>其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。</p>
<p>另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd [dirName]</span><br></pre></td></tr></table></figure>

<ul>
<li>dirName：要切换的目标目录。</li>
</ul>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>跳到 /usr/bin/ :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/bin</span><br></pre></td></tr></table></figure>

<p>跳到自己的 home 目录 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure>

<p>跳到目前目录的上上两层 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ../..</span><br></pre></td></tr></table></figure>

<h2 id="创建新目录-mkdir"><a href="#创建新目录-mkdir" class="headerlink" title="创建新目录 mkdir"></a>创建新目录 mkdir</h2><p>Linux mkdir命令用于建立名称为 dirName 之子目录。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir [-p] dirName</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-p 确保目录名称存在，不存在的就建一个。</li>
</ul>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>在工作目录下，建立一个名为 AAA 的子目录 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir AAA</span><br></pre></td></tr></table></figure>

<p>在工作目录下的 BBB 目录中，建立一个名为 Test 的子目录。 若 BBB 目录原本不存在，则建立一个。（注：本例若不加 -p，且原本 BBB目录不存在，则产生错误。）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p BBB/Test</span><br></pre></td></tr></table></figure>

<h2 id="创建文件-touch"><a href="#创建文件-touch" class="headerlink" title="创建文件 touch"></a>创建文件 touch</h2><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>
<p>ls -l 可以显示档案的时间记录。</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数说明</strong>：</li>
<li>a 改变档案的读取时间记录。</li>
<li>m 改变档案的修改时间记录。</li>
<li>c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。</li>
<li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li>
<li>r 使用参考档的时间记录，与 –file 的效果一样。</li>
<li>d 设定时间与日期，可以使用各种不同的格式。</li>
<li>t 设定档案的时间记录，格式与 date 指令相同。</li>
<li>–no-create 不会建立新档案。</li>
<li>–help 列出指令格式。</li>
<li>–version 列出版本讯息。</li>
</ul>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>使用指令”touch”修改文件”testfile”的时间属性为当前系统时间，输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> touch testfile                #修改文件的时间属性</span><br></pre></td></tr></table></figure>

<p>首先，使用ls命令查看testfile文件的属性，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ls -l testfile                #查看文件的时间属性  </span><br><span class="line"><span class="meta">#</span>原来文件的修改时间为16:09  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile</span><br></pre></td></tr></table></figure>

<p>执行指令”touch”修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> touch testfile                #修改文件时间属性为当前系统时间  </span><br><span class="line"><span class="meta">$</span> ls -l testfile                #查看文件的时间属性  </span><br><span class="line"><span class="meta">#</span>修改后文件的时间属性为当前系统时间  </span><br><span class="line">-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile</span><br></pre></td></tr></table></figure>

<p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> touch file            #创建一个名为“file”的新的空白文件</span><br></pre></td></tr></table></figure>

<h2 id="复制文件或目录-cp"><a href="#复制文件或目录-cp" class="headerlink" title="复制文件或目录 cp"></a>复制文件或目录 cp</h2><p>Linux cp命令主要用于复制文件或目录。</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp [options] source dest</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp [options] source... directory</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li>
<li>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</li>
<li>-f：覆盖已经存在的目标文件而不给出提示。</li>
<li>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。</li>
<li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li>
<li>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li>
<li>-l：不复制文件，只是生成链接文件。</li>
</ul>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>使用指令”cp”将当前目录”test/”下的所有文件复制到新目录”newtest”下，输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> cp –r test/ newtest</span><br></pre></td></tr></table></figure>

<p>注意：用户使用该指令复制目录时，必须使用参数”-r”或者”-R”。</p>
<h2 id="移动目录或文件夹-mv"><a href="#移动目录或文件夹-mv" class="headerlink" title="移动目录或文件夹 mv"></a>移动目录或文件夹 mv</h2><p>Linux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。</p>
<h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv [options] source dest</span><br><span class="line">mv [options] source... directory</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;</li>
<li>-f: 在mv操作要覆盖某已有的目标文件时不给任何指示;</li>
</ul>
<p>mv参数设置与运行结果</p>
<table>
<thead>
<tr>
<th align="left">命令格式</th>
<th align="left">运行结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mv 文件名 文件名</td>
<td align="left">将源文件名改为目标文件名</td>
</tr>
<tr>
<td align="left">mv 文件名 目录名</td>
<td align="left">将文件移动到目标目录</td>
</tr>
<tr>
<td align="left">mv 目录名 目录名</td>
<td align="left">目标目录已存在，将源目录 移动到目标目录；目标 目录不存在则改名</td>
</tr>
<tr>
<td align="left">mv 目录名 文件名</td>
<td align="left">出错</td>
</tr>
</tbody></table>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>将文件 aaa 更名为 bbb :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv aaa bbb</span><br></pre></td></tr></table></figure>

<p>将info目录放入logs目录中。注意，如果logs目录不存在，则该命令将info改名为logs。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv info/ logs</span><br></pre></td></tr></table></figure>

<p>再如将/usr/student下的所有文件和目录移到当前目录下，命令行为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> mv /usr/student/*  .</span><br></pre></td></tr></table></figure>

<h2 id="vi-vim-的使用"><a href="#vi-vim-的使用" class="headerlink" title="vi/vim 的使用"></a>vi/vim 的使用</h2><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>插入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p>
<h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><p>用户刚刚启动 vi/vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li><strong>i</strong> 切换到插入模式，以输入字符。</li>
<li><strong>x</strong> 删除当前光标所在处的字符。</li>
<li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li>
</ul>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>在命令模式下按下i就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li>字符按键以及Shift组合，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li>
<li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li>
<li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
<h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。</p>
<p><a href="https://ipcmen.com/vi-vim" target="_blank" rel="noopener">Linux vi/vim</a></p>
<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><h3 id="命令：cat"><a href="#命令：cat" class="headerlink" title="命令：cat"></a>命令：cat</h3><p>cat 命令用于连接文件并打印到标准输出设备上。</p>
<h3 id="使用权限"><a href="#使用权限" class="headerlink" title="使用权限"></a>使用权限</h3><p>所有使用者</p>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat [-AbeEnstTuv] [--help] [--version] fileName</span><br></pre></td></tr></table></figure>

<h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><p><strong>-n 或 –number</strong>：由 1 开始对所有输出的行数编号。</p>
<p><strong>-b 或 –number-nonblank</strong>：和 -n 相似，只不过对于空白行不编号。</p>
<p><strong>-s 或 –squeeze-blank</strong>：当遇到有连续两行以上的空白行，就代换为一行的空白行。</p>
<p><strong>-v 或 –show-nonprinting</strong>：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</p>
<p><strong>-E 或 –show-ends</strong> : 在每行结束处显示 $。</p>
<p><strong>-T 或 –show-tabs</strong>: 将 TAB 字符显示为 ^I。</p>
<p><strong>-e</strong> : 等价于 -vE。</p>
<p><strong>-A, –show-all</strong>：等价于 -vET。</p>
<p><strong>-e：</strong>等价于”-vE”选项；</p>
<p><strong>-t：</strong>等价于”-vT”选项；</p>
<h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure>

<p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure>

<p>清空 /etc/test.txt 文档内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /dev/null &gt; /etc/test.txt</span><br></pre></td></tr></table></figure>

<p>cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /dev/fd0 &gt; OUTFILE</span><br></pre></td></tr></table></figure>

<p>相反的，如果想把 image file 写到软盘，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat IMG_FILE &gt; /dev/fd0</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：</p>
<ul>
<li>\1. OUTFILE 指输出的镜像文件名。</li>
<li>\2. IMG_FILE 指镜像文件。</li>
<li>\3. 若从镜像文件写回 device 时，device 容量需与相当。</li>
<li>\4. 通常用制作开机磁片。</li>
</ul>
<h2 id="Shell-echo命令"><a href="#Shell-echo命令" class="headerlink" title="Shell echo命令"></a>Shell echo命令</h2><p>Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo string</span><br></pre></td></tr></table></figure>

<p>您可以使用echo实现更复杂的输出格式控制。</p>
<h3 id="1-显示普通字符串"><a href="#1-显示普通字符串" class="headerlink" title="1.显示普通字符串:"></a>1.显示普通字符串:</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "It is a test"</span><br></pre></td></tr></table></figure>

<p>这里的双引号完全可以省略，以下命令与上面实例效果一致：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo It is a test</span><br></pre></td></tr></table></figure>

<h3 id="2-显示转义字符"><a href="#2-显示转义字符" class="headerlink" title="2.显示转义字符"></a>2.显示转义字符</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "\"It is a test\""</span><br></pre></td></tr></table></figure>

<p>结果将是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;It is a test&quot;</span><br></pre></td></tr></table></figure>

<p>同样，双引号也可以省略</p>
<h3 id="3-显示变量"><a href="#3-显示变量" class="headerlink" title="3.显示变量"></a>3.显示变量</h3><p>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">read name </span><br><span class="line">echo "$name It is a test"</span><br></pre></td></tr></table></figure>

<p>以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# sh test.sh</span><br><span class="line">OK                     #标准输入</span><br><span class="line">OK It is a test        #输出</span><br></pre></td></tr></table></figure>

<h3 id="4-显示换行"><a href="#4-显示换行" class="headerlink" title="4.显示换行"></a>4.显示换行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e "OK! \n" # -e 开启转义</span><br><span class="line">echo "It it a test"</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OK!</span><br><span class="line"></span><br><span class="line">It it a test</span><br></pre></td></tr></table></figure>

<h3 id="5-显示不换行"><a href="#5-显示不换行" class="headerlink" title="5.显示不换行"></a>5.显示不换行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">echo -e "OK! \c" # -e 开启转义 \c 不换行</span><br><span class="line">echo "It is a test"</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OK! It is a test</span><br></pre></td></tr></table></figure>

<h3 id="6-显示结果定向至文件"><a href="#6-显示结果定向至文件" class="headerlink" title="6.显示结果定向至文件"></a>6.显示结果定向至文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "It is a test" &gt; myfile</span><br></pre></td></tr></table></figure>

<h3 id="7-原样输出字符串，不进行转义或取变量-用单引号"><a href="#7-原样输出字符串，不进行转义或取变量-用单引号" class="headerlink" title="7.原样输出字符串，不进行转义或取变量(用单引号)"></a>7.原样输出字符串，不进行转义或取变量(用单引号)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo '$name\"'</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$name\&quot;</span><br></pre></td></tr></table></figure>

<h3 id="8-显示命令执行结果"><a href="#8-显示命令执行结果" class="headerlink" title="8.显示命令执行结果"></a>8.显示命令执行结果</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo `date`</span><br></pre></td></tr></table></figure>

<p>结果将显示当前日期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thu Jul 24 10:08:46 CST 2014</span><br></pre></td></tr></table></figure>

<h2 id="删除文件或者目录-rm"><a href="#删除文件或者目录-rm" class="headerlink" title="删除文件或者目录 rm"></a>删除文件或者目录 rm</h2><p>Linux rm命令用于删除一个文件或者目录。</p>
<h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm [options] name...</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-i 删除前逐一询问确认。</li>
<li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</li>
<li>-r 将目录及以下之档案亦逐一删除。</li>
</ul>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r”，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> rm  test.txt </span><br><span class="line">rm：是否删除 一般文件 "test.txt"? y  </span><br><span class="line"><span class="meta">#</span> rm  homework  </span><br><span class="line">rm: 无法删除目录"homework": 是一个目录  </span><br><span class="line"><span class="meta">#</span> rm  -r  homework  </span><br><span class="line">rm：是否删除 目录 "homework"? y</span><br></pre></td></tr></table></figure>

<p>删除当前目录下的所有文件及目录，命令行为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm  -r  *</span><br></pre></td></tr></table></figure>

<p>文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。</p>
<h2 id="下载文件-wget"><a href="#下载文件-wget" class="headerlink" title="下载文件 wget"></a>下载文件 wget</h2><p>Linux系统下载文件工具</p>
<p><a href="https://ipcmen.com/wget" target="_blank" rel="noopener">wget</a></p>
<h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget [参数] [URL地址]</span><br></pre></td></tr></table></figure>

<h2 id="备份，解压，压缩文件-tar"><a href="#备份，解压，压缩文件-tar" class="headerlink" title="备份，解压，压缩文件 tar"></a>备份，解压，压缩文件 tar</h2><p>Linux tar命令用于备份文件。</p>
<p>tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p>
<h3 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b &lt;区块数目&gt;][-C &lt;目的目录&gt;][-f &lt;备份文件&gt;][-F &lt;Script文件&gt;][-K &lt;文件&gt;][-L &lt;媒体容量&gt;][-N &lt;日期时间&gt;][-T &lt;范本文件&gt;][-V &lt;卷册名称&gt;][-X &lt;范本文件&gt;][-&lt;设备编号&gt;&lt;存储密度&gt;][--after-date=&lt;日期时间&gt;][--atime-preserve][--backuup=&lt;备份方式&gt;][--checkpoint][--concatenate][--confirmation][--delete][--exclude=&lt;范本样式&gt;][--force-local][--group=&lt;群组名称&gt;][--help][--ignore-failed-read][--new-volume-script=&lt;Script文件&gt;][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner=&lt;用户名称&gt;][--posix][--erve][--preserve-order][--preserve-permissions][--record-size=&lt;区块数目&gt;][--recursive-unlink][--remove-files][--rsh-command=&lt;执行指令&gt;][--same-owner][--suffix=&lt;备份字尾字符串&gt;][--totals][--use-compress-program=&lt;执行指令&gt;][--version][--volno-file=&lt;编号文件&gt;][文件或目录...]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-A或–catenate 新增文件到已存在的备份文件。</li>
<li>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为12Bytes。</li>
<li>-B或–read-full-records 读取数据时重设区块大小。</li>
<li>-c或–create 建立新的备份文件。</li>
<li>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt; 切换到指定的目录。</li>
<li>-d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。</li>
<li>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt; 指定备份文件。</li>
<li>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt; 每次更换磁带时，就执行指定的Script文件。</li>
<li>-g或–listed-incremental 处理GNU格式的大量备份。</li>
<li>-G或–incremental 处理旧的GNU格式的大量备份。</li>
<li>-h或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。</li>
<li>-i或–ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。</li>
<li>-k或–keep-old-files 解开备份文件时，不覆盖已有的文件。</li>
<li>-K&lt;文件&gt;或–starting-file=&lt;文件&gt; 从指定的文件开始还原。</li>
<li>-l或–one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li>
<li>-L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt; 设置存放每体的容量，单位以1024 Bytes计算。</li>
<li>-m或–modification-time 还原文件时，不变更文件的更改时间。</li>
<li>-M或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li>
<li>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。</li>
<li>-o或–old-archive或–portability 将资料写入备份文件时使用V7格式。</li>
<li>-O或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li>
<li>-p或–same-permissions 用原来的文件权限还原文件。</li>
<li>-P或–absolute-names 文件名使用绝对名称，不移除文件名称前的”/”号。</li>
<li>-r或–append 新增文件到已存在的备份文件的结尾部分。</li>
<li>-R或–block-number 列出每个信息在备份文件中的区块编号。</li>
<li>-s或–same-order 还原文件的顺序和备份文件内的存放顺序相同。</li>
<li>-S或–sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li>
<li>-t或–list 列出备份文件的内容。</li>
<li>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li>
<li>-u或–update 仅置换较备份文件内的文件更新的文件。</li>
<li>-U或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。</li>
<li>-v或–verbose 显示指令执行过程。</li>
<li>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。</li>
<li>-w或–interactive 遭遇问题时先询问用户。</li>
<li>-W或–verify 写入备份文件后，确认文件正确无误。</li>
<li>-x或–extract或–get 从备份文件中还原文件。</li>
<li>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li>
<li>-z或–gzip或–ungzip 通过gzip指令处理备份文件。</li>
<li>-Z或–compress或–uncompress 通过compress指令处理备份文件。</li>
<li>-&lt;设备编号&gt;&lt;存储密度&gt; 设置备份用的外围设备编号及存放数据的密度。</li>
<li>–after-date=&lt;日期时间&gt; 此参数的效果和指定”-N”参数相同。</li>
<li>–atime-preserve 不变更文件的存取时间。</li>
<li>–backup=&lt;备份方式&gt;或–backup 移除文件前先进行备份。</li>
<li>–checkpoint 读取备份文件时列出目录名称。</li>
<li>–concatenate 此参数的效果和指定”-A”参数相同。</li>
<li>–confirmation 此参数的效果和指定”-w”参数相同。</li>
<li>–delete 从备份文件中删除指定的文件。</li>
<li>–exclude=&lt;范本样式&gt; 排除符合范本样式的问家。</li>
<li>–group=&lt;群组名称&gt; 把加入设备文件中的文件的所属群组设成指定的群组。</li>
<li>–help 在线帮助。</li>
<li>–ignore-failed-read 忽略数据读取错误，不中断程序的执行。</li>
<li>–new-volume-script=&lt;Script文件&gt; 此参数的效果和指定”-F”参数相同。</li>
<li>–newer-mtime 只保存更改过的文件。</li>
<li>–no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li>
<li>–null 从null设备读取文件名称。</li>
<li>–numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。</li>
<li>–owner=&lt;用户名称&gt; 把加入备份文件中的文件的拥有者设成指定的用户。</li>
<li>–posix 将数据写入备份文件时使用POSIX格式。</li>
<li>–preserve 此参数的效果和指定”-ps”参数相同。</li>
<li>–preserve-order 此参数的效果和指定”-A”参数相同。</li>
<li>–preserve-permissions 此参数的效果和指定”-p”参数相同。</li>
<li>–record-size=&lt;区块数目&gt; 此参数的效果和指定”-b”参数相同。</li>
<li>–recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li>
<li>–remove-files 文件加入备份文件后，就将其删除。</li>
<li>–rsh-command=&lt;执行指令&gt; 设置要在远端主机上执行的指令，以取代rsh指令。</li>
<li>–same-owner 尝试以相同的文件拥有者还原问家你。</li>
<li>–suffix=&lt;备份字尾字符串&gt; 移除文件前先行备份。</li>
<li>–totals 备份文件建立后，列出文件大小。</li>
<li>–use-compress-program=&lt;执行指令&gt; 通过指定的指令处理备份文件。</li>
<li>–version 显示版本信息。</li>
<li>–volno-file=&lt;编号文件&gt; 使用指定文件内的编号取代预设的卷册编号。</li>
</ul>
<h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><p>压缩文件 非打包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> touch a.c       </span><br><span class="line"><span class="meta">#</span> tar -czvf test.tar.gz a.c   //压缩 a.c文件为test.tar.gz</span><br><span class="line">a.c</span><br></pre></td></tr></table></figure>

<p>列出压缩文件内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> tar -tzvf test.tar.gz </span><br><span class="line">-rw-r--r-- root/root     0 2010-05-24 16:51:59 a.c</span><br></pre></td></tr></table></figure>

<p>解压文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> tar -xzvf test.tar.gz a.c</span><br></pre></td></tr></table></figure>

<h2 id="显示当前进程-状态-ps"><a href="#显示当前进程-状态-ps" class="headerlink" title="显示当前进程 状态  ps"></a>显示当前进程 状态  ps</h2><p>Linux ps命令用于显示当前进程 (process) 的状态。</p>
<p><a href="https://ipcmen.com/ps" target="_blank" rel="noopener">Linux ps</a></p>
<h3 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps [options] [--help]</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义</li>
<li>-A 列出所有的行程</li>
<li>-w 显示加宽可以显示较多的资讯</li>
<li>-au 显示较详细的资讯</li>
<li>-aux 显示所有包含其他使用者的行程</li>
<li>au(x) 输出格式 :</li>
<li>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</li>
<li>USER: 行程拥有者</li>
<li>PID: pid</li>
<li>%CPU: 占用的 CPU 使用率</li>
<li>%MEM: 占用的记忆体使用率</li>
<li>VSZ: 占用的虚拟记忆体大小</li>
<li>RSS: 占用的记忆体大小</li>
<li>TTY: 终端的次要装置号码 (minor device number of tty)</li>
<li>STAT: 该行程的状态:</li>
<li>D: 不可中断的静止 (通悸□□缜b进行 I/O 动作)</li>
<li>R: 正在执行中</li>
<li>S: 静止状态</li>
<li>T: 暂停执行</li>
<li>Z: 不存在但暂时无法消除</li>
<li>W: 没有足够的记忆体分页可分配</li>
<li>&lt;: 高优先序的行程</li>
<li>N: 低优先序的行程</li>
<li>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)</li>
<li>START: 行程开始时间</li>
<li>TIME: 执行的时间</li>
<li>COMMAND:所执行的指令</li>
</ul>
<h2 id="终止进程-kill"><a href="#终止进程-kill" class="headerlink" title="终止进程 kill"></a>终止进程 kill</h2><p>Linux kill命令用于删除执行中的程序或工作。</p>
<p>kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或jobs指令查看。</p>
<h3 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称。</li>
<li>-s &lt;信息名称或编号&gt; 　指定要送出的信息。</li>
<li>[程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。</li>
</ul>
<h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><p>杀死进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> kill 12345</span><br></pre></td></tr></table></figure>

<p>强制杀死进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> kill -KILL 123456</span><br></pre></td></tr></table></figure>

<p>发送SIGHUP信号，可以使用一下信号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> kill -HUP pid</span><br></pre></td></tr></table></figure>

<p>彻底杀死进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> kill -9 123456</span><br></pre></td></tr></table></figure>

<p>显示信号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> kill -l</span><br><span class="line">1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line">2) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">3)  SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">4)  SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">5)  SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">6)  SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">7)  SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">8)  SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">9)  SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">10) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">11) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">12) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">13) SIGRTMAX-1	64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>杀死指定用户所有进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>kill -9 $(ps -ef | grep hnlinux) //方法一 过滤出hnlinux用户进程 </span><br><span class="line"><span class="meta">#</span>kill -u hnlinux //方法二</span><br></pre></td></tr></table></figure>

<h2 id="控制系统服务-service"><a href="#控制系统服务-service" class="headerlink" title="控制系统服务  service"></a>控制系统服务  service</h2><p>控制系统服务的实用工具</p>
<h3 id="补充说明-1"><a href="#补充说明-1" class="headerlink" title="补充说明"></a>补充说明</h3><p><strong>service命令</strong> 是Redhat Linux兼容的发行版中用来控制系统服务的实用工具，它以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</p>
<h3 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service(选项)(参数)</span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-h：显示帮助信息；</span><br><span class="line">--status-all：显示所服务的状态。</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>服务名：自动要控制的服务名，即<code>/etc/init.d</code>目录下的脚本文件名；</li>
<li>控制命令：系统服务脚本支持的控制命令。</li>
</ul>
<h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><p>当修改了主机名、ip地址等信息时，经常需要把网络重启使之生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service network status</span><br><span class="line">配置设备：</span><br><span class="line">lo eth0</span><br><span class="line">当前的活跃设备：</span><br><span class="line">lo eth0</span><br><span class="line"></span><br><span class="line">service network restart</span><br><span class="line">正在关闭接口 eth0：                                        [  确定  ]</span><br><span class="line">关闭环回接口：                                             [  确定  ]</span><br><span class="line">设置网络参数：                                             [  确定  ]</span><br><span class="line">弹出环回接口：                                             [  确定  ]</span><br><span class="line">弹出界面 eth0：                                            [  确定  ]</span><br></pre></td></tr></table></figure>

<p>重启mysql</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service mysqld status</span><br><span class="line">mysqld (pid 1638) 正在运行...</span><br><span class="line"></span><br><span class="line">service mysqld restart</span><br><span class="line">停止 MySQL：                                               [  确定  ]</span><br><span class="line">启动 MySQL：                                               [  确定  ]</span><br></pre></td></tr></table></figure>

<h2 id="系统服务管理器指令-systemctl"><a href="#系统服务管理器指令-systemctl" class="headerlink" title="系统服务管理器指令 systemctl"></a>系统服务管理器指令 systemctl</h2><p>系统服务管理器指令</p>
<h3 id="补充说明-2"><a href="#补充说明-2" class="headerlink" title="补充说明"></a>补充说明</h3><p><strong>systemctl命令</strong> 是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。</p>
<table>
<thead>
<tr>
<th>任务</th>
<th>旧指令</th>
<th>新指令</th>
</tr>
</thead>
<tbody><tr>
<td>使某服务自动启动</td>
<td>chkconfig –level 3 httpd on</td>
<td>systemctl enable httpd.service</td>
</tr>
<tr>
<td>使某服务不自动启动</td>
<td>chkconfig –level 3 httpd off</td>
<td>systemctl disable httpd.service</td>
</tr>
<tr>
<td>检查服务状态</td>
<td>service httpd status</td>
<td>systemctl status httpd.service （服务详细信息） systemctl is-active httpd.service （仅显示是否 Active)</td>
</tr>
<tr>
<td>显示所有已启动的服务</td>
<td>chkconfig –list</td>
<td>systemctl list-units –type=service</td>
</tr>
<tr>
<td>启动某服务</td>
<td>service httpd start</td>
<td>systemctl start httpd.service</td>
</tr>
<tr>
<td>停止某服务</td>
<td>service httpd stop</td>
<td>systemctl stop httpd.service</td>
</tr>
<tr>
<td>重启某服务</td>
<td>service httpd restart</td>
<td>systemctl restart httpd.service</td>
</tr>
</tbody></table>
<h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><p>1.启动nfs服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start nfs-server.service</span><br></pre></td></tr></table></figure>

<p>2.设置开机自启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable nfs-server.service</span><br></pre></td></tr></table></figure>

<p>3.停止开机自启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable nfs-server.service</span><br></pre></td></tr></table></figure>

<p>4.查看服务当前状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status nfs-server.service</span><br></pre></td></tr></table></figure>

<p>5.重新启动某服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart nfs-server.service</span><br></pre></td></tr></table></figure>

<p>6.查看所有已启动的服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl list -units --type=service</span><br></pre></td></tr></table></figure>

<p>开启防火墙22端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 22 -j accept</span><br></pre></td></tr></table></figure>

<p>如果仍然有问题，就可能是SELinux导致的</p>
<p>关闭SElinux：</p>
<p>修改<code>/etc/selinux/config</code>文件中的<code>SELINUX=””</code>为disabled，然后重启。</p>
<p>彻底关闭防火墙：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status firewalld.service</span><br><span class="line">sudo systemctl stop firewalld.service          </span><br><span class="line">sudo systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://ipcmen.com/" target="_blank" rel="noopener">Linux命令大全（手册）</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS动画</title>
    <url>/2019-10-29/Css/CSS%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h2 id="CSS动画的分类"><a href="#CSS动画的分类" class="headerlink" title="CSS动画的分类"></a>CSS动画的分类</h2><ul>
<li>transition补间，过度动画：控制最开始的状态和最末的状态的动画，中间的状态由浏览器自动帮我们计算生成</li>
<li>keyframe关键帧动画</li>
<li>逐帧动画</li>
</ul><h2 id="transition补间动画"><a href="#transition补间动画" class="headerlink" title="transition补间动画"></a>transition补间动画</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-property" target="_blank" rel="noopener">transition-property</a>：规定设置过渡效果的 CSS 属性的名称。只有指定的属性才会在过渡中发生动画，其它属性仍如通常那样瞬间变化。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-duration" target="_blank" rel="noopener">transition-duration</a>：指定过渡的时长。或者为所有属性指定一个值，或者指定多个值，为每个属性指定不同的时长。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function" target="_blank" rel="noopener">transition-timing-function</a>：规定速度效果的速度曲线。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-delay" target="_blank" rel="noopener">transition-delay</a>：指定延迟，即属性开始变化时与过渡开始发生时之间的时长。</li>
</ul><a id="more"></a>

<h3 id="补间动画场景"><a href="#补间动画场景" class="headerlink" title="补间动画场景"></a>补间动画场景</h3><ul>
<li>位置-平移（left，right，margin，transform）</li>
<li>方位-旋转（transform: rotate）</li>
<li>大小-缩放（transform: scale）</li>
<li>透明度（opacity）</li>
<li>其他-线性变换（transform）</li>
</ul>
<h3 id="补间动画过度动画"><a href="#补间动画过度动画" class="headerlink" title="补间动画过度动画"></a>补间动画过度动画</h3><p><a href="https://matthewlein.com/tools/ceaser" target="_blank" rel="noopener">ceaser</a>：过度动画</p>
<h2 id="keyframe关键帧动画"><a href="#keyframe关键帧动画" class="headerlink" title="keyframe关键帧动画"></a>keyframe关键帧动画</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes" target="_blank" rel="noopener">@keyframes</a> 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。这比 <strong>transition</strong> 更能控制动画序列的中间步骤。</p>
<p>要使用关键帧, 先创建一个带名称的 <strong>@keyframes</strong> 规则，以便后续使用 <strong>animation-name</strong> 这个属性来将一个动画同其关键帧声明匹配。每个 <strong>@keyframes</strong> 规则包含多个关键帧，也就是一段样式块语句，每个关键帧有一个百分比值作为名称，代表在动画进行中，在哪个阶段触发这个帧所包含的样式。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation" target="_blank" rel="noopener">animation</a>：属性是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name" target="_blank" rel="noopener">animation-name</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-duration" target="_blank" rel="noopener">animation-duration</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-timing-function" target="_blank" rel="noopener">animation-timing-function</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-delay" target="_blank" rel="noopener">animation-delay</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-iteration-count" target="_blank" rel="noopener">animation-iteration-count</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-direction" target="_blank" rel="noopener">animation-direction</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-fill-mode" target="_blank" rel="noopener">animation-fill-mode</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-play-state" target="_blank" rel="noopener">animation-play-state</a> 属性的一个简写属性形式。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name" target="_blank" rel="noopener">animation-name</a>：属性指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-direction" target="_blank" rel="noopener">animation-direction</a>: 指示动画是否反向播放，它通常在简写属性animation中设定</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-fill-mode" target="_blank" rel="noopener">animation-fill-mode</a>：设置CSS动画在执行之前和之后如何将样式应用于其目标。决定动画停在哪里。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-iteration-count" target="_blank" rel="noopener">animation-iteration-count</a>: 定义动画在结束前运行的次数 可以是1次 无限循环。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-play-state" target="_blank" rel="noopener">animation-play-state</a>：定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。</li>
</ul>
<h2 id="逐帧动画"><a href="#逐帧动画" class="headerlink" title="逐帧动画"></a>逐帧动画</h2><ul>
<li>每一帧都是关键帧，没有补间，过度</li>
<li>适用于无法补间计算的动画</li>
<li>资源较大，需要大量图片</li>
<li>使用 animation-timing-function: steps(1)，1保证每个区间只有一个画面，取消补间，过度效果。</li>
</ul>
<h2 id="过度动画与关键帧动画的区别"><a href="#过度动画与关键帧动画的区别" class="headerlink" title="过度动画与关键帧动画的区别"></a>过度动画与关键帧动画的区别</h2><ul>
<li>过度动画需要有状态改变</li>
<li>关键帧动画不需要状态改变</li>
<li>关键帧动画能控制更精细</li>
</ul>
<h2 id="逐帧动画如何实现"><a href="#逐帧动画如何实现" class="headerlink" title="逐帧动画如何实现"></a>逐帧动画如何实现</h2><ul>
<li>使用关键帧动画</li>
<li>消除补间，过度（steps）</li>
</ul>
<h2 id="CSS动画性能"><a href="#CSS动画性能" class="headerlink" title="CSS动画性能"></a>CSS动画性能</h2><ul>
<li>性能不差</li>
<li>部分情况下优于js</li>
<li>js可以做到更好，可以优化</li>
<li>部分高危属性，如：box-shadow等</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes" target="_blank" rel="noopener">CSS3中的关键帧</a></li>
<li><a href="https://coding.imooc.com/class/164.html" target="_blank" rel="noopener">全面系统讲解CSS工作应用+面试一步搞定</a></li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS布局</title>
    <url>/2019-10-29/Css/CSS%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="CSS实现三栏布局"><a href="#CSS实现三栏布局" class="headerlink" title="CSS实现三栏布局"></a>CSS实现三栏布局</h2><ul>
<li>float布局</li>
<li>Position定位</li>
<li>table布局</li>
<li>弹性(flex)布局</li>
<li>inline-block布局</li>
</ul><h3 id="float布局-margin"><a href="#float布局-margin" class="headerlink" title="float布局 + margin"></a>float布局 + margin</h3><ul>
<li>元素脱离文档流</li>
<li>不脱离文本流</li>
</ul><p>对自身影响：</p><ul>
<li>形成块（BFC），可以设置宽高</li>
<li>位置尽量靠上</li>
<li>位置尽量靠左或靠右</li>
</ul><p>对兄弟元素影响：</p><ul>
<li>上面贴非float元素</li>
<li>旁边贴float元素</li>
<li>不影响其他块级元素位置</li>
<li>影响其块级元素文本</li>
</ul><a id="more"></a>





<p>对父级元素影响：</p>
<ul>
<li>从布局上消失</li>
<li>造成高度塌陷（清除浮动）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS实现三栏布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 100px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#631D9F</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">            float: right;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span> &#123;</span></span><br><span class="line">            margin-left: 300px;</span><br><span class="line">            margin-right: 300px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#4990E2</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="comment">/*清除浮动*/</span></span></span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/*清除浮动*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">            content: '';</span><br><span class="line">            display: block;</span><br><span class="line">            clear: both;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>中</span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>浮动布局<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Position布局"><a href="#Position布局" class="headerlink" title="Position布局"></a>Position布局</h3><p>position其属性有5种 :</p>
<ul>
<li>inherit: 继承父元素的position属性值</li>
<li>static: 默认值，没有定位</li>
<li>fixed: 生成绝对定位的元素,相对于浏览器窗口进行定位（不管屏幕内容怎么滑动,其位置不会改变）</li>
<li>relative:生成相对定位，相对于其原本位置进行定位</li>
<li>absolute:生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS实现三栏布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            left: 0;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            left: 300px;</span><br><span class="line">            right: 300px;</span><br><span class="line">            background-color: blue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            right: 0;</span><br><span class="line">            width: 300px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#3A2CAC</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>中</span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Position布局<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS实现三栏布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> &#123;</span></span><br><span class="line">            width: 100%;</span><br><span class="line">            display: table;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span>,</span></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">            display: table-cell;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span> &#123;</span></span><br><span class="line">            background-color: blue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>中</span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>table布局<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="弹性-flex-布局"><a href="#弹性-flex-布局" class="headerlink" title="弹性(flex)布局"></a>弹性(flex)布局</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS实现三栏布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> &#123;</span></span><br><span class="line">            display: flex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            width: 400px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span> &#123;</span></span><br><span class="line">            background-color: blue;</span><br><span class="line">            word-break: break-word;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">            background-color: red;</span><br><span class="line">            width: 400px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>中</span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>弹性(flex)布局<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="inline-block布局"><a href="#inline-block布局" class="headerlink" title="inline-block布局"></a>inline-block布局</h3><p>inline-block布局存在间隙</p>
<ul>
<li>原因：存在空白字符，字符存在间距</li>
<li>解决：消灭空白字符或消除间距</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS实现三栏布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="comment">/*消除inline-block字符间隔*/</span></span></span><br><span class="line">            font-size: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span>,</span></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">            display: inline-block;</span><br><span class="line"><span class="css">            <span class="comment">/*重新设置字体大小*/</span></span></span><br><span class="line">            font-size: 14px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.center</span> &#123;</span></span><br><span class="line">            background-color: blue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>中</span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>inline-block布局<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="如何清除浮动"><a href="#如何清除浮动" class="headerlink" title="如何清除浮动"></a>如何清除浮动</h2><p>父元素设置 <strong><em>overflow</em></strong>：</p>
<ul>
<li>overflow: hidden;</li>
<li>overflow: auto;</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="comment">/*清除浮动*/</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父元素设置 <strong><em>::after</em></strong> ：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*清除浮动*/</span></span><br><span class="line"><span class="selector-class">.main</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何适配移动端界面"><a href="#如何适配移动端界面" class="headerlink" title="如何适配移动端界面"></a>如何适配移动端界面</h2><ul>
<li>viewport</li>
<li>rem/viewport/media query（响应式布局）</li>
<li>设计上：隐藏，折行，自适应等</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/164.html" target="_blank" rel="noopener">全面系统讲解CSS工作应用+面试一步搞定</a></li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS选择器</title>
    <url>/2019-10-28/Css/CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p>CSS 选择器是用来指定该组 CSS 样式会对什么元素生效的，是连接 HTML 结构和 CSS 样式的桥梁。</p><h2 id="选择器分离"><a href="#选择器分离" class="headerlink" title="选择器分离"></a>选择器分离</h2><ul>
<li>ID 选择器 #id{}</li>
<li>类选择器 .link{}</li>
<li>通配选择器 *{}</li>
<li>标签选择器 div{}</li>
<li>属性选择器 input[class=input]{}</li>
<li>伪类选择器 :hover{}</li>
<li>伪元素选择器 ::before{}</li>
<li>组合选择器 h1 + p</li>
<li>否定选择器 :not(.link){}</li>
</ul><a id="more"></a>

<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ul>
<li>[attr]，用来选择带有 attr 属性的元素，如刚提到的 a [href]。</li>
<li>[attr=xxx]，用来选择有 attr 属性且属性值等于 xxx 的元素</li>
<li>[attr~=xxx]，这个选择器中间用了～=，选择属性值中包含 xxx 的元素，但一定是逗号分隔的多个值中有一个能和 xxx 相等才行</li>
<li>[attr|=xxx]，这个选择器是用来选择属性值为 xxx 或 xxx- 开头的元素，比较常用的场景是选择某一类的属性。</li>
<li>[attr^=xxx]，这个选择器会匹配以 xxx 开头的元素，实际上就是用正则去匹配属性值，只要是以 xxx 开头都可以。</li>
<li>[attr$=xxx]，这个选择器和上一个相似，它是用正则匹配的方式来选择属性值以 xxx 结尾的元素。</li>
<li>[attr*=xxx]，这个是用正则匹配的方式来选择属性值中包含 xxx 字符的所有元素。这个选择器的规则算是最宽泛的，只要 xxx 是元素属性值的子字符串，这个选择器就会生效。</li>
</ul>
<h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.page</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class 为 page 元素里面的所有 p 元素的字体都改成 18px</p>
<h4 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.page</span> &gt; <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class 为 page 元素里面的所有儿子元素 p 的字体都改成 18px</p>
<h4 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> + <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>h1 + p 选择器就表示选择紧邻 h1 元素的 p 元素，让这个 p 元素距离标题隔开 10px，并且字体设置为红色。这里要注意，相邻选择器只能选择紧挨在 h1 后面的 p 元素，而不能向前找。</p>
<h4 id="通用兄弟选择器"><a href="#通用兄弟选择器" class="headerlink" title="通用兄弟选择器"></a>通用兄弟选择器</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> ~ <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的选择器会选中和 h1 元素同级且在 h1 元素后面出现的 p 元素，并给它们加上红色的字体样式</p>
<h3 id="伪类选择器和伪元素选择器"><a href="#伪类选择器和伪元素选择器" class="headerlink" title="伪类选择器和伪元素选择器"></a>伪类选择器和伪元素选择器</h3><p>伪元素是真实存在的元素，在页面中可以有内容，样式。 伪类是标记一些特殊的状态，鼠标选中某个元素时，状态下的样式。某个元素的状态。</p>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><h4 id="标记状态的伪类"><a href="#标记状态的伪类" class="headerlink" title="标记状态的伪类"></a>标记状态的伪类</h4><ul>
<li>:link，选取未访问过的超链接元素。如果我们注意过搜索引擎的结果的话，它里面的链接只要点过的就会变色，从而标记哪个链接是访问过的。:link 这个属性就是用来标识没访问过的链接。</li>
<li>:visited，选取访问过的超链接元素。和第一条相反，:visited 是用来标记哪个链接是已经访问过的，防止重复点击。</li>
<li>:hover，选取鼠标悬停的元素。，这个伪类经常用在 PC 端，当鼠标放在一个元素上时，可以用 :hover 来控制鼠标悬停的样式。因为在移动端里没有鼠标的概念，所以移动端里很少用这个伪类。</li>
<li>:active，选取点中的元素。这个伪类的作用在刚才提到过了，当我们希望按钮有操作反馈的时候，可以用它来标记操作反馈的样式。当然这个伪类也是可以通用的，并不是只能用在按钮上。</li>
<li>:focus，选取获得焦点的元素。这个伪类用来标识获得焦点的元素，比如搜索框在聚焦的时候有个比较明显的边框，方便用户知道当前在可输入的状态。</li>
</ul>
<h4 id="筛选功能的伪类"><a href="#筛选功能的伪类" class="headerlink" title="筛选功能的伪类"></a>筛选功能的伪类</h4><ul>
<li>:empty，选取没有子元素的元素。比如选择空的 span，就可以用 span:empty 选择器来选择。这里要注意元素内有空格的话也不能算空，不会被这个伪类选中。</li>
<li>:checked，选取勾选状态的 input 元素， 只对 radio 和 checkbox 生效。</li>
<li>:disabled，选取禁用的表单元素。</li>
<li>:first-child，选取当前选择器下第一个元素。</li>
<li>:last-child，和 first-child 相反，选取当前选择器下最后一个元素。</li>
<li>:nth-child(an+b)，选取指定位置的元素。这个伪类是有参数的，参数可以支持 an+b 的形式，这里 a 和 b 都是可变的，n 从0起。使用这个伪类可以做到选择第几个，或者选择序号符合 an+b 的所有元素。比如使用 li:nth-child(2n+1)，就可以选中 li 元素中序号是2的整数倍加1的所有元素，也就是第1、3、5、7、9、2n+1个 li 元素。</li>
<li>:nth-last-child(an+b) ，这个伪类和 nth-child 相似，只不过在计数的时候，这个伪类是从后往前计数。</li>
<li>:only-child，选取唯一子元素。如果一个元素的父元素只有它一个子元素，这个伪类就会生效。如果一个元素还有兄弟元素，这个伪类就不会对它生效。-</li>
<li>:only-of-type，选取唯一的某个类型的元素。如果一个元素的父元素里只有它一个当前类型的元素，这个伪类就会生效。这个伪类允许父元素里有其他元素，只要不和自己一样就可以。</li>
</ul>
<h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>伪元素选择器是用于向某些元素设置特殊效果。伪元素选择器选中的并不是真实的 DOM 元素，所以叫伪元素选择器。伪元素选择器常用的也就下面 5 个：</p>
<ul>
<li>::first-line，为某个元素的第一行文字使用样式。</li>
<li>::first-letter，为某个元素中的文字的首字母或第一个字使用样式。</li>
<li>::before，在某个元素之前插入一些内容。</li>
<li>::after，在某个元素之后插入一些内容。</li>
<li>::selection，对光标选中的元素添加样式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">伪元素选择器构造的元素是虚拟的，所以不能用 JS 去操作它。</span><br><span class="line"></span><br><span class="line">如果同时使用了 before 和 first-letter 两个伪类，第一个字是要从 before 里的内容开始算起的，如果 before里面的内容是一个非文本元素，那 first-letter 也会作用在这个非文本元素上，但是不一定能生效。</span><br><span class="line"></span><br><span class="line">first-line 和 first-letter 不适用于内联元素，在内联元素中这两个选择器都会失效。</span><br><span class="line"></span><br><span class="line">在 CSS3 中，规定了伪类用一个冒号（:）表示，伪元素用两个冒号表示（::）。但除了 selection，其余四个伪元素选择器已经在 CSS2 中存在且和伪类用的是一样的单冒号表示的。为了向下兼容，现在的浏览器中伪元素选择器用单冒号和双冒号都可以。在没有兼容问题的情况下，还是建议大家按着新的 CSS3 标准来开发。</span><br></pre></td></tr></table></figure>

<h2 id="样式优先级关系"><a href="#样式优先级关系" class="headerlink" title="样式优先级关系"></a>样式优先级关系</h2><p>当一个 DOM 元素受到多条样式控制的时候，样式的优先级顺序应该是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内联样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通用选择器 &gt; 继承样式 &gt; 浏览器默认样式</span><br></pre></td></tr></table></figure>

<h2 id="选择器权重"><a href="#选择器权重" class="headerlink" title="选择器权重"></a>选择器权重</h2><ul>
<li>内联样式的权重是 1000。</li>
<li>ID 选择器里样式的权重是 100。</li>
<li>类选择器、属性选择器和伪类选择器里样式的权重是 10。</li>
<li>标签选择器里样式的权重是 1。</li>
<li>通用选择器直接忽略。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、这个计算模型仅供理解样式优先级关系，不能代表浏览器里真实的计算方法。</span><br><span class="line">2、权重值的计算不能越级，比如选择器 A 只有 1 个 ID 选择器，权重就是 100；选择器 B 用了 20 个类选择器，权重值是 200。这个时候如果两个选择器对应的样式作用在同一个 DOM 节点上，那么还是选择器A会生效，因为它的选择器级别更高。</span><br><span class="line">3、如果两个选择器 A 和 B 是同级别选择器，并且最终计算的权重值也相同，那么这两个选择器谁在后面谁优先级高。</span><br><span class="line">4、!important 优先级最高。</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.imooc.com/read/36" target="_blank" rel="noopener">手把手带你打造自己的UI样式库</a></p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML基础</title>
    <url>/2019-10-28/Html/HTML%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h2><h2 id="DOCTYPE的作用"><a href="#DOCTYPE的作用" class="headerlink" title="DOCTYPE的作用"></a>DOCTYPE的作用</h2><ul>
<li>告诉浏览器的解析器使用哪种HTML规范或者XHTML规范来解析页面</li>
<li>让浏览器以标准模式渲染（盒子模型）</li>
<li>让浏览器知道元素的合法性</li>
</ul><h2 id="HTML-XHTML-HTML5的关系"><a href="#HTML-XHTML-HTML5的关系" class="headerlink" title="HTML XHTML HTML5的关系"></a>HTML XHTML HTML5的关系</h2><ul>
<li>HTML是超文本标记语言，属于SGML</li>
<li>XHTML属于XML，是HTML进行XML严格化的结果</li>
<li>HTML5不属于SGML或XML，比XHTML宽松</li>
</ul><a id="more"></a>

<h2 id="HTML5有什么变化"><a href="#HTML5有什么变化" class="headerlink" title="HTML5有什么变化"></a>HTML5有什么变化</h2><ul>
<li>新的语义化元素：section，article，footer，header</li>
<li>表单增强</li>
<li>新的API：离线，音视频，图形，实时通信，本地存储，设备能力<ul>
<li>离线：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache" target="_blank" rel="noopener">Application Cache</a>，已废弃，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service Worker</a></li>
<li>音视频：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio" target="_blank" rel="noopener">audio</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video" target="_blank" rel="noopener">video</a></li>
<li>图形：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas" target="_blank" rel="noopener">canvas</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial" target="_blank" rel="noopener">svg</a></li>
<li>实时通信：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">WebSocket</a></li>
<li>本地存储：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="noopener">localStorage</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener">sessionStorage</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">IndexedDB</a></li>
<li>设备能力：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation/Using_geolocation" target="_blank" rel="noopener">navigator.geolocation</a>，获取地理位置。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/deviceorientation_event" target="_blank" rel="noopener">deviceorientation</a>，陀螺仪。</li>
<li>分类和嵌套规则</li>
</ul>
</li>
</ul>
<h2 id="em和i的区别"><a href="#em和i的区别" class="headerlink" title="em和i的区别"></a>em和i的区别</h2><p>就表现而言&lt;em&gt;&lt;/em&gt;,&lt;i&gt;&lt;/i&gt;表现都一样，都是表示斜体。</p>
<p>但是&lt;em&gt;标签是“含有语义”的标签，搜索引擎会了解这些语义。其在HTML中是特意被设定为表示“强调”的意思。当发现这些表示“强调”的标签时，一些屏幕阅读器可能使用不同的inflection，更利于SEO。</p>
<p>i 是存样式标签。</p>
<p>HTML5中 i 不推荐使用。</p>
<h2 id="语义化的意义"><a href="#语义化的意义" class="headerlink" title="语义化的意义"></a>语义化的意义</h2><ul>
<li>开发者容易理解</li>
<li>机器容易理解结构（搜索引擎，读屏软件）</li>
<li>有助于SEO</li>
<li>semantic microdata</li>
</ul>
<h2 id="哪些元素可以自闭合"><a href="#哪些元素可以自闭合" class="headerlink" title="哪些元素可以自闭合"></a>哪些元素可以自闭合</h2><ul>
<li>表单元素 input</li>
<li>图片 img</li>
<li>br hr</li>
<li>meta link</li>
</ul>
<h2 id="HTML和DOM的关系"><a href="#HTML和DOM的关系" class="headerlink" title="HTML和DOM的关系"></a>HTML和DOM的关系</h2><ul>
<li>HTML是’死‘的</li>
<li>DOM有HTML解析而来，是活的</li>
<li>JS可以维护 DOM</li>
</ul>
<h2 id="property和attribute的区别"><a href="#property和attribute的区别" class="headerlink" title="property和attribute的区别"></a>property和attribute的区别</h2><ul>
<li>attribute是’死‘的</li>
<li>property是活的，有HTML解析生成</li>
<li>修改互不影响</li>
</ul>
<h2 id="form的作用有哪些"><a href="#form的作用有哪些" class="headerlink" title="form的作用有哪些"></a>form的作用有哪些</h2><ul>
<li>直接提交表单</li>
<li>使用 submit / reset 按钮</li>
<li>便于浏览器保存表单</li>
<li>第三方库可以整体提取值</li>
<li>第三方库可以进行表单验证</li>
</ul>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型属性：</p>
<ul>
<li>宽度（width）和高度（height），这两个属性分别决定了一个盒子的宽度和高度，在标准盒模型中，这个宽高指定的就是最里层内容区的宽度和高度，对应画框中最里面带色彩的部分。</li>
<li>内边距（padding），当内容区和边框需要离开一定的间距，避免布局太过拥挤时，就可以用内边距来指定他们隔开的距离。在画框中就对应着内容区和边框中间夹着的那部分白色的区域。</li>
<li>边框（border），边框比较好理解，就是每幅画的外框。</li>
<li>外边距（margin），外边距是用来限制盒子与盒子中间的距离的，在上图中，三幅画边框与边框中间空出来的距离，就由外边距来指定。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">            div&#123;</span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                padding: 10px;</span><br><span class="line"><span class="css">                <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#000</span>;</span></span><br><span class="line">                margin: 20px;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="comment">/* 标准盒模型 **/</span></span></span><br><span class="line"><span class="css">            <span class="selector-class">.content-box</span>&#123;</span></span><br><span class="line">                box-sizing: content-box;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="comment">/* 怪异盒模型 **/</span></span></span><br><span class="line"><span class="css">            <span class="selector-class">.border-box</span>&#123;</span></span><br><span class="line">                box-sizing: border-box;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标准盒模型 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-box"</span>&gt;</span></span><br><span class="line">            我是content-box</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 怪异盒模型 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"border-box"</span>&gt;</span></span><br><span class="line">            我是border-box</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3><p>盒子实际大小是：</p>
<ul>
<li>横向空间：width  + padding宽度 + border宽度</li>
<li>纵向空间：height + padding高度 + border宽度</li>
</ul>
<h3 id="怪异盒模型"><a href="#怪异盒模型" class="headerlink" title="怪异盒模型"></a>怪异盒模型</h3><p>在怪异模式下，width 和 height 做指定的宽高就是盒子的实际宽高，而它内容区部分的大小是在 width 或 height 指定尺寸的基础上，再减去 border 和 padding 所占的宽度。</p>
<h2 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h2><p>但是如果两个盒子都设置了 margin，在排列这两个盒子的时候左右外边距是叠加的，上下外边距是取最大值。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/164.html" target="_blank" rel="noopener">全面系统讲解CSS工作应用+面试一步搞定</a></li>
<li><a href="https://www.imooc.com/read/36" target="_blank" rel="noopener">手把手带你打造自己的UI样式库</a></li>
</ul>
]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>node-stream实现原理</title>
    <url>/2019-10-24/Node/node-stream%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="stream实现原理"><a href="#stream实现原理" class="headerlink" title="stream实现原理"></a>stream实现原理</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// let buffer = Buffer.alloc(BUFFER_SIZE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fs.open(path, flags[, mode], callback): 异步打开文件, 返回文件描述符fd</span></span><br><span class="line"><span class="comment"> * path - 文件的路径。</span></span><br><span class="line"><span class="comment"> * flags -文件打开的行为。 具体值详见下文。</span></span><br><span class="line"><span class="comment"> * mode - 设置文件模式(权限)， 文件创建默认权限为 0666(可读， 可写)。</span></span><br><span class="line"><span class="comment"> * callback - 回调函数， 带有两个参数如： callback(err, fd)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fs.read(fd, buffer, offset, length, position, callback): 通过文件描述符 fd 读取文件内容</span></span><br><span class="line"><span class="comment"> * fd - 通过 fs.open() 方法返回的文件描述符，从 fd 指定的文件中读取数据。</span></span><br><span class="line"><span class="comment"> * buffer - 数据将写入的缓冲区。</span></span><br><span class="line"><span class="comment"> * offset - buffer 中开始写入的偏移量。</span></span><br><span class="line"><span class="comment"> * length - 缓冲区写入的字节数。</span></span><br><span class="line"><span class="comment"> * position - 参数指定从文件中开始读取的位置。 如果 position 为 null，则从当前文件位置读取数据，并更新文件位置。 如果 position 是整数，则文件位置将保持不变</span></span><br><span class="line"><span class="comment"> * callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* fs.write(fd, buffer, offset, length[, position], callback): 将 buffer 写入到 fd 指定的文件</span></span><br><span class="line"><span class="comment">* fd - 通过 fs.open() 方法返回的文件描述符。</span></span><br><span class="line"><span class="comment">* buffer - 将 buffer 写入到 fd 指定的文件。</span></span><br><span class="line"><span class="comment">* offset - 决定 buffer 中要被写入的部位。</span></span><br><span class="line"><span class="comment">* length - 是一个整数，指定要写入的字节数。</span></span><br><span class="line"><span class="comment">* position - 指定文件开头的偏移量（ 数据应该被写入的位置）。</span></span><br><span class="line"><span class="comment">* callback - 回调函数， 有三个参数err, bytesWritten, buffer， err 为错误信息， bytesWritten 指定 buffer 中被写入的字节数， buffer 为缓冲区对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fs.write(fd, string[, position[, encoding]], callback): 将 string 写入到 fd 指定的文件。 如果 string 不是一个字符串， 则该值会被强制转换为字符串。</span></span><br><span class="line"><span class="comment"> * position 指定文件开头的偏移量（ 数据应该被写入的位置）。 如果 typeof position !== 'number'，则数据会被写入当前的位置。</span></span><br><span class="line"><span class="comment"> * encoding 是期望的字符串编码。</span></span><br><span class="line"><span class="comment"> * callback回调会接收到参数(err, written, string)， 其中 written 指定传入的字符串中被要求写入的字节数。 被写入的字节数不一定与被写入的字符串字符数相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readPath = path.resolve(__dirname, <span class="string">'1.txt'</span>);</span><br><span class="line"><span class="keyword">const</span> writePath = path.resolve(__dirname, <span class="string">'2.txt'</span>);</span><br><span class="line">fs.open(readPath, <span class="string">'r'</span>, (err, rfd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"打开文件fd："</span> + rfd)</span><br><span class="line">        fs.open(writePath, <span class="string">'w'</span>, (err, wfd) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(err);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"打开文件fd："</span> + wfd)</span><br><span class="line">                <span class="keyword">let</span> readPosition = <span class="number">0</span>;</span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">let</span> buffer = Buffer.alloc(BUFFER_SIZE);</span><br><span class="line">                    fs.read(rfd, buffer, <span class="number">0</span>, BUFFER_SIZE, readPosition, (err, bytesRead) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.error(err);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            readPosition += bytesRead;</span><br><span class="line">                            <span class="comment">//如果调用fs.write(fd, buffer, offset, length[, position], callback) 将buffer写入到fd指定的文件会出现乱码的情况</span></span><br><span class="line">                            <span class="comment">//此处调用fs.write(fd, string[, position[, encoding]], callback) 将string写入到fd指定的文件不会出现乱码</span></span><br><span class="line">                            <span class="keyword">if</span> (bytesRead != <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//递归</span></span><br><span class="line">                                fs.write(wfd, buffer, <span class="number">0</span>, bytesRead, (err, bytesWritten, buffer) =&gt; &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                                        <span class="built_in">console</span>.error(err);</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        next();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;)</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//关闭文件</span></span><br><span class="line">                                fs.close(rfd, () =&gt; &#123;</span><br><span class="line">                                    <span class="built_in">console</span>.log(<span class="string">"关闭文件fd："</span> + rfd)</span><br><span class="line">                                &#125;);</span><br><span class="line">                                fs.close(wfd, () =&gt; &#123;</span><br><span class="line">                                    <span class="built_in">console</span>.log(<span class="string">"关闭文件fd："</span> + wfd)</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                next()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.zhufengpeixun.cn/main/course/index.html" target="_blank" rel="noopener">珠峰前端架构师</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux中间件原理</title>
    <url>/2019-10-21/Redux/Redux%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Redux中间件原理"><a href="#Redux中间件原理" class="headerlink" title="Redux中间件原理"></a>Redux中间件原理</h2><p><img src="/images/middleware.png" alt="Redux中间件"> </p><p>中间件主要被用于分离那些不属于你应用的核心业务逻辑的可被组合起来使用的代码。</p><ul>
<li>不使用middleware时，在dispatch(action)时会执行Reducer，并根据action的type更新返回相应的state。</li>
<li>而在使用middleware时，简言之，middleware会将我们当前的action做相应的处理，随后再交付Reducer执行</li>
<li>通过重写dispatch方法，在派发action之前或之后添加逻辑（AOP）。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。每一个 middleware 处理一个相对独立的业务需求，通过串联不同的 middleware，实现变化多样的的功能。</li>
</ul><a id="more"></a>


<h2 id="相关源码分析"><a href="#相关源码分析" class="headerlink" title="相关源码分析"></a>相关源码分析</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="keyword">function</span> (<span class="params">&#123; getState, dispatch &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`旧状态：<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(getState())&#125;</span>`</span>);</span><br><span class="line">            next(action);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`新状态：<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(getState())&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> thunk = <span class="function"><span class="keyword">function</span> (<span class="params">&#123; getState, dispatch &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">                action(dispatch);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(next)</span><br><span class="line">                next(action)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> store = createStore(...args);<span class="comment">//创建store</span></span><br><span class="line">            <span class="keyword">let</span> dispatch;</span><br><span class="line">            <span class="comment">//中间件api</span></span><br><span class="line">            <span class="keyword">let</span> middlewareAPI = &#123;</span><br><span class="line">                getState: store.getState,<span class="comment">//获取仓库中的状态</span></span><br><span class="line">                <span class="comment">//dispatch指向箭头函数会指向包装后的dispatch 即compose(...chain)(store.dispatch) 这样就可以解决多层嵌套派发action的问题</span></span><br><span class="line">                dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)<span class="comment">//派发动作</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI));</span><br><span class="line">            <span class="comment">//compose 是函数式编程中的组合，compose 将 chain 中的所有匿名函数，[f1, f2, ... , fx, ..., fn]，组装成一个新的函数，即新的 dispatch，当新 dispatch 执行时，[f1, f2, ... , fx, ..., fn]，从右到左依次执行（ 所以顺序很重要）</span></span><br><span class="line">            dispatch = compose(...chain)(store.dispatch);</span><br><span class="line">            <span class="comment">//返回重写dispatch方法后的store</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...store,</span><br><span class="line">                dispatch</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reduce有四个参数</span></span><br><span class="line"><span class="comment"> * previousValue: 上一次调用callback时返回的值</span></span><br><span class="line"><span class="comment"> * currentValue: 正在处理的数组元素</span></span><br><span class="line"><span class="comment"> * index: 正在处理的数组元素下标</span></span><br><span class="line"><span class="comment"> * array: 被处理的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> funcs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将 funcs 中的所有匿名函数，[f1, f2, ... , fx, ..., fn]，组装成一个新的函数，当新的函数执行时，[f1, f2, ... , fx, ..., fn]，从右到左依次执行（ 所以顺序很重要）</span></span><br><span class="line">    <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = applyMiddleware(thunk, logger)(createStore)(reducer);</span><br><span class="line"><span class="comment">// let store = createStore(reducer, applyMiddleware(thunk, logger));</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<h3 id="代码执行过程分析"><a href="#代码执行过程分析" class="headerlink" title="代码执行过程分析"></a>代码执行过程分析</h3><ul>
<li><p>1、依次执行middleware：将middleware执行后返回的函数合并到一个chain数组，如下</p>
<ul>
<li><p><strong><em>const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ES6箭头函数</span><br><span class="line">export default (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 即</span><br><span class="line">function (&#123; dispatch, getState &#125;) &#123;</span><br><span class="line">    return function(next) &#123;</span><br><span class="line">        return function (action) &#123;</span><br><span class="line">            return &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么此时合并的chain结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[    ...,</span><br><span class="line">    function(next) &#123;</span><br><span class="line">        return function (action) &#123;</span><br><span class="line">            return &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2、修改dispatch，增加功能：compose函数，实际就是一个柯里化函数，即将所有的middleware合并成一个middleware，并在最后一个middleware中传入当前的dispatch</p>
<ul>
<li><strong><em>dispatch = compose(…chain)(store.dispatch) 返回重写的dispatch</em></strong><br><img src="/images/middleware2.png" alt="compose"> </li>
</ul>
<p>执行 <strong><em>compose(…chain)(store.dispatch)</em></strong>，当前 <strong><em>a</em></strong> 对应于 <strong><em>蓝色框</em></strong> 代码，<strong><em>b</em></strong> 对应于 <strong><em>红色框</em></strong> 代码 。首先会执行 <strong><em>红色框</em></strong> 对应的代码，执行后返回 <strong><em>黄色框</em></strong> 对应的代码。此时，<strong><em>蓝色框</em></strong> 中的next指向 <strong><em>黄色框</em></strong> 对应的代码。最终 <strong><em>蓝色框</em></strong> 对应的代码执行，返回 <strong><em>绿色框</em></strong> 的代码。就是重写的 <strong><em>dispatch</em></strong> 函数。</p>
</li>
<li><p>3、触发异步action，执行过程如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">asyncAdd()&#123;</span><br><span class="line">  <span class="comment">//在redux中派发的动作只能是纯对象，并不能 store.dispatch 函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dispatch</span>)</span>&#123;</span><br><span class="line">       setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            dispatch(&#123;<span class="attr">type</span>:types.ADD&#125;);</span><br><span class="line">       &#125;, <span class="number">1000</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>触发 asyncAdd，执行 <strong>绿色框*</strong> 的代码，由于当前 action 为 <strong><em>asyncAdd</em></strong> 函数中返回的函数，所有会执行 <strong><em>action(dispatch)</em></strong>。执行<strong><em>asyncAdd</em></strong> 中的函数，执行setTimeout，1秒钟之后执行 <strong><em>dispatch({type:types.ADD});</em></strong> ，即执行 <strong>绿色框*</strong> 的代码。由于当前 action 为 对象，所有会执行  else 条件中的代码。当前，<strong><em>next</em></strong> 指向 <strong><em>黄色框</em></strong> 的代码。执行 <strong><em>黄色框</em></strong> 的代码，先打印旧状态，然后执行 <strong><em>next(action);</em></strong>，当前 <strong><em>next</em></strong> 指向原生的 dispatch 函数，会触发 action 修改 state，触发视图的更新。最后打印新状态。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.zhufengpeixun.cn/main/course/index.html" target="_blank" rel="noopener">珠峰前端架构师</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux学习总结</title>
    <url>/2019-10-21/Redux/Redux%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><p>“模块（组件）之间需要共享数据”，和“数据可能被任意修改导致不可预料的结果”之间的矛盾。</p><h2 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h2><p>提高数据修改的门槛</p><h2 id="Redux应用场景"><a href="#Redux应用场景" class="headerlink" title="Redux应用场景"></a>Redux应用场景</h2><ul>
<li><p>随着 JavaScript 单页应用开发日趋复杂,管理不断变化的 state 非常困难</p>
</li>
<li><p>Redux的出现就是为了解决state里的数据问题</p>
</li>
<li><p>在React中，数据在组件中是单向流动的</p>
</li>
<li><p>数据从一个方向父组件流向子组件(通过props)，由于这个特征，两个非父子关系的组件（或者称作兄弟组件）之间的通信就比较麻烦</p>
<p><img src="/images/redux-wrong.png" alt="Redux应用场景"></p>
</li>
</ul><a id="more"></a>


<h2 id="Redux设计思想"><a href="#Redux设计思想" class="headerlink" title="Redux设计思想"></a>Redux设计思想</h2><ul>
<li><p>单一数据源：整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中</p>
</li>
<li><p>State 是只读的：唯一改变 state 的方法就是派发（dispatch） action，action 是一个用于描述已发生事件的普通对象</p>
</li>
<li><p>使用纯函数来执行修改：为了描述 action 如何改变 state tree ，你需要编写 reducers</p>
<ul>
<li>Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state </li>
</ul>
</li>
<li><p>订阅事件：其它组件可以通过订阅（subscribe）store中的状态(state)来刷新自己的视图.  </p>
<p><img src="/images/redux-flow.png" alt="Redux工作流"></p>
</li>
</ul>
<h2 id="Redux概念解析"><a href="#Redux概念解析" class="headerlink" title="Redux概念解析"></a>Redux概念解析</h2><ul>
<li><p>Store</p>
<ul>
<li><p>就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个Store。</p>
</li>
<li><p>Redux 提供createStore这个函数，用来生成Store</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>State</p>
<ul>
<li>Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。当前时刻的 State，可以通过store.getState()拿到</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"><span class="keyword">const</span> state = store.getState();</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>Action</p>
<ul>
<li>是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。</li>
<li>我们应该尽量减少在 action 中传递的数据。</li>
<li>State的变化，会导致View的变化。但是，用户接触不到 State，只能接触到View 所以，State的变化必须是 View导致的。Action 就是 View 发出的通知，表示State 应该要发生变化了。 Action是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">'ADD_TODO'</span></span><br><span class="line">&#123;</span><br><span class="line">  type: ADD_TODO,</span><br><span class="line">  text: <span class="string">'Learn Redux'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Action Creator</p>
<ul>
<li>View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator</li>
<li>在 Redux 中的 action 创建函数只是简单的返回一个 action:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>store.dispatch</p>
<ul>
<li>View 发出 Action 的唯一方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  text: <span class="string">'Learn Redux'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Reducer</p>
<ul>
<li>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</li>
<li>Reducer 是一个纯函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。<ul>
<li>纯函数<ul>
<li>函数的返回结果只依赖于它的参数，相同的输入产生相同的输出</li>
<li>对外层作用域不会产生副作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> new_state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="相关源码分析"><a href="#相关源码分析" class="headerlink" title="相关源码分析"></a>相关源码分析</h2><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p>创建数据仓库，store。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//处理middleware 中间件</span></span><br><span class="line">    <span class="comment">//enhancer：applyMiddleware(...middleware)的执行结果</span></span><br><span class="line">    <span class="keyword">if</span> (enhancer) &#123;</span><br><span class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> state;</span><br><span class="line">    <span class="keyword">let</span> listeners = [];<span class="comment">//事件订阅</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅事件，用于状态变更，触发view渲染。返回一个取消订阅的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>)</span>&#123;</span><br><span class="line">        listeners.push(listener);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取消事件订阅</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            listeners = listeners.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> item !== listener;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">        state = reducer(state, action);<span class="comment">//获取新的状态</span></span><br><span class="line">        <span class="comment">//发布事件  触发view更新</span></span><br><span class="line">        listeners.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">listener</span>)</span>&#123;</span><br><span class="line">            listener();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">"@@TYEP/REDUX_INIT"</span> &#125;);<span class="comment">//初始化数据 state赋值为reducer中的默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        dispatch,</span><br><span class="line">        subscribe,</span><br><span class="line">        getState,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bindActionCreator"><a href="#bindActionCreator" class="headerlink" title="bindActionCreator"></a>bindActionCreator</h3><p>通过bindActionCreator将 <strong>store.dispatch*</strong> 与 <strong><em>Action Creator</em></strong>进行组合，降低两者的耦合，同时提高了 <strong><em>store.dispatch</em></strong> 代码的复用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//派发动作</span></span><br><span class="line">        dispatch(actionCreator(<span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个辅助方法，能够让我们以方法的形式来派发action</span></span><br><span class="line"><span class="comment">// 如果actionCreators是一个函数，返回一个派发动作的函数</span></span><br><span class="line"><span class="comment">// 如果actionCreators是一个对象，返回一个派发动作的对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//处理函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators ===<span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators !== <span class="string">'object'</span> || actionCreators === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">            <span class="string">`bindActionCreators expected an object or a function, instead received <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">            actionCreators === <span class="literal">null</span> ? <span class="string">'null'</span> : <span class="keyword">typeof</span> actionCreators</span></span></span><br><span class="line"><span class="string"><span class="subst">            &#125;</span>. `</span> +</span><br><span class="line">            <span class="string">`Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理对象</span></span><br><span class="line">    <span class="keyword">const</span> boundActionCreators = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> actionCreators) &#123;</span><br><span class="line">        <span class="keyword">const</span> actionCreator = actionCreators[key]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="comment">//绑定属性：为bindActionCreator返回的函数</span></span><br><span class="line">            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回绑定actionCreators后的对象</span></span><br><span class="line">    <span class="keyword">return</span> boundActionCreators</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>随着应用变得复杂，需要对 reducer 函数 进行拆分，拆分后的每一块独立负责管理 state 的一部分。</p>
<p>combineReducers 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore。</p>
<p>合并后的 reducer 可以调用各个子 reducer，并把它们的结果合并成一个 state 对象。state 对象的结构由传入的多个 reducer 的 key 决定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> hasChanged = <span class="literal">false</span>;<span class="comment">//标记state是否更新</span></span><br><span class="line">        <span class="keyword">const</span> nextState = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> reducers) &#123;</span><br><span class="line">            <span class="comment">//获取单个reducer 注意：每个reducer中的action type不要重名 否则会触发其他reducer计算新的state 出现非预期的状态更新</span></span><br><span class="line">            <span class="keyword">const</span> reducer = reducers[key];</span><br><span class="line">            <span class="keyword">const</span> previousStateForKey = state[key];<span class="comment">//获取旧状态</span></span><br><span class="line">            <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action);<span class="comment">//计算新状态 action命中会返回新的状态否则返回旧状态</span></span><br><span class="line">            <span class="comment">//赋值给nextState对象 合并成一个对象</span></span><br><span class="line">            nextState[key] = nextStateForKey;</span><br><span class="line">            <span class="comment">//判断state是否修改</span></span><br><span class="line">            hasChanged = hasChanged || previousStateForKey !== nextStateForKey</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果状态没有更新返回旧的状态state  否则返回新的状态</span></span><br><span class="line">        <span class="comment">//可以在组件shouldComponentUpdate生命周期 进行状态，属性的是否更新比较 避免不必要的渲染</span></span><br><span class="line">        <span class="keyword">return</span> hasChanged ? nextState : state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.zhufengpeixun.cn/main/course/index.html" target="_blank" rel="noopener">珠峰前端架构师</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全-SQL注入攻击</title>
    <url>/2019-10-19/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/Web%E5%AE%89%E5%85%A8-SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h2><p>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p><a id="more"></a>
<h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><ul>
<li>存储结构化数据</li>
<li>可高效操作大量数据</li>
<li>方便处理数据之间的关联关系</li>
<li>常见的关系型数据库：MySQL，Oracle，SQLServer，PostGreSQL</li>
</ul>
<h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><ul>
<li>结构化查询语言，一种描述性语言，面向语义化</li>
<li>SQL语言的作用：对存储在RDBMS（关系型数据库管理系统）中的数据进行增删改查等操作，有些非关系数据库也支持SQL</li>
</ul>
<h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><p>SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。</p>
<h2 id="SQL注入类型"><a href="#SQL注入类型" class="headerlink" title="SQL注入类型"></a>SQL注入类型</h2><p>根据相关技术原理，SQL注入可以分为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## SQL注入产生原因</span><br><span class="line"></span><br><span class="line">- 不当的类型处理；</span><br><span class="line">- 不安全的数据库配置；</span><br><span class="line">- 不合理的查询集处理；</span><br><span class="line">- 不当的错误处理；</span><br><span class="line">- 转义字符处理不合适；</span><br><span class="line">- 多个提交处理不当。</span><br><span class="line"></span><br><span class="line">## SQL注入示例</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">//查询语句</span><br><span class="line">SELECT * FROM table WHERE id=$&#123;id&#125;</span><br><span class="line">//注入数据</span><br><span class="line">1 or 1=1</span><br><span class="line">//注入后的查询语句</span><br><span class="line">SELECT * FROM table WHERE id=1 or 1=1</span><br><span class="line"></span><br><span class="line">//查询语句</span><br><span class="line">SELECT * FROM user WHERE username=`$&#123;username&#125;` AND password=`$&#123;password&#125;`</span><br><span class="line">//注入数据</span><br><span class="line">1&apos; or &apos;1&apos;=&apos;1</span><br><span class="line">//注入后的查询语句</span><br><span class="line">SELECT * FROM user WHERE username=`123` AND password=1&apos; or &apos;1&apos;=&apos;1&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="SQL注入危害"><a href="#SQL注入危害" class="headerlink" title="SQL注入危害"></a>SQL注入危害</h2><ul>
<li>猜解密码</li>
<li>获取数据</li>
<li>删库删表</li>
<li>拖库</li>
</ul>
<h2 id="SQL注入防御"><a href="#SQL注入防御" class="headerlink" title="SQL注入防御"></a>SQL注入防御</h2><ul>
<li>对数据进行转义，永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等</li>
<li>永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取</li>
<li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li>
<li>不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息</li>
<li>关闭错误输出：应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装，把异常信息存放在独立的表中</li>
<li>使用ORM（对象关系映射）</li>
</ul>
<h2 id="Node-防止SQL注入攻击"><a href="#Node-防止SQL注入攻击" class="headerlink" title="Node 防止SQL注入攻击"></a>Node 防止SQL注入攻击</h2><h3 id="转义查询值"><a href="#转义查询值" class="headerlink" title="转义查询值"></a>转义查询值</h3><p>使用<a href="https://github.com/mysqljs/mysql" target="_blank" rel="noopener">mysql</a>，转义查询值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(&#123;</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    user: <span class="string">'me'</span>,</span><br><span class="line">    password: <span class="string">'secret'</span>,</span><br><span class="line">    database: <span class="string">'my_db'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userId = <span class="string">'some user provided value'</span>;</span><br><span class="line"><span class="keyword">var</span> sql    = <span class="string">'SELECT * FROM users WHERE id = '</span> + connection.escape(userId); <span class="comment">//转义查询值</span></span><br><span class="line">connection.query(sql, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="使用参数化查询"><a href="#使用参数化查询" class="headerlink" title="使用参数化查询"></a>使用参数化查询</h3><p>使用<a href="https://github.com/sidorares/node-mysql2" target="_blank" rel="noopener">node-mysql2</a>进行参数化查询</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get the client</span></span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(&#123;</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    user: <span class="string">'me'</span>,</span><br><span class="line">    password: <span class="string">'secret'</span>,</span><br><span class="line">    database: <span class="string">'my_db'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userId = <span class="string">'some user provided value'</span>;</span><br><span class="line">connection.execute(<span class="string">'SELECT * FROM users WHERE id = ?'</span>,[userId], <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="使用ORM（对象关系映射）"><a href="#使用ORM（对象关系映射）" class="headerlink" title="使用ORM（对象关系映射）"></a>使用ORM（对象关系映射）</h3><p>使用<a href="https://github.com/demopark/sequelize-docs-Zh-CN/tree/master" target="_blank" rel="noopener">Sequelize</a></p>
<h2 id="参数化查询"><a href="#参数化查询" class="headerlink" title="参数化查询"></a>参数化查询</h2><p>参数化查询(Parameterized Query 或 Parameterized Statement)是指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数 (Parameter) 来给值，这个方法目前已被视为最有效可预防SQL注入攻击 (SQL Injection) 的攻击手法的防御方式</p>
<h3 id="参数化查询原理"><a href="#参数化查询原理" class="headerlink" title="参数化查询原理"></a>参数化查询原理</h3><p>在使用参数化查询的情况下，数据库服务器不会将参数的内容视为SQL指令的一部份来处理，而是在数据库完成 SQL 指令的编译后，才套用参数运行，因此就算参数中含有恶意的指令，由于已经编译完成，就不会被数据库所运行。 有部份的开发人员可能会认为使用参数化查询，会让程序更不好维护，或者在实现部份功能上会非常不便，然而，使用参数化查询造成的额外开发成本，通常都远低于因为SQL注入攻击漏洞被发现而遭受攻击，所造成的重大损失</p>
<h3 id="SQL-指令撰写方法"><a href="#SQL-指令撰写方法" class="headerlink" title="SQL 指令撰写方法"></a>SQL 指令撰写方法</h3><p>MySQL 的参数格式是以 “?” 字符加上参数名称而成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">UPDATE myTable SET c1 = ?c1, c2 = ?c2, c3 = ?c3 WHERE c4 = ?c4</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行sql查询</span></span><br><span class="line">query(<span class="string">`SELECT * FROM user WHERE id=?`</span>,[id])</span><br></pre></td></tr></table></figure>

<h2 id="NOSQL注入防御"><a href="#NOSQL注入防御" class="headerlink" title="NOSQL注入防御"></a>NOSQL注入防御</h2><ul>
<li>检测数据类型</li>
<li>类型转换</li>
<li>写完整条件</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>前端Cookie安全性</title>
    <url>/2019-10-19/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/%E5%89%8D%E7%AB%AFCookie%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。（可以叫做浏览器缓存）</p><h2 id="Cookie特性"><a href="#Cookie特性" class="headerlink" title="Cookie特性"></a>Cookie特性</h2><ul>
<li>前端（浏览器）数据存储</li>
<li>后端通过http响应头进行设置</li>
<li>前端请求时，会自动添加cookie，通过http请求头传给后端</li>
<li>前端可读写</li>
<li>遵守同源策略</li>
</ul><a id="more"></a>

<h2 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h2><ul>
<li>domain：域，表示当前cookie属于哪个域或子域下面，可以在哪些域名下使用</li>
<li>Path：表示cookie的所属路径，标识指定了主机下的哪些路径可以接受Cookie，具体可以作用到网站的哪一级，即url层级</li>
<li>Expire time/Max-age：表示了cookie的有效期。expire的值，是一个时间，过了这个时间，该cookie就失效了。或者是用max-age指定当前cookie是在多长时间之后而失效。如果服务器返回的一个cookie，没有指定其expire time，那么表明此cookie有效期只是当前的session，即是session cookie，当前session会话结束后，就过期了。对应的，当关闭（浏览器中）该页面的时候，此cookie就应该被浏览器所删除了。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来，就好像浏览器从来没有关闭一样</li>
<li>secure：表示该cookie只能用https传输。一般用于包含认证信息的cookie，要求传输此cookie的时候，必须用https传输</li>
<li>httponly：表示此cookie必须用于http或https传输。这意味着，浏览器脚本，比如javascript中，是不允许访问操作此cookie的</li>
<li>SameSite：允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）</li>
</ul>
<h2 id="Cookie作用"><a href="#Cookie作用" class="headerlink" title="Cookie作用"></a>Cookie作用</h2><ul>
<li>存储个性化设置</li>
<li>存储未登录时用户唯一标识</li>
<li>存储已登录用户凭证</li>
<li>存储其他业务数据（缓存）</li>
</ul>
<h2 id="Cookie的缺陷"><a href="#Cookie的缺陷" class="headerlink" title="Cookie的缺陷"></a>Cookie的缺陷</h2><ul>
<li>cookie会被附加在每个HTTP请求中，所以无形中增加了流量。</li>
<li>由于在HTTP请求中的cookie是明文传递的，所以安全性成问题。（除非用HTTPS)</li>
<li>cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的</li>
</ul>
<h2 id="Cookie-登录用户凭证"><a href="#Cookie-登录用户凭证" class="headerlink" title="Cookie 登录用户凭证"></a>Cookie 登录用户凭证</h2><ul>
<li>前端提交用户名和密码</li>
<li>后端验证用户名和密码</li>
<li>后端生成用户凭证，设置cookie，通过http响应头传输给前端</li>
<li>后续，继续访问时，http请求头会携带cookie，后端通过用户凭证cookie验证用户信息，处理请求</li>
</ul>
<h2 id="Cookie-生成用户凭证"><a href="#Cookie-生成用户凭证" class="headerlink" title="Cookie 生成用户凭证"></a>Cookie 生成用户凭证</h2><ul>
<li>用户ID：很容易被篡改</li>
<li>用户ID+签名：后台根据用户ID生成签名，将用户ID+签名传给前端，后台处理请求时通过验证用户ID和签名，处理请求。同时通过判断用户ID和签名的一致性，验证用户ID是否被篡改</li>
<li>Session：客户端第一次正常访问服务器，服务器生成一个sessionid来标识用户并保存用户信息（服务器有一个专门的地方来保存所有用户的sessionId），在response headers中作为cookie的一个值返回，客户端收到后把cookie保存在本地，下次再发请求时会在request headers中带上这个sessionId，服务器通过查找这个sessionId就知道用户状态了，并更新sessionId的最后访问时间。sessionId也可以设置失效时间。总言之cookie是保存在客户端，session是存在服务器，session依赖于cookie</li>
</ul>
<h2 id="Cookie和XSS的关系"><a href="#Cookie和XSS的关系" class="headerlink" title="Cookie和XSS的关系"></a>Cookie和XSS的关系</h2><ul>
<li>XSS可能偷取Cookie</li>
<li>设置http-only防止Cookie被盗</li>
</ul>
<h2 id="Cookie和CSRF的关系"><a href="#Cookie和CSRF的关系" class="headerlink" title="Cookie和CSRF的关系"></a>Cookie和CSRF的关系</h2><ul>
<li>CSRF利用了用户的Cookie</li>
<li>攻击站点无法读写Cookie</li>
<li>最好能阻止第三方使用Cookie（SameSite）</li>
</ul>
<h2 id="Cookie的安全策略"><a href="#Cookie的安全策略" class="headerlink" title="Cookie的安全策略"></a>Cookie的安全策略</h2><ul>
<li>签名防止篡改（用户ID+签名）</li>
<li>私有变换（加密）</li>
<li>http-only（防止XSS攻击）</li>
<li>secure：防止HTTP数据传输过程中的窃听，盗取Cookie</li>
<li>SameSite（防止CSRF攻击）</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全-跨站请求伪造攻击CSRF</title>
    <url>/2019-10-19/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/Web%E5%AE%89%E5%85%A8-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BBCSRF/</url>
    <content><![CDATA[<h2 id="跨站请求伪造攻击CSRF"><a href="#跨站请求伪造攻击CSRF" class="headerlink" title="跨站请求伪造攻击CSRF"></a>跨站请求伪造攻击CSRF</h2><p>CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。</p><a id="more"></a>
<h2 id="跨站"><a href="#跨站" class="headerlink" title="跨站"></a>跨站</h2><p>在其他网站，在用户不知情的情况下，对目标网站发出了请求，产生了影响。</p>
<h2 id="CSRF攻击攻击原理及过程"><a href="#CSRF攻击攻击原理及过程" class="headerlink" title="CSRF攻击攻击原理及过程"></a>CSRF攻击攻击原理及过程</h2><ul>
<li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</li>
<li>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li>
<li>用户在同一浏览器中，打开一个TAB页访问了攻击网站B；</li>
<li>攻击网站就能伪装成用户C向A网站发起请求（此时携带了用户的身份信息Cookie）</li>
</ul>
<h2 id="CSRF攻击特征"><a href="#CSRF攻击特征" class="headerlink" title="CSRF攻击特征"></a>CSRF攻击特征</h2><ul>
<li>攻击网站B向A网站发起请求</li>
<li>携带A网站的Cookie</li>
<li>不访问A网站前端</li>
<li>HTTP请求头的refer指向攻击网站B</li>
</ul>
<h2 id="CSRF攻击危害"><a href="#CSRF攻击危害" class="headerlink" title="CSRF攻击危害"></a>CSRF攻击危害</h2><ul>
<li>利用用户登录态</li>
<li>用户不知情</li>
<li>完成业务请求</li>
<li>盗取用户资金（转账，消费）</li>
<li>冒充用户发帖背锅</li>
<li>损坏网站声誉</li>
<li>等等…</li>
</ul>
<h2 id="CSRF攻击防御"><a href="#CSRF攻击防御" class="headerlink" title="CSRF攻击防御"></a>CSRF攻击防御</h2><ul>
<li>通过SameSite Cookie，禁止第三方网站携带Cookie</li>
<li>不访问A网站前端，在A网站前端中加入验证信息，第三方攻击网站无法获取验证信息，后台通过判断验证信息处理请求<ul>
<li>验证码,（图形验证码）缺点是用户体验差<ul>
<li><a href="https://www.npmjs.com/package/svg-captcha" target="_blank" rel="noopener">svg-captcha</a>：Node 图形验证码</li>
</ul>
</li>
<li>Token：Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</li>
</ul>
</li>
<li>验证HTTP请求头的refer 请求来源，如果不是合法的域名直接拒绝请求</li>
<li>防抓包：使用HTTPS(HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。)替换HTTP,对传输的数据进行加密,这样,当请求的信息被抓包工具抓包后,也无法修改提交的数据。</li>
<li>node可以使用 <a href="https://github.com/expressjs/csurf" target="_blank" rel="noopener">CSRF</a> 中间件来防御csrf攻击。</li>
</ul>
<h2 id="SameSite-Cookie"><a href="#SameSite-Cookie" class="headerlink" title="SameSite Cookie"></a>SameSite Cookie</h2><p>服务器端设置Cookie的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#SameSite_cookies" target="_blank" rel="noopener">SameSite</a>，浏览器端在跨站请求时Cookie不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。目前主流浏览器基本上都支持。<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Browser_compatibility" target="_blank" rel="noopener">支持情况</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: key=value; SameSite=Strict</span><br></pre></td></tr></table></figure>

<h2 id="SameSite属性值"><a href="#SameSite属性值" class="headerlink" title="SameSite属性值"></a>SameSite属性值</h2><ul>
<li>Strict：跨域发起的任何请求都不会携带cookie</li>
<li>Lax： Lax相对于Strict模式来说，宽松了一些</li>
</ul>
<table>
<thead>
<tr>
<th>请求类型</th>
<th>例子</th>
<th>非 SameSite</th>
<th>SameSite = Lax</th>
<th>SameSite = Strict</th>
</tr>
</thead>
<tbody><tr>
<td>link</td>
<td><code>&lt;a href=&quot;…&quot;&gt;</code></td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>prerender</td>
<td><code>&lt;link rel=&quot;prerender&quot; href=&quot;…&quot;&gt;</code></td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>form get</td>
<td><code>&lt;form method=&quot;get&quot; action=&quot;…&quot;&gt;</code></td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>form post</td>
<td><code>&lt;form method=&quot;post&quot; action=&quot;…&quot;&gt;</code></td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>iframe</td>
<td><code>&lt;iframe src=&quot;…&quot;&gt;</code></td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>ajax</td>
<td><code>$.get(&#39;…&#39;)</code></td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>image</td>
<td><code>&lt;img src=&quot;…&quot;&gt;</code></td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/104.html" target="_blank" rel="noopener">Web前后端漏洞分析与防御</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全-跨站脚本攻击XSS</title>
    <url>/2019-10-19/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/Web%E5%AE%89%E5%85%A8-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBXSS/</url>
    <content><![CDATA[<h2 id="跨站脚本攻击XSS"><a href="#跨站脚本攻击XSS" class="headerlink" title="跨站脚本攻击XSS"></a>跨站脚本攻击XSS</h2><p>跨站脚本攻击（XSS），是目前最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p><h2 id="跨站"><a href="#跨站" class="headerlink" title="跨站"></a>跨站</h2><p>简单来说，如果有一个网站，希望网站中所有运行的逻辑都来自本站。如果运行了别的网站的脚本，就产生了跨站脚本攻击。</p><a id="more"></a>

<h2 id="XSS攻击原理"><a href="#XSS攻击原理" class="headerlink" title="XSS攻击原理"></a>XSS攻击原理</h2><p>攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie信息、破坏页面结构、重定向到其它网站等。</p>
<h2 id="XSS能做什么"><a href="#XSS能做什么" class="headerlink" title="XSS能做什么"></a>XSS能做什么</h2><ul>
<li>获取页面数据</li>
<li>获取Cookie信息</li>
<li>截取前端逻辑</li>
<li>发送请求</li>
<li>偷取网站任意数据</li>
<li>偷取用户资料</li>
<li>偷取用户密码和登录态</li>
<li>欺骗用户</li>
<li>等等…</li>
</ul>
<h2 id="XSS攻击类型"><a href="#XSS攻击类型" class="headerlink" title="XSS攻击类型"></a>XSS攻击类型</h2><ul>
<li>反射型：攻击代码直接由url参数注入，页面直接执行了注入的代码<ul>
<li>通过将攻击的url转为短网址，可以屏蔽脚本信息，攻击更加隐蔽</li>
</ul>
</li>
<li>存储型：XSS代码会被保存到网站的数据中，如数据库，在其他用户访问到这条记录时，这条攻击代码会被读取出来，显示在页面上。（危害性更大）</li>
</ul>
<h2 id="XSS攻击注入点"><a href="#XSS攻击注入点" class="headerlink" title="XSS攻击注入点"></a>XSS攻击注入点</h2><ul>
<li>HTML节点内容：节点内容是动态生成，包含用户输入的信息</li>
<li>HTML属性：节点属性如果由用户输入信息组成</li>
<li>Javascript代码：由用户输入信息组成</li>
<li>富文本：由用户输入信息组成</li>
</ul>
<p>基本上页面内容，由用户输入信息动态生成，都可能存在XSS攻击。</p>
<h3 id="HTML节点内容"><a href="#HTML节点内容" class="headerlink" title="HTML节点内容"></a>HTML节点内容</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    #&#123;content&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//XSS攻击</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">       alert(1)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"#&#123;image&#125;"</span>/&gt;</span></span><br><span class="line">//提前关闭src属性 注入攻击代码：1" onerror="alert(1)</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1"</span> <span class="attr">onerror</span>=<span class="string">"alert(1)"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Javascript代码"><a href="#Javascript代码" class="headerlink" title="Javascript代码"></a>Javascript代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">"#&#123;data&#125;"</span>;</span><br><span class="line">    <span class="comment">//提前关闭data变量 注入攻击代码：hello"; alert(1);"</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">"hello"</span>; alert(<span class="number">1</span>);<span class="string">""</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h3><ul>
<li>富文本得保留HTML</li>
<li>HTML有XSS攻击风险</li>
</ul>
<h2 id="浏览器自带防御"><a href="#浏览器自带防御" class="headerlink" title="浏览器自带防御"></a>浏览器自带防御</h2><ul>
<li>X-XSS-Protection：通过设置响应头处理XSS攻击</li>
<li>只能处理反射型攻击类型， url参数出现在HTML节点内容或HTML属性中</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener">Content-Security-Policy</a>：允许站点管理者控制用户代理能够为指定的页面加载哪些资源。这将帮助防止跨站脚本攻击（Cross-Site Script）</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X-XSS-Protection: 0 // 表示关闭浏览器的XSS防护机制</span><br><span class="line">X-XSS-Protection: 1 // 启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）</span><br><span class="line">X-XSS-Protection: 1; mode=block // 启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。</span><br><span class="line">X-XSS-Protection: 1; report=&lt;reporting-uri&gt; // 启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认会拦截XSS攻击</span></span><br><span class="line">The XSS Auditor refused to execute a script <span class="keyword">in</span> <span class="string">'http://localhost/?from=%3Cscript%3Ealert(1)%3C/script%3E'</span> because its source code was found within the request. The auditor was enabled <span class="keyword">as</span> the server did not send an <span class="string">'X-XSS-Protection'</span> header.</span><br></pre></td></tr></table></figure>

<h2 id="HTML节点内容防御方法"><a href="#HTML节点内容防御方法" class="headerlink" title="HTML节点内容防御方法"></a>HTML节点内容防御方法</h2><p>将 &lt; &gt; 尖括号进行转义，替换成<a href="https://www.w3school.com.cn/html/html_entities.asp" target="_blank" rel="noopener">html字符实体</a>。</p>
<ul>
<li>将&lt; 转义为 &amp;lt;</li>
<li>将 &gt; 转义为&amp;gt;</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    #&#123;content&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//XSS攻击</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">       alert(1)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeHtml = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>);<span class="comment">//处理 &lt;</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);<span class="comment">//处理 &gt;</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTML属性防御方法"><a href="#HTML属性防御方法" class="headerlink" title="HTML属性防御方法"></a>HTML属性防御方法</h2><p>由于引号，将属性提前关闭了，所以需要进行转义。</p>
<ul>
<li>将” 转义为&amp;quto;。</li>
<li>将’ 转义为&amp;#39;。</li>
<li>将  转义为&amp;nbsp;：属性没有引号情况下，转义空格。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"#&#123;image&#125;"</span>/&gt;</span></span><br><span class="line">//提前关闭src属性 注入攻击代码：1" onerror="alert(1)</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1"</span> <span class="attr">onerror</span>=<span class="string">"alert(1)"</span>/&gt;</span></span><br><span class="line">//属性没有引号</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeHtmlProperty = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>);<span class="comment">//处理 "</span></span><br><span class="line">    str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>);<span class="comment">//处理 '</span></span><br><span class="line">    str = str.replace(<span class="regexp">/ /g</span>, <span class="string">'&amp;nbsp;'</span>);<span class="comment">//处理空格</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTML节点内容，HTML属性防御方法"><a href="#HTML节点内容，HTML属性防御方法" class="headerlink" title="HTML节点内容，HTML属性防御方法"></a>HTML节点内容，HTML属性防御方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeHtmlAndProperty = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>);<span class="comment">//处理 &amp; 需要放在最前面 一般不需要处理</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>);<span class="comment">//处理 &lt;</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);<span class="comment">//处理 &gt;</span></span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>);<span class="comment">//处理 "</span></span><br><span class="line">    str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>);<span class="comment">//处理 '</span></span><br><span class="line">    <span class="comment">//处理空格 由于html内容中，多个连续的空格，在渲染时只会产生一个空格，将空格全部转为&amp;nbsp;（html实体）可能显示存在问题，一般情况下，空格不进行转义。基于这种情况，必须确保属性带上引号，否则不能处理属性没有引号情况下的XSS攻击</span></span><br><span class="line">    <span class="comment">// str = str.replace(/ /g, '&amp;nbsp;');</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Javascript代码防御方法"><a href="#Javascript代码防御方法" class="headerlink" title="Javascript代码防御方法"></a>Javascript代码防御方法</h2><ul>
<li>将 “ 转义为 \“</li>
<li>转换成josn（推荐）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">"#&#123;data&#125;"</span>;</span><br><span class="line">    <span class="comment">//提前关闭data变量 注入攻击代码：hello"; alert(1);"</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">"hello"</span>; alert(<span class="number">1</span>);<span class="string">""</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不完善的方法</span></span><br><span class="line"><span class="keyword">var</span> escapeForJs = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    str = str.replace(<span class="regexp">/\\/g</span>, <span class="string">'\\\\'</span>);<span class="comment">//将\ 转义为\\</span></span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>);<span class="comment">//将" 转义为\"</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成josn</span></span><br><span class="line"><span class="keyword">var</span> escapeForJsJson = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="富文本防御方法"><a href="#富文本防御方法" class="headerlink" title="富文本防御方法"></a>富文本防御方法</h2><ul>
<li>使用黑名单过滤，过滤不符合要求的标签和属性。实现相对简单，只需要按照正则表达式过滤。但是html是非常庞大，繁杂的，有太多的标签和属性，容易忽略，产生漏洞</li>
<li>使用白名单，保留部分标签和属性。过滤比较彻底，只允许指定的标签，属性存在。但是实现比较麻烦，需要将html完全解析成树状结构，针对这个dom树，遍历它的元素，保留白名单中的标签和属性，其他的过滤掉。过滤完之后，再组装成html。</li>
</ul>
<h3 id="使用黑名单过滤"><a href="#使用黑名单过滤" class="headerlink" title="使用黑名单过滤"></a>使用黑名单过滤</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//需要过滤javascript</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(1)"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//需要过滤script</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    alert(2);sssss;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过黑名单过滤</span></span><br><span class="line"><span class="keyword">var</span> xssFilter = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!html) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    html = html.replace(<span class="regexp">/&lt;\s*\/?script\s*&gt;/g</span>, <span class="string">''</span>);<span class="comment">//将script转义为空</span></span><br><span class="line">    html = html.replace(<span class="regexp">/javascript[^'"]*/g</span>, <span class="string">''</span>);<span class="comment">//将javascript转义为空</span></span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用白名单过滤"><a href="#使用白名单过滤" class="headerlink" title="使用白名单过滤"></a>使用白名单过滤</h3><ul>
<li>使用<a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">cheerio</a>处理XSS攻击<ul>
<li>解析html，对标签，属性进行过滤，最终返回html，需要自己维护，完善白名单列表</li>
</ul>
</li>
<li>使用<a href="https://github.com/leizongmin/js-xss" target="_blank" rel="noopener">js-xss</a>处理XSS攻击</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用白名单处理富文本</span></span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>)</span><br><span class="line"><span class="keyword">var</span> xssFilter3 = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!html) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">	<span class="keyword">const</span> $ = cheerio.load(html)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义白名单 需要进行维护，完善该名单</span></span><br><span class="line">	<span class="keyword">const</span> whiteList = &#123;</span><br><span class="line">		<span class="string">'img'</span>: [<span class="string">'src'</span>],<span class="comment">//标签名：属性列表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤标签属性</span></span><br><span class="line">	$(<span class="string">'*'</span>).each(<span class="function">(<span class="params">index, elem</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">//标签不存在白名单中 直接移除</span></span><br><span class="line">		<span class="keyword">if</span> (!whiteList[elem.name]) &#123;</span><br><span class="line">			$(elem).remove();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// //标签在白名单中 处理属性</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> elem.attribs)&#123;</span><br><span class="line">			<span class="keyword">if</span>(whiteList[elem.name].indexOf(attr)===<span class="number">-1</span>)&#123;</span><br><span class="line">				<span class="comment">//移除属性</span></span><br><span class="line">				$(elem).attr(attr,<span class="literal">null</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//返回过滤后的标签属性</span></span><br><span class="line">	<span class="keyword">return</span> $.html()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="防御-XSS-攻击"><a href="#防御-XSS-攻击" class="headerlink" title="防御 XSS 攻击"></a>防御 XSS 攻击</h2><ul>
<li>HttpOnly 防止劫取 Cookie</li>
<li>用户的输入检查</li>
<li>服务端的输出检查</li>
<li>使用<a href="https://github.com/leizongmin/js-xss" target="_blank" rel="noopener">js-xss</a>处理XSS攻击</li>
</ul>
<h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>HTTP 响应头<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener">Content-Security-Policy（内容安全策略）</a>允许站点管理者控制用户代理能够为指定的页面加载哪些资源，可以指定哪些内容可以执行。这将帮助防止跨站脚本攻击（Cross-Site Script）（XSS）。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">内容安全策略CSP)</a> 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p>
<h3 id="启用CSP"><a href="#启用CSP" class="headerlink" title="启用CSP"></a>启用CSP</h3><ul>
<li>服务器响应头添加 Content-Security-Policy 来指定规则</li>
<li>HTML 中 &lt;meta&gt; 元素也可以被用来配置该策略</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self'; img-src https://*; child-src 'none';"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="制定策略"><a href="#制定策略" class="headerlink" title="制定策略"></a>制定策略</h3><p>你可以使用  Content-Security-Policy HTTP头部 来指定你的策略，像这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// policy参数是一个包含了各种描述你的CSP策略指令的字符串。</span><br><span class="line">Content-Security-Policy: policy</span><br></pre></td></tr></table></figure>

<h3 id="更多策略指令"><a href="#更多策略指令" class="headerlink" title="更多策略指令"></a>更多策略指令</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener">更多策略指令</a></p>
<h3 id="描述策略"><a href="#描述策略" class="headerlink" title="描述策略"></a>描述策略</h3><p>一个策略由一系列策略指令所组成，每个策略指令都描述了一个针对某个特定类型资源以及生效范围的策略。你的策略应当包含一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src" target="_blank" rel="noopener">default-src</a>策略指令，在其他资源类型没有符合自己的策略时应用该策略。一个策略可以包含 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src" target="_blank" rel="noopener">default-src</a>  或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/script-src" target="_blank" rel="noopener">script-src</a> 指令来防止内联脚本运行, 并杜绝eval()的使用。 一个策略也可包含一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src" target="_blank" rel="noopener">default-src</a> 或  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/style-src" target="_blank" rel="noopener">style-src</a> 指令去限制来自一个 &lt;style&gt; 元素或者style属性的內联样式。</p>
<h3 id="常见用例"><a href="#常见用例" class="headerlink" title="常见用例"></a>常见用例</h3><ul>
<li><p>示例 1：一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 2：一个网站管理者允许内容来自信任的域名及其子域名 (域名不必与CSP设置所在的域名相同)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos; *.trusted.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 3：</p>
<ul>
<li><p>一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码.</p>
</li>
<li><p>在这里，各种内容默认仅允许从文档所在的源获取, 但存在如下例外:</p>
<ul>
<li>图片可以从任何地方加载(注意 “*” 通配符)。</li>
<li>多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)。</li>
<li>可运行脚本仅允许来自于userscripts.example.com。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>示例 4：</p>
<ul>
<li>一个线上银行网站的管理者想要确保网站的所有内容都要通过SSL方式获取，以避免攻击者窃听用户发出的请求。</li>
<li>该服务器仅允许通过HTTPS方式并仅从onlinebanking.jumbobank.com域名来访问文档。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src https://onlinebanking.jumbobank.com</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>示例 5：</p>
<ul>
<li>一个在线邮箱的管理者想要允许在邮件里包含HTML，同样图片允许从任何地方加载，但不允许JavaScript或者其他潜在的危险内容(从任意位置加载)。</li>
<li>注意这个示例并未指定script-src。在此CSP示例中，站点通过 default-src 指令的对其进行配置，这也同样意味着脚本文件仅允许从原始服务器获取。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos; *.mailsite.com; img-src *</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="更多案例说明"><a href="#更多案例说明" class="headerlink" title="更多案例说明"></a>更多案例说明</h3><p><a href="https://infosec.mozilla.org/guidelines/web_security#Examples_5" target="_blank" rel="noopener">更多案例说明</a></p>
<h3 id="对策略进行测试"><a href="#对策略进行测试" class="headerlink" title="对策略进行测试"></a>对策略进行测试</h3><p>为降低部署成本，CSP可以部署为报告(report-only)模式。在此模式下，CSP策略不是强制性的，但是任何违规行为将会报告给一个指定的URI地址。此外，一个报告模式的头部可以用来测试一个修订后的未来将应用的策略而不用实际部署它。</p>
<p>你可以用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only" target="_blank" rel="noopener">Content-Security-Policy-Report-Only</a> HTTP 头部来指定你的策略，像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy-Report-Only: policy</span><br></pre></td></tr></table></figure>

<p>如果Content-Security-Policy-Report-Only 头部和 Content-Security-Policy 同时出现在一个响应中，两个策略均有效。在Content-Security-Policy 头部中指定的策略有强制性 ，而Content-Security-Policy-Report-Only中的策略仅产生报告而不具有强制性。</p>
<p>支持CSP的浏览器将始终对于每个企图违反你所建立的策略都发送违规报告，如果策略里包含一个有效的report-uri 指令。</p>
<h3 id="启用违例报告"><a href="#启用违例报告" class="headerlink" title="启用违例报告"></a>启用违例报告</h3><p>默认情况下，违规报告并不会发送。为启用发送违规报告，你需要指定 report-uri 策略指令，并提供至少一个URI地址去递交报告：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos;; report-uri http://reportcollector.example.com/collector.cgi</span><br></pre></td></tr></table></figure>

<p>然后你需要设置你的服务器能够接收报告，使其能够以你认为恰当的方式存储并处理这些报告。</p>
<h3 id="违例报告的语法"><a href="#违例报告的语法" class="headerlink" title="违例报告的语法"></a>违例报告的语法</h3><p>作为报告的JSON对象报告包含了以下数据：</p>
<ul>
<li>document-uri：发生违规的文档的URI。</li>
<li>referrer：违规发生处的文档引用（地址）。</li>
<li>blocked-uri：被CSP阻止的资源URI。如果被阻止的URI来自不同的源而非文档URI，那么被阻止的资源URI会被删减，仅保留协议，主机和端口号。</li>
<li>violated-directive：违反的策略名称。</li>
<li>original-policy：在 Content-Security-Policy HTTP 头部中指明的原始策略。</li>
</ul>
<h3 id="违例报告样本"><a href="#违例报告样本" class="headerlink" title="违例报告样本"></a>违例报告样本</h3><p>我们假设页面位于 <strong><a href="http://example.com/signup.html" target="_blank" rel="noopener">http://example.com/signup.html</a></strong>。它使用如下策略，该策略禁止任何资源的加载，除了来自cdn.example.com的样式表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;none&apos;; style-src cdn.example.com; report-uri /_/csp-reports</span><br></pre></td></tr></table></figure>

<p>signup.html 的HTML像这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sign Up<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ... Content ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你能看出其中错误吗？样式表仅允许加载自cdn.example.com，然而该页面企图从自己的源 <strong>(<a href="http://example.com" target="_blank" rel="noopener">http://example.com</a>)</strong> 加载。当该文档被访问时，一个兼容CSP的浏览器将以POST请求的形式发送违规报告到 <strong><a href="http://example.com/_/csp-reports" target="_blank" rel="noopener">http://example.com/_/csp-reports</a></strong>，内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"csp-report"</span>: &#123;</span><br><span class="line">    <span class="attr">"document-uri"</span>: <span class="string">"http://example.com/signup.html"</span>,</span><br><span class="line">    <span class="attr">"referrer"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"blocked-uri"</span>: <span class="string">"http://example.com/css/style.css"</span>,</span><br><span class="line">    <span class="attr">"violated-directive"</span>: <span class="string">"style-src cdn.example.com"</span>,</span><br><span class="line">    <span class="attr">"original-policy"</span>: <span class="string">"default-src 'none'; style-src cdn.example.com; report-uri /_/csp-reports"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，该报告在blocked-uri字段中包含了违规资源的完整路径 ，但情况并非总是如此。比如，当signup.html试图从   <strong><a href="http://anothercdn.example.com/stylesheet.css" target="_blank" rel="noopener">http://anothercdn.example.com/stylesheet.css</a></strong> 加载CSS时，浏览器将不会包含完整路径，而只会保留源路径 <strong>(<a href="http://anothercdn.example.com" target="_blank" rel="noopener">http://anothercdn.example.com</a>)</strong>。CSP技术规范对此古怪行为<a href="https://www.w3.org/TR/CSP/#violation-reports" target="_blank" rel="noopener">给出了解释</a>。大体上说，这样是为了防止泄露跨域资源的敏感信息。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">内容安全策略</a></li>
<li><a href="https://coding.imooc.com/class/104.html" target="_blank" rel="noopener">Web前后端漏洞分析与防御</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener">Content-Security-Policy</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化-重绘与回流</title>
    <url>/2019-10-18/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/</url>
    <content><![CDATA[<h2 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><p>当 <strong><em>Render Tree</em></strong> 当中有元素的大小、布局、结构等发生改变时，就会触发回流，每个页面在首次加载的时候都需要进行至少一次回流；</p><p>当 <strong><em>Render Tree</em></strong> 有元素属性需要更新，这些属性只是影响元素的外观、风格，那么则会触发重绘。</p><p>重绘不一定导致回流，回流一定会导致重绘。</p><p>回流比重绘的代价要更高。</p><a id="more"></a>



<h2 id="触发重绘"><a href="#触发重绘" class="headerlink" title="触发重绘"></a>触发重绘</h2><ul>
<li>color、background 相关属性(如：background-color、background-image 等)</li>
<li>outline 相关属性( outline-color、outline-width )、text-decoration</li>
<li>border-radius、visibility、box-shadow</li>
</ul>
<h2 id="触发回流"><a href="#触发回流" class="headerlink" title="触发回流"></a>触发回流</h2><h3 id="触发页面重布局"><a href="#触发页面重布局" class="headerlink" title="触发页面重布局"></a>触发页面重布局</h3><ul>
<li>盒子模型相关属性会触发重布局：width、height、padding、margin、display、border-width、border、min-height </li>
<li>定位属性及浮动会触发重布局：top、bottom、left、right、position、float、clear</li>
<li>改变节点内部文字结构也会触发重布局：text-align、font-weight、font-family、line-height、vertical-align、white-space、font-size、overflow、overflow-y</li>
</ul>
<h3 id="触发回流的操作"><a href="#触发回流的操作" class="headerlink" title="触发回流的操作"></a>触发回流的操作</h3><ul>
<li>页面初次渲染</li>
<li>元素大小发生变化</li>
<li>元素的位置发生变化</li>
<li>浏览器窗口大小变化</li>
<li>添加或者删除 DOM 元素</li>
<li>激活 CSS 伪类</li>
<li>改变字体</li>
<li>获取即时计算的属性：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle、scrollIntoView()、scrollIntoViewIfNeeded()getBoundingClientRect()、scrollTo()</li>
</ul>
<h2 id="Flush-队列"><a href="#Flush-队列" class="headerlink" title="Flush 队列"></a>Flush 队列</h2><p>现代浏览器会对频繁的回流或重绘操作进行优化：</p>
<p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p>
<p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p>
<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>width、height</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
</ul>
<p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p>
<p>基本上都是获取即时计算的属性。</p>
<h2 id="减少重绘与回流"><a href="#减少重绘与回流" class="headerlink" title="减少重绘与回流"></a>减少重绘与回流</h2><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul>
<li>避免使用table布局。</li>
<li>尽可能在DOM树的最末端改变class。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到position属性为absolute或fixed的元素上。</li>
<li>避免使用CSS表达式（例如：calc()）。</li>
</ul>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul>
<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li>
<li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li>
<li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<h2 id="扩展部分"><a href="#扩展部分" class="headerlink" title="扩展部分"></a>扩展部分</h2><p>更加完整的渲染流程</p>
<p><img src="/images/render4.jpg" alt="更加完整的渲染流程"></p>
<p>上面提到把 position 设置为absolute 或者 fixed，其实就是把 Render Tree 上面的这个元素提升到了 Render Layer，提升到 Render Layer 之后，这个时候就不会影响其他元素也进行回流操作，而只会自己进行回流操作，那么这就是背后真正的原因。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tips:动画除了可以使用 position 设置为 absolute 或 fixed 优化之外，还可以使用启用硬件加速( GPU加速 )来进行优化，比如说一些移动元素的操作我们可以使用 translate3d() 方法来完成，使用这个方法之后，我们就触发了硬件加速，由于硬件加速使用的是 GPU 绘制，所以速度更快，而且不会引起回流和重绘，性能也可以得到较大的提升。</span><br></pre></td></tr></table></figure>

<h2 id="Chrome创建-Render-Layer-图层的条件"><a href="#Chrome创建-Render-Layer-图层的条件" class="headerlink" title="Chrome创建 Render Layer 图层的条件"></a>Chrome创建 Render Layer 图层的条件</h2><ul>
<li>3D和透视变换CSS属性(perspective transform)</li>
<li>使用加速视频解码的 video 标签</li>
<li>3D Webgl的上下文或加速2D上下文的 canvas 节点</li>
<li>混合插件 (如Flash)</li>
<li>css3硬件加速（GPU加速）transform，opacity，filters，Will-change</li>
</ul>
<h3 id="常用方法生成独立图层："><a href="#常用方法生成独立图层：" class="headerlink" title="常用方法生成独立图层："></a>常用方法生成独立图层：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform: translateZ(0);</span><br><span class="line"></span><br><span class="line">will-change: transform;</span><br></pre></td></tr></table></figure>

<p>将频发触发重绘与回流的 Dom 元素，独立到一个独立的图层。但是 Composite Layers 合并图层也会消耗性能，过多的图层可能导致性能更差。</p>
<h2 id="如何查看重绘与回流"><a href="#如何查看重绘与回流" class="headerlink" title="如何查看重绘与回流"></a>如何查看重绘与回流</h2><ul>
<li><p>1.按F12进入开发者工具，打开performance面板。</p>
</li>
<li><p>2.点击最左侧的黑色圆就可以开始一个新的监测记录。</p>
</li>
</ul>
<h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>以天猫手机端为例，获取顶部的滚动栏渲染信息。</p>
<p><img src="/images/render5.png" alt="渲染信息"></p>
<p>通过Main图表，Summary面板可以查看重绘与回流相关信息。</p>
<p><img src="/images/render6.png" alt="重绘与回流信息"></p>
<h2 id="如何查看Render-Layer"><a href="#如何查看Render-Layer" class="headerlink" title="如何查看Render Layer"></a>如何查看Render Layer</h2><p>如下图所示：</p>
<p><img src="/images/render7.png" alt="Render Layer"></p>
<p><img src="/images/render8.png" alt="Render Layer2"></p>
<p>Layers 面板可以查看详细的 Render Layer 信息。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/" target="_blank" rel="noopener">回流与重绘：CSS性能让JavaScript变慢？</a></li>
<li><a href="https://juejin.im/post/5a9923e9518825558251c96a" target="_blank" rel="noopener">浏览器的回流与重绘</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化-DOM性能优化</title>
    <url>/2019-10-18/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-DOM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端需要频繁操作 DOM，为了提高网站性能，需要针对 DOM 操作进行相应优化。</p><h2 id="使用DOM的引用"><a href="#使用DOM的引用" class="headerlink" title="使用DOM的引用"></a>使用DOM的引用</h2><p>比如：我们需要对一组 li 标签进行遍历操作，我们可以用一个变量 length 把这组 li 标签的长度保存下来，然后基于length 进行遍历。</p><h2 id="使用事件代理批量处理事件"><a href="#使用事件代理批量处理事件" class="headerlink" title="使用事件代理批量处理事件"></a>使用事件代理批量处理事件</h2><p>比如：给一系列子元素 li 添加绑定事件，可以通过事件代理来进行优化。</p><a id="more"></a>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// container：父元素</span></span><br><span class="line">container.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    target = e.target || e.srcElement;</span><br><span class="line">    <span class="keyword">if</span> (target.tagName.toLowerCase() == <span class="string">'li'</span>) &#123;</span><br><span class="line">        <span class="comment">// 触发click后要做的事情</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h2 id="使用文档碎片"><a href="#使用文档碎片" class="headerlink" title="使用文档碎片"></a>使用文档碎片</h2><p>DocumentFragments 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。</p>
<p>因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。</p>
<p>这个方法真是处理批量标签的一大利器，使用它可以节省下很多时间，提高 DOM 性能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"><span class="keyword">let</span> wrapper = <span class="built_in">document</span>.createDocumentFragment; <span class="comment">// 使用文档碎片</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">    li.innerText = data[i];</span><br><span class="line">&#125;</span><br><span class="line">wrapper.appendChild(li);</span><br><span class="line">container.appendChild(wrapper);</span><br><span class="line">container.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    target = e.target || e.srcElement;</span><br><span class="line">    <span class="keyword">if</span> (target.tagName.toLowerCase() == <span class="string">'li'</span>) &#123;</span><br><span class="line">        <span class="comment">// 触发click后要做的事情</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h2 id="使用innerHTML一次性添加DOM节点"><a href="#使用innerHTML一次性添加DOM节点" class="headerlink" title="使用innerHTML一次性添加DOM节点"></a>使用innerHTML一次性添加DOM节点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"><span class="keyword">var</span> sHtml = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> len = data.length;</span><br><span class="line"><span class="keyword">var</span> i, li;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    sHtml += <span class="string">'&lt;li&gt;'</span> + data[i] + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">container.innerHTMl = sHtml; <span class="comment">// 最后一次性添加到页面中，只出发浏览器一次重排</span></span><br></pre></td></tr></table></figure>

<h2 id="通过className来批量修改元素样式"><a href="#通过className来批量修改元素样式" class="headerlink" title="通过className来批量修改元素样式"></a>通过className来批量修改元素样式</h2><p>经常有这样的场景，我们需要在js中批量的修改元素的样式，比如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ele.style.width = <span class="number">100</span> + <span class="string">'px'</span>;</span><br><span class="line">ele.style.height = <span class="number">100</span> + <span class="string">'px'</span>;</span><br><span class="line">ele.style.backgrounfColor = <span class="string">'red'</span>;</span><br><span class="line">ele.style.border = <span class="string">'solid 1px green'</span>;</span><br></pre></td></tr></table></figure>

<p>以上代码会多次出发浏览器重绘和重排，一种好的方式是将需要修改的样式在样式文件中先写好，通过给元素赋值className的形式批量修改样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.active</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">backgroung-color</span>: red;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给元素赋值className</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ele.className += <span class="string">' active'</span>; <span class="comment">// 注意前面的空格</span></span><br></pre></td></tr></table></figure>

<h2 id="如何渲染几万条数据并不卡住界面"><a href="#如何渲染几万条数据并不卡住界面" class="headerlink" title="如何渲染几万条数据并不卡住界面"></a>如何渲染几万条数据并不卡住界面</h2><p>可以通过 requestAnimationFrame 动画，动态渲染数据。</p>
<p>与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>如何渲染几万条数据并不卡住界面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        控件</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 异步任务 避免阻塞</span></span></span><br><span class="line"><span class="javascript">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 插入十万条数据</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> total = <span class="number">100000</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 一次插入 20 条，如果觉得性能不好就减少</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> once = <span class="number">20</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 渲染数据总共需要几次</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> loopCount = total / once</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 循环渲染次数</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> countOfRender = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>)</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 使用文档碎片 优化性能，插入不会造成回流</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; once; i++) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span></span><br><span class="line"><span class="javascript">                    li.innerText = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total)</span></span><br><span class="line">                    fragment.appendChild(li)</span><br><span class="line">                &#125;</span><br><span class="line">                ul.appendChild(fragment)</span><br><span class="line">                countOfRender += 1</span><br><span class="line">                loop()</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 循环条件判断</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (countOfRender &lt; loopCount) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">window</span>.requestAnimationFrame(add)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            loop()</span><br><span class="line">        &#125;, 0)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://qianlongo.github.io/2016/04/14/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BDOM%E7%AF%87%E7%AB%A0/#more" target="_blank" rel="noopener">前端性能优化之DOM篇章</a></li>
<li><a href="https://juejin.im/post/5c3ca3d76fb9a049a979f429" target="_blank" rel="noopener">你知道的requestAnimationFrame</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染原理与性能优化</title>
    <url>/2019-10-18/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="浏览器的渲染引擎"><a href="#浏览器的渲染引擎" class="headerlink" title="浏览器的渲染引擎"></a>浏览器的渲染引擎</h2><ul>
<li>IE（Trident）</li>
<li>Chrome（Blink）</li>
<li>Firefox（Gecko）</li>
<li>Opera（Blink）</li>
<li>Safari（Webkit）</li>
<li>UC（U3）</li>
<li>QQ浏览器微信（X5/Blink）</li>
</ul><p><strong><em>Blink</em></strong> 渲染引擎占据了半壁江山，<strong><em>Blink</em></strong> 的前身都是由 <strong><em>Webkit</em></strong> 优化改造而来的。浏览器内核决定了浏览器解释网页语法的方式。不同的渲染引擎，从而也导致了浏览器的兼容性问题。</p><a id="more"></a>

<h2 id="浏览器渲染“黑盒”"><a href="#浏览器渲染“黑盒”" class="headerlink" title="浏览器渲染“黑盒”"></a>浏览器渲染“黑盒”</h2><p><img src="/images/render2.png" alt="浏览器渲染“黑盒”"></p>
<p>浏览器呈现网页这个过程，宛如一个黑盒。在这个神秘的黑盒中，有许多功能模块，内核内部的实现正是这些功能模块相互配合协同工作进行的。其中我们最需要关注的，就是 <strong><em>HTML 解释器</em></strong>、<strong><em>CSS 解释器</em></strong>、<strong><em>图层布局计算模块</em></strong>、<strong><em>视图绘制模块</em></strong> 与 <strong><em>JavaScript 引擎</em></strong> 这几大模块：</p>
<ul>
<li><p>HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。</p>
</li>
<li><p>CSS 解释器：解析 CSS 文档, 生成样式规则。</p>
</li>
<li><p>图层布局计算模块：布局计算每个对象的精确位置和大小。</p>
</li>
<li><p>视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。</p>
</li>
<li><p>JavaScript 引擎：编译执行 Javascript 代码。</p>
</li>
</ul>
<h2 id="渲染原理解析"><a href="#渲染原理解析" class="headerlink" title="渲染原理解析"></a>渲染原理解析</h2><p><img src="/images/render1.jpg" alt="渲染原理"></p>
<ul>
<li>解析HTML<br>首先是解析HTML/SVG/XHTML，这个过程主要是把 HTML/SVG/XHTML 文档解析为 DOM 树的过程。<br>如果遇到 <strong>&lt;script&gt;</strong> 标签会停止解析，先执行标签当中 JavaScript；如果是外联方式，也需要等待下载并且执行完对应的 JavaScript 代码，然后才能够继续执行解析 HTML 的工作。HTML解析完成后触发 DOMContentLoaded 事件，这里我们就可以操作 DOM了。<br>在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。</li>
<li>解析CSS<br>解析 HTML 和解析 CSS 是并行处理的。解析 CSS 遇到 <strong>&lt;script&gt;</strong> 标签，会阻塞 CSS 的解析。CSS 解析器将 CSS 解析成 CSSStyleSheet (也被叫做 CSSOM 树)，这里的 CSSOM 树与 DOM 树结构类似。解析对应关系如下：<br><img src="/images/render3.jpg" alt="解析对应关系"></li>
<li>计算样式<br>CSSOM 与 DOM 树 结合，生成生成页面 render 树。</li>
<li>计算图层布局<br>页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。</li>
<li>绘制图层<br>在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。</li>
<li>整合图层，得到页面<br>最后一步浏览器会合并各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。</li>
</ul>
<h3 id="渲染过程概括"><a href="#渲染过程概括" class="headerlink" title="渲染过程概括"></a>渲染过程概括</h3><ul>
<li>当浏览器拿到一个网页后，首先浏览器会先解析HTML，如果遇到了外链的css，会一下载css，一边解析HTML。</li>
<li>当css下载完成后，会继续解析css，生成css Rules tree,不会影响到HTML的解析。</li>
<li>当遇到 <strong>&lt;script&gt;</strong> 标签时，一旦发现有对javascript的引用，就会立即下载脚本，同时阻断文档的解析，等脚本执行完成后，再开始文档的解析。</li>
<li>当DOM树和CSS规则树已经生成完毕后，构造 Rendering Tree。</li>
<li>调用系统渲染页面。</li>
</ul>
<h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><h3 id="CSS-的阻塞"><a href="#CSS-的阻塞" class="headerlink" title="CSS 的阻塞"></a>CSS 的阻塞</h3><p>CSS 解析和HTML解析是同步进行的，那么一个 HTML 文档首先解析的肯定是 HTML，然后才是 CSS，这就导致了 HTML 解析完成后，往往需要等待 CSS 解析。如果 CSS 没有解析完成，我们就需要一直等，这里就是 CSS 阻塞了相关的渲染。</p>
<p>CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</p>
<p>CSS 会阻塞后面内联 JavaScript 的执行。</p>
<p>我们往往把 CSS 样式表全部通过 <strong>&lt;style&gt;</strong> 标签内联到网页当中，或启用 CDN 实现静态资源加载速度的优化</p>
<h3 id="JS-的阻塞"><a href="#JS-的阻塞" class="headerlink" title="JS 的阻塞"></a>JS 的阻塞</h3><p>JS 引擎是独立于渲染引擎存在的。JavaScript 既会阻塞 HTML 解析，也会阻塞 CSS 解析。因此我们可以改变 JavaScript 的加载方式或者加载时机来进行优化：</p>
<ul>
<li>尽量将 JavaScript 文件放在 body 的底部；</li>
<li>body中间尽量不要写 <strong>&lt;script&gt;</strong> 标签；</li>
<li>使用 defer 和 async 来避免不必要的阻塞</li>
</ul>
<h3 id="JS的四种加载方式"><a href="#JS的四种加载方式" class="headerlink" title="JS的四种加载方式"></a>JS的四种加载方式</h3><ul>
<li><p>正常模式：这种情况下 JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执行完毕才能去做其它事情。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"index.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>async 模式：JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。使用 async 模式引入的多个 script 的执行顺序是不确定的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"index.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>defer 模式：JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。使用 defer 模式引入的多个 script 是从上往下顺序执行的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"index.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>动态异步引入<br>使用 document.createElement 创建的 script 默认是异步的，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.createElement(<span class="string">"script"</span>).async); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。defer 一般用于业务代码。如第三方统计代码。</p>
<p>注意 async 与 defer 属性对于 inline-script 都是无效的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://juejin.im/book/5b936540f265da0a9624b04b" target="_blank" rel="noopener">前端性能优化原理与实践</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-文件指纹策略：chunkhash、contenthash和hash</title>
    <url>/2019-10-18/webpack/webpack-%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9%E7%AD%96%E7%95%A5%EF%BC%9Achunkhash%E3%80%81contenthash%E5%92%8Chash/</url>
    <content><![CDATA[<h2 id="什么是文件指纹"><a href="#什么是文件指纹" class="headerlink" title="什么是文件指纹"></a>什么是文件指纹</h2><ul>
<li>打包后输出文件名的后缀</li>
<li>通常用于版本管理</li>
<li>hash一般是结合CDN缓存来使用，通过webpack构建之后，生成对应文件名自动带上对应的MD5值。如果文件内容改变的话，那么对应文件哈希值也会改变，对应的HTML引用的URL地址也会改变，触发CDN服务器从源服务器上拉取对应数据，进而更新本地缓存</li>
</ul><a id="more"></a>
<h2 id="文件指纹如何生成"><a href="#文件指纹如何生成" class="headerlink" title="文件指纹如何生成"></a>文件指纹如何生成</h2><ul>
<li>Hash：和整个项目的构建相关，webpack打包阶段会生成Compiler，Compilation。webpack启动那一次，会生成Compiler（初始化一次）。但是每一次只要项目文件有修改，，Compilation都会发生变化。Compilation变换就会影响Hash的变换，整个项目构建的 hash 值就会更改。如果css/js都是使用hash作为文件指纹的话，那么某一个js或者css发生改变，所有打包出来的css/js指纹都会变化。不利于缓存</li>
<li>Chunkhash：采用hash计算的话，每一次构建后生成的哈希值都不一样，即使文件内容压根没有改变。这样子是没办法实现缓存效果，我们需要换另一种哈希值计算方式，即chunkhash,chunkhash和hash不一样，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响</li>
<li>Contenthash：根据文件内容来定义 hash ，文件内容不变，则 contenthash 不变。某个页面既有js资源，又有css资源。如果css资源也使用Chunkhash。如果修改了js。由于css资源使用了Chunkhash，就会导致css内容没有变化，发布上线的文件却发生了变化。因此，通常对css资源使用Contenthash。这个时候可以使用mini-css-extract-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建</li>
</ul>
<h2 id="JS-的文件指纹设置"><a href="#JS-的文件指纹设置" class="headerlink" title="JS 的文件指纹设置"></a>JS 的文件指纹设置</h2><ul>
<li>设置 output 的 filename，使用 [chunkhash]，或[contenthash]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">        search: <span class="string">'./src/search.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name][chunkhash:8].js'</span>,</span><br><span class="line">        path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="CSS-的文件指纹设置"><a href="#CSS-的文件指纹设置" class="headerlink" title="CSS 的文件指纹设置"></a>CSS 的文件指纹设置</h2><ul>
<li>设置 MiniCssExtractPlugin 的 filename，使用 [contenthash]<ul>
<li>MiniCssExtractPlugin：将css资源提取到一个独立的文件。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">        search: <span class="string">'./src/search.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name][chunkhash:8].js'</span>,</span><br><span class="line">        path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">`[name][contenthash:8].css`</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="图片，字体文件的文件指纹设置"><a href="#图片，字体文件的文件指纹设置" class="headerlink" title="图片，字体文件的文件指纹设置"></a>图片，字体文件的文件指纹设置</h2><ul>
<li>设置 file-loader（或url-loader） 的 name，使用 [hash]</li>
</ul>
<table>
<thead>
<tr>
<th>占位符名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>[ext]</td>
<td>资源后缀名</td>
</tr>
<tr>
<td>[name]</td>
<td>文件名称</td>
</tr>
<tr>
<td>[path]</td>
<td>文件的相对路径</td>
</tr>
<tr>
<td>[floder]</td>
<td>文件所在文件夹</td>
</tr>
<tr>
<td>[contenthash]</td>
<td>文件的内容hash，默认是md5生成</td>
</tr>
<tr>
<td>[hash]</td>
<td>文件内容hash，默认是md5生成。图片的hash和css/js资源的hash概念不一样，图片的hash是由图片内容决定的</td>
</tr>
<tr>
<td>[emoji]</td>
<td>一个随机的指代文件内容的emoji</td>
</tr>
</tbody></table>
<p>注意：图片，字体文件的hash和css/js资源的hash概念不一样，图片，字体文件的hash是由内容决定的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        name: <span class="string">'img/[name][hash:8].[ext] '</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Webpack-具体配置信息"><a href="#Webpack-具体配置信息" class="headerlink" title="Webpack 具体配置信息"></a>Webpack 具体配置信息</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./test/test.js'</span>,</span><br><span class="line">        about: <span class="string">'./test/about.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        <span class="comment">//打包文件名称  chunkhash:8设置js资源的文件指纹</span></span><br><span class="line">        filename: <span class="string">'[name].[chunkhash:8].js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [&#123; <span class="attr">loader</span>: MiniCssExtractPlugin.loader &#125;, <span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">                loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                query: &#123;</span><br><span class="line">                    <span class="comment">// 设置图片资源的文件指纹 使用hash</span></span><br><span class="line">                    name: <span class="string">'[name].[ext]?[hash]'</span>,</span><br><span class="line">                    outputPath: <span class="string">'static/img/'</span>,</span><br><span class="line">                    publicPath: <span class="string">'/dist/static/img/'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,<span class="comment">//解析字体</span></span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            name: <span class="string">'[name]_[hash:8].[ext]'</span>,<span class="comment">//设置字体资源的文件指纹 使用hash</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            <span class="comment">// 将css资源提取到一个独立的文件</span></span><br><span class="line">            <span class="comment">// 设置css资源的文件指纹 用contenthash</span></span><br><span class="line">            filename: <span class="string">'[name].[contenthash:8].css'</span>,</span><br><span class="line">            chunkFilename: <span class="string">'[id].css'</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通常的文件缓存策略"><a href="#通常的文件缓存策略" class="headerlink" title="通常的文件缓存策略"></a>通常的文件缓存策略</h2><ul>
<li>html: header 头的 cache-control 会设置成 no-cache。也就是 html 文件不会走缓存</li>
<li>css/js/img 等静态资源：header头的 cache-control 设置成强缓存，缓存时间通常是1年的样子。通过文件指纹控制缓存是否失效，文件指纹一变，请求就不会走旧文件了</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化-浏览器缓存</title>
    <url>/2019-10-17/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：</p><ul>
<li>Memory Cache</li>
<li>Service Worker Cache</li>
<li>HTTP Cache</li>
<li>Push Cache</li>
</ul><p><img src="/images/cache3.jpg" alt="浏览器缓存"></p><p>其中，“from memory cache”对标到 Memory Cache 类型，“from ServiceWorker”对标到 Service Worker Cache 类型。至于 Push Cache，这个比较特殊，是 HTTP2 的新特性。</p><a id="more"></a>



<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>它需要服务端和客户端配合才能完成，常见的服务器软件如：Apache、Nginx都可以为资源设置不同的HTTP缓存策略。HTTP缓存策略又细分为 <strong><em>强制缓存</em></strong> 和 <strong><em>协商缓存</em></strong> 。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。</p>
<h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>强缓存是利用 http 头中的 <strong><em>Expires</em></strong> 和 <strong><em>Cache-Control</em></strong> 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。</p>
<p>命中强缓存的情况下，返回的 HTTP 状态码为 200 （如下图）:</p>
<p><img src="/images/cache4.png" alt="HTTP 状态码 200"></p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>expires是强制缓存策略的关键字段，expires是HTTP1.0的字段，是一个绝对时间值。当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段。像这样：</p>
<p><img src="/images/cache5.jpg" alt="Expires"></p>
<p>expires 是一个时间戳，当再次向服务器请求资源，浏览器本地时间和 expires 的时间戳会进行对比，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。</p>
<p>expires 最大的问题在于对“本地时间”的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达到我们的预期。可以通过 Cache-Control 解决这个问题。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>HTTP1.1 新增了 Cache-Control 字段来完成 expires 的任务。Cache-Control 可以视作是 expires 的完全替代方案。Cache-Control设置的是一个相对时间，可以更加精准地控制资源缓存。</p>
<p><img src="/images/cache6.jpg" alt="Cache-Control"></p>
<h4 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h4><ul>
<li>public<br>设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用<strong>max-age=</strong>来精确控制；</li>
<li>private<br>设置了该字段值的资源只能被用户浏览器缓存，不能作为共享缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；</li>
<li>no-cache<br>设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；</li>
<li>no-store<br>设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；</li>
</ul>
<h3 id="到期时间"><a href="#到期时间" class="headerlink" title="到期时间"></a>到期时间</h3><ul>
<li>max-age=<br>设置缓存的最大有效期，单位为秒；</li>
<li>s-maxage=：<br>优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；</li>
<li>max-stale[=]：<br>设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</li>
</ul>
<p>实际开发当中expires和Cache-Control一般都要进行设置，这是为了兼容不支持HTTP1.1的环境。两者同时存在，Cache-Control的优先级要高于expires。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了</p>
<h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h3><p><strong><em>Last-Modified</em></strong> 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Last-Modified: Fri, 27 Oct 2019 06:35:57 GMT</span><br></pre></td></tr></table></figure>

<p>随后我们每次请求时，会带上一个叫 <strong><em>If-Modified-Since</em></strong> 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If-Modified-Since: Fri, 27 Oct 2019 06:35:57 GMT</span><br></pre></td></tr></table></figure>

<p>服务器接收到这个时间戳后，根据 <strong><em>If-Modified-Since</em></strong> 的字段值和服务端资源最后的修改时间是否一致来判断资源是否有修改。如果没有修改，则返回的状态码为304；如果有修改，则返回新的资源，状态码为200。</p>
<h3 id="Last-Modified-弊端"><a href="#Last-Modified-弊端" class="headerlink" title="Last-Modified 弊端"></a>Last-Modified 弊端</h3><ul>
<li>服务端对Last-Modified标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内被修改多次的话，这个时候服务端无法准确标注文件的修改时间。</li>
<li>服务端文件进行了编辑，但文件的内容没有改变，这个资源在再次被请求时，会被当做新资源，导致文件无法使用缓存。</li>
</ul>
<h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h3><p><strong><em>Etag</em></strong> 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 <strong><em>Etag</em></strong> 就是不同的，反之亦然。因此 <strong><em>Etag</em></strong> 能够精准地感知文件的变化。</p>
<p><strong><em>Etag</em></strong> 和 <strong><em>Last-Modified</em></strong> 类似，当首次请求时，服务器响应头里返回一个最初的标识符字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETag: W/&quot;2a3b-1602480f459&quot;</span><br></pre></td></tr></table></figure>

<p>随后我们每次请求时，会带上一个叫 <strong><em>if-None-Match</em></strong> 的字符串，它的值正是上一次 response 返回给它的 <strong><em>Etag</em></strong> 值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If-None-Match: W/&quot;2a3b-1602480f459&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Etag-弊端"><a href="#Etag-弊端" class="headerlink" title="Etag 弊端"></a>Etag 弊端</h3><p>Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。</p>
<h3 id="HTTP-缓存决策指南"><a href="#HTTP-缓存决策指南" class="headerlink" title="HTTP 缓存决策指南"></a>HTTP 缓存决策指南</h3><p><img src="/images/cache7.png" alt="HTTP 缓存决策指南"></p>
<p>当资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。</p>
<h2 id="缓存字段的配置"><a href="#缓存字段的配置" class="headerlink" title="缓存字段的配置"></a>缓存字段的配置</h2><h3 id="expires和cache-control"><a href="#expires和cache-control" class="headerlink" title="expires和cache-control"></a>expires和cache-control</h3><p>如果使用的是 <strong><em>Nginx</em></strong>，那么打开Nginx的配置文件 <strong><em>nginx.conf</em></strong>，具体配置方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// expires:给图片设置过期时间30天，这里也可以设置其它类型文件</span></span><br><span class="line">location ~ \.(gif|jpg|jpeg|png)$ &#123;</span><br><span class="line">        root /<span class="keyword">var</span>/www/img/;</span><br><span class="line">        expires <span class="number">30</span>d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cache-control:给图片设置过期时间36秒，这里也可以设置其它类型文件</span></span><br><span class="line">location ~ \.(gif|jpg|jpeg|png)$ &#123;</span><br><span class="line">        root /<span class="keyword">var</span>/www/img/;</span><br><span class="line">        add_header    Cache-Control  max-age=<span class="number">3600</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用的是 <strong><em>Apache</em></strong>，那么打开Apache的配置文件 <strong><em>http.conf</em></strong>，具体的配置方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// expires</span><br><span class="line">&lt;IfModule expires_module&gt;</span><br><span class="line">      #打开缓存</span><br><span class="line">      ExpiresActive on </span><br><span class="line">      # 给图片设置过期时间30天，这里也可以设置其它类型文件</span><br><span class="line">      ExpiresByType image/gif access plus 30 days</span><br><span class="line">      ExpiresByType image/jpg access plus 30 days</span><br><span class="line">      ExpiresByType image/jpeg access plus 30 days</span><br><span class="line">      ExpiresByType image/png access plus 30 days</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">// cache-control</span><br><span class="line">&lt;FilesMatch &quot;\.(gif/jpg/jpeg/png)$&quot;&gt;</span><br><span class="line">　  	 Header set Cache-Control &quot;max-age=604800, public&quot;</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Last-Modified和Etag"><a href="#Last-Modified和Etag" class="headerlink" title="Last-Modified和Etag"></a>Last-Modified和Etag</h3><p>Last-Modified在Nginx和Apache当中都是默认启用的。</p>
<p>如果我们使用的是 <strong><em>Apache</em></strong>，那么只需要在 <strong><em>.htaccess</em></strong> 文件当中添加如下配置，即可开启Etag：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FileETag MTime Size</span><br></pre></td></tr></table></figure>

<p>如果我们使用的是 <strong><em>Nginx</em></strong>，需要先安装 <strong><em>Etag</em></strong> 模块；安装成功之后，仍然打开 <strong><em>nginx.conf</em></strong> 文件，确保当中没有出现 <strong><em>etgoff</em></strong>，然后添加如下配置，即可开启Etag：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ .*\.(gif|jpg|jpeg|png)$ &#123;</span><br><span class="line">   FileETag on;</span><br><span class="line">   etag_format &quot;%X%X%X&quot;; //这里格式化规则可以修改</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Service-Worker-Cache"><a href="#Service-Worker-Cache" class="headerlink" title="Service Worker Cache"></a>Service Worker Cache</h2><p>Service Worker是运行在浏览器背后的独立线程。可能大家在看到Service Worker这个概念的时候发现它经常和PWA一起出现。可以这么说，PWA应用在开发的时候必会用到Service Worker，这得益于Service强大的缓存能力。使用Service Worker前提必须是HTTPS协议，因为Service Worker涉及到了HTTP的拦截，所以必须使用HTTPS协议来保证安全。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="noopener">使用 Service Workers</a></p>
<h2 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h2><p>Memory Cache指得是内存中的缓存，大家都知道内存的读取是非常快的，但是空间确有限，而且持续性很短，一旦我们关闭当前tab页面，Memory Cache也就随着消失了。Memory Cache缓存的大部分是preloader指令下的静态资源。我们发现，Base64 格式的图片，几乎永远可以被塞进 memory cache。</p>
<h2 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h2><p>Disk Cache是存储在硬盘上的缓存，我们为静态资源设置的缓存一般都是缓存到Disk Cache当中，所以我们平时接触到最多的缓存就是Disk Cache。</p>
<h2 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h2><ul>
<li>Push Cache是推送缓存，它是HTTP2.0新增加的内容，目前实际的应用还偏少。</li>
<li>Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。</li>
<li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。</li>
<li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。</li>
<li><a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="noopener">了解更多</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://juejin.im/book/5b936540f265da0a9624b04b" target="_blank" rel="noopener">前端性能优化原理与实践</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化-本地存储</title>
    <url>/2019-10-17/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><ul>
<li>HTTP1.0中协议是无状态的，但在WEB应用中，在多个请求之间共享会话是非常必要的，所以出现了Cookie</li>
<li>cookie是为了辩别用户身份，进行会话跟踪而存储在客户端上的数据</li>
</ul><h3 id="Cookie原理"><a href="#Cookie原理" class="headerlink" title="Cookie原理"></a>Cookie原理</h3><p><img src="/images/cookie1.jpg" alt="Cookie原理"></p><p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会将cookie放入到响应请求中，在浏览器第二次发请求的时候，会把cookie带过去，服务端会辨别用户身份，当然服务器也可以修改cookie内容。</p><a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 服务器设置Cookie</span><br><span class="line">Set-Cookie:name=1111; Path=/</span><br></pre></td></tr></table></figure>

<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>Cookie一旦创建成功，那么名字无法进行修改；</li>
<li>Cookie不支持跨域，这是由Cookie隐私安全性所决定的，这样能够阻止非法获取其它网站的Cookie；</li>
<li>每个单独的域名下面的Cookie数量不能超过20个。</li>
<li>同一个域名下的所有请求，都会携带 Cookie。</li>
<li>Cookie 是有体积上限的，它最大只能有 4KB。当 Cookie 超过 4KB 时，将被裁切。</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取cookie 返回字符串</span></span><br><span class="line"><span class="keyword">const</span> allCookies = <span class="built_in">document</span>.cookie;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加cookie  newCookie是一个键值对形式的字符串。需要注意的是，用这个方法一次只能对一个cookie进行设置或更新。</span></span><br><span class="line"><span class="built_in">document</span>.cookie = newCookie;</span><br></pre></td></tr></table></figure>

<p>以下可选的cookie属性值可以跟在键值对后，用来具体化对cookie的设定/更新，使用分号以作分隔：</p>
<ul>
<li>path: 表示 cookie 影响到的路由，如 path=/。如果路径不能匹配时，浏览器则不发送这个Cookie</li>
<li>httpOnly: 如果在Cookie中设置了HttpOnly属性值true，那么通过JavaScript脚本将无法读取到cookie信息，保证Cookie不会被泄露，这样能有效的防止XSS攻击；</li>
<li>name: Cookie的名称，Cookie一旦创建，名称便不可更改；一个域名下绑定的cookie，name不能相同，相同的name的值会被覆盖掉。</li>
<li>value: Cookie的值。如果值为Unicode字符，需要为字符编码；如果值为二进制数据，则需要使用BASE64编码；</li>
<li>expires: 是一个绝对的过期时间，如果没有指定或为0表示当前会话有效；</li>
<li>maxAge: 是以秒为单位的，是一个相对时间。正常情况下，max-age的优先级高于expires。Max-Age为正数时，cookie会在Max-Age秒之后，被删除，当Max-Age为负数时，表示的是临时储存，不会生出cookie文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭，cookie就会消失，当Max-Age为0时，又会发生什么呢，删除cookie，因为cookie机制本身没有设置删除cookie，失效的cookie会被浏览器自动从内存中删除，所以，它实现的就是让cookie失效。</li>
<li>domain: 可以访问该Cookie的域名，如果设置为“.immoc.com”，则所有以“immoc.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”；</li>
<li>comment: Cookie的用处说明，浏览器显示Cookie信息的时候显示该说明。</li>
<li>secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>Cookie和Session结合使用是最常见的使用场景。我们把session_id存储在Cookie当中，然后每次请求的时候携带这个session_id，这样我们就知道是谁发起的请求，从而返回对应的信息；</li>
<li>统计页面的点击次数。</li>
</ul>
<h3 id="cookie使用注意事项"><a href="#cookie使用注意事项" class="headerlink" title="cookie使用注意事项"></a>cookie使用注意事项</h3><ul>
<li>可能被客户端篡改，使用前验证合法性</li>
<li>不要存储敏感数据，比如用户密码，账户余额</li>
<li>使用httpOnly保证安全</li>
<li>尽量减少cookie的体积</li>
<li>设置正确的domain和path，减少数据传输</li>
</ul>
<h2 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>大小方面相比，LocalStorage突破了4KB大小体积限制，一般是5MB;</li>
<li>LocalStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；</li>
<li>仅位于浏览器端，不与服务端发生通信。，不会像Cookie那样，每次的HTTP请求都会携带。</li>
</ul>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul>
<li>浏览器兼容性问题，IE只有在IE8以上的版本才会支持；</li>
<li>如果浏览器设置为隐私模式，那么我们无法读取LocalStorage；</li>
<li>LocalStorage受同源策略的限制，即协议、端口、主机地址有任何一个不同，则无法访问。</li>
</ul>
<h3 id="Local-Storage-应用场景"><a href="#Local-Storage-应用场景" class="headerlink" title="Local Storage 应用场景"></a>Local Storage 应用场景</h3><p>可以存储一些全局状态，数据。比如：个人昵称、不常改动的图片信息等。对于换肤这个需求，我们完全可以把换肤的信息存储在LocalStorage当中，操作LocalStorage即可。</p>
<h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p>Session Storage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p>
<h3 id="SessionStorage-应用场景"><a href="#SessionStorage-应用场景" class="headerlink" title="SessionStorage 应用场景"></a>SessionStorage 应用场景</h3><p>由于SessionStorage具有时效性，常用的业务场景比如网站常见的游客登录，就可以存储在SessionStorage当中，还有网站的一些临时浏览记录都可以使用SessionStorage来进行记录。</p>
<h2 id="Local-Storage-与-Session-Storage"><a href="#Local-Storage-与-Session-Storage" class="headerlink" title="Local Storage 与 Session Storage"></a>Local Storage 与 Session Storage</h2><ul>
<li>SessionStorage和LocalStorage一样都是在本地进行数据存储；</li>
<li>Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享。</li>
<li>LocalStorage和SessionStorage都不能被爬虫爬取；</li>
<li>LocalStorage和SessionStorage的API用法是非常相似的，具体的API使用方法如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存数据，以键值对的方式储存信息；</span></span><br><span class="line">setItem (key, value)</span><br><span class="line"><span class="comment">// 获取数据，将键值传入，即可获取到对应的value值；</span></span><br><span class="line">getItem (key)</span><br><span class="line"><span class="comment">// 删除单个数据，根据键值移除对应的信息</span></span><br><span class="line">removeItem (key)</span><br><span class="line"><span class="comment">// 删除所有的数据</span></span><br><span class="line">clear ()</span><br><span class="line"><span class="comment">// 获取某个索引的key</span></span><br><span class="line">key (index)</span><br></pre></td></tr></table></figure>

<h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexDB 是一个运行在浏览器上的非关系型数据库。理论上来说，IndexDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。。<a href="https://www.zhangxinxu.com/wordpress/2017/07/html5-indexeddb-js-example/" target="_blank" rel="noopener">了解更多</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化-CDN 缓存</title>
    <url>/2019-10-17/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-CDN-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h2><p><strong><em>CDN</em></strong> 的全称是 <strong><em>Content Delivery Network</em></strong>，即内容分发网络。CDN服务商将源站的资源缓存到遍布全国的高性能加速节点上，当用户访问相应的业务资源时，用户会被调度至最接近的节点最近的节点ip返回给用户，使内容能够传输的更快，更加稳定。可以提升首次请求的响应能力。</p><h2 id="CDN缓存-基本原理"><a href="#CDN缓存-基本原理" class="headerlink" title="CDN缓存 基本原理"></a>CDN缓存 基本原理</h2><a id="more"></a>
<p><strong><em>CDN</em></strong> 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<p><strong><em>CDN</em></strong> 的基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<h2 id="CDN的核心功能"><a href="#CDN的核心功能" class="headerlink" title="CDN的核心功能"></a>CDN的核心功能</h2><p>CDN 的核心点有两个，一个是缓存，一个是回源。</p>
<p>这两个概念都非常好理解。对标到上面描述的过程，“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。</p>
<h2 id="CDN缓存应用场景"><a href="#CDN缓存应用场景" class="headerlink" title="CDN缓存应用场景"></a>CDN缓存应用场景</h2><ul>
<li><p>使用第三方的CDN服务：前端开源项目的CDN加速服务，<a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">第三方的CDN服务</a></p>
</li>
<li><p>CDN 往往被用来存放静态资源：所谓“静态资源”，就是像 JS、CSS、图片等不需要业务服务器进行计算即得的资源。而“动态资源”，顾名思义是需要后端实时动态生成的资源，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。而且我们可以写脚本结合Webpack将对应的静态资源直接放到CDN，完成一键自动部署整个项目。</p>
</li>
<li><p>把静态资源和业务服务器置于不同的域名下：静态服务器最好启用一个全新域名，避免每次请求都携带Cookie。</p>
</li>
<li><p>直播传送：直播本质上是使用流媒体进行传送，那么CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化-缓存</title>
    <url>/2019-10-17/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手段。对于这个操作的必要性，Chrome 官方给出的解释似乎更有说服力一些：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="缓存的优点"><a href="#缓存的优点" class="headerlink" title="缓存的优点"></a>缓存的优点</h2><ul>
<li>获得更快的读写能力：相比数据库I/O操作磁盘，缓存I/O操作内存速度更快。</li>
<li>降低数据库压力：把常用的数据放在缓存中，请求直接读取缓存，可以减轻数据库的负担。</li>
<li>减少冗余数据传输：很多的静态资源，基本上很少有改动，有了缓存之后，我们只用在有文件改动的时候，再重新从服务器拉取新的资源即可。</li>
<li>节省流量：有了缓存，对于那些非常大的静态资源，我们无需每次进行请求，可以节省大量的流量，流量就是钱，对应的我们可以利用缓存为我们服务的公司节省一笔不小的开支。</li>
<li>降低时延：对于已经缓存好的数据，我们就无需再发请求给服务器，这样就节省下很多HTTP请求的时间，降低时延。</li>
</ul>
<h2 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类"></a>缓存的分类</h2><h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><p>CDN是通过在多个节点部署来减少请求时间的，这样我们不需要每次都回源到源站服务器进行请求。CDN对于常见的HTTP请求都是支持的，但是并不是对所有请求方式都会进行缓存，进行缓存的只有GET请求，对于其它请求均不作缓存，仅仅起到转发作用，相当于proxy。</p>
<p><img src="/images/cache1.jpg" alt="CDN缓存"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tips:关于CDN站点部署最好使用动静分离的形式，将动态请求和静态请求的内容独立成两个站点，而 CDN 仅仅加速静态站点中的资源，现在的CDN服务商大多数也都支持这个功能。</span><br></pre></td></tr></table></figure>

<h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><p>数据库属于 I/O 操作密集型的应用，主要负责数据的管理及存储。数据库缓存是一类特殊的缓存，是数据库自身的缓存机制。大多数据库不需要配置就可以快速运行，但并没有为特定的需求进行优化。在数据库调优的时候，缓存优化是一项很重要的工作。</p>
<p>数据库缓存就是我们把一些经常会被访问到资源直接放到内存当中，当数据没有变化我们并不会去让直接读写数据库，只有数据发生变化的时候我们才会去操作数据库。</p>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。</p>
<p>浏览器缓存是根据一套与服务端约定好的规则来进行工作的。</p>
<h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>本地存储主要有以下几种：LocalStorage、SessionStorage和Cookie、WebSql(废弃)和IndexDB，其中IndexDB主要用在前端有大容量存储需求的页面上，例如在线编辑或者网页邮箱。</p>
<h3 id="接口缓存"><a href="#接口缓存" class="headerlink" title="接口缓存"></a>接口缓存</h3><p>通过 AOP 面向切片编程，集合装饰器的使用，我们可以将一个接口请求的返回结果直接缓存起来。这样在调用这个接口的入参相同时，可以直接从缓存中读取数据，减少了请求，提高了相应速度。在此基础上，还可以对这个装饰器做进一步的优化，比如对存储对 key 做序列化并求 hash、给装饰器加锁防止并行操作等等。</p>
<h3 id="Web应用层缓存"><a href="#Web应用层缓存" class="headerlink" title="Web应用层缓存"></a>Web应用层缓存</h3><p>当平台级缓存不能满足系统性能要求的时候，就要考虑使用应用级缓存了。应用级缓存，需要开发者通过代码来实现缓存机制，这里主要使用NoSQL型数据库来进行相关实现。不管是Redis 还是MongoDB，以及Memcached 都可以作为应用级缓存的重要技术。一种典型的方式是每分钟或一段时间后统一生成某类页面存储在缓存中，或者可以在热数据变化时更新缓存。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree Shaking的使用和原理分析</title>
    <url>/2019-10-17/webpack/Tree-Shaking%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="tree-shaking-摇树优化"><a href="#tree-shaking-摇树优化" class="headerlink" title="tree shaking(摇树优化)"></a>tree shaking(摇树优化)</h2><ul>
<li>概念：1 个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到bundle 里面去，tree shaking 就是只把用到的方法打入 bundle ，没用到的方法会在uglify 阶段被擦除掉</li>
<li>使用：<ul>
<li>webpack 默认支持，在 .babelrc 里设置 modules: false 即可</li>
<li>production mode的情况下默认开启</li>
</ul>
</li>
<li>要求：<ul>
<li>必须是 ES6 的语法，CJS 的方式不支持</li>
<li>需要tree shaking的模块代码是没有副作用的，否则tree shaking会失效</li>
</ul>
</li>
</ul><a id="more"></a>
<h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><ul>
<li>副作用这个概念来源于函数式编程(FP)，纯函数是没有副作用的，也不依赖外界环境或者改变外界环境。纯函数的概念是：接受相同的输入，任何情况下输出都是一样的。</li>
<li>非纯函数存在副作用，副作用就是：相同的输入，输出不一定相同。或者这个函数会影响到外部变量、外部环境。</li>
<li>函数如果调用了全局对象或者改变函数外部变量，则说明这个函数有副作用</li>
</ul>
<h2 id="DCE-Dead-code-elimination"><a href="#DCE-Dead-code-elimination" class="headerlink" title="DCE (Dead code elimination)"></a>DCE (Dead code elimination)</h2><ul>
<li><p>没有导入和使用</p>
</li>
<li><p>代码不会被执⾏，不可到达</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'false'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码执行的结果不会被用到</p>
<ul>
<li>执行函数返回结果，结果没有赋值给变量。</li>
<li>执行函数返回结果，结果赋值给变量。但是变量没有被使用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;func2&#125; <span class="keyword">from</span> <span class="string">'./functions'</span>;</span><br><span class="line">func2();</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码只会影响死变量（只写不读）</p>
<ul>
<li>定义了一个变量，修改了它的值，但是并没有使用。</li>
</ul>
</li>
</ul>
<h2 id="Tree-shaking-原理"><a href="#Tree-shaking-原理" class="headerlink" title="Tree-shaking 原理"></a>Tree-shaking 原理</h2><ul>
<li>利用 ES6 模块的特点:<ul>
<li>只能作为模块顶层的语句出现</li>
<li>import 的模块名只能是字符串常量，不能动态引入模块</li>
<li>import binding 是 immutable的，引入的模块不能再进行修改</li>
</ul>
</li>
<li>代码擦除： uglify 阶段删除无用代码</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用动态Polyfill服务</title>
    <url>/2019-10-17/webpack/%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81Polyfill%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="构建体积优化：动态-Polyfill"><a href="#构建体积优化：动态-Polyfill" class="headerlink" title="构建体积优化：动态 Polyfill"></a>构建体积优化：动态 Polyfill</h2><p><img src="/images/25.png" alt="构建体积优化：动态 Polyfill"></p><h2 id="Polyfill-Service原理"><a href="#Polyfill-Service原理" class="headerlink" title="Polyfill Service原理"></a>Polyfill Service原理</h2><ul>
<li><p>每次打开页面，浏览器都会向Polyfill Service发送请求，Polyfill Service识别 User Agent，下发不同的 Polyfill，做到按需加载Polyfill的效果。</p>
<p><img src="/images/28.png" alt="Polyfill Service原理"></p>
</li>
</ul><h2 id="构建体积优化：如何使用动态-Polyfill-service"><a href="#构建体积优化：如何使用动态-Polyfill-service" class="headerlink" title="构建体积优化：如何使用动态 Polyfill service"></a>构建体积优化：如何使用动态 Polyfill service</h2><a id="more"></a>

<ul>
<li><p><a href="https://polyfill.io/v3/" target="_blank" rel="noopener">polyfill.io</a> 官方提供的服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//访问url，根据User Agent 直接返回浏览器所需的 polyfills</span><br><span class="line">https://polyfill.io/v3/polyfill.min.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于官方自建 polyfill 服务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//huayang.qq.com/polyfill_service/v2/polyfill.min.js?unknown=polyfill&amp;features=Promise,Map,Set</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><a href="https://c7sky.com/polyfill-io.html" target="_blank" rel="noopener">其他</a></li>
</ul>
<h2 id="体积优化策略总结"><a href="#体积优化策略总结" class="headerlink" title="体积优化策略总结"></a>体积优化策略总结</h2><ul>
<li>Scope Hoisting</li>
<li>Tree-shaking</li>
<li>公共资源分离</li>
<li>图片压缩</li>
<li>动态 Polyfill</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用webpack进行图片压缩</title>
    <url>/2019-10-17/webpack/%E4%BD%BF%E7%94%A8webpack%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h2 id="使用webpack进行图片压缩"><a href="#使用webpack进行图片压缩" class="headerlink" title="使用webpack进行图片压缩"></a>使用webpack进行图片压缩</h2><ul>
<li>要求：基于 Node 库的 imagemin 或者 tinypng API</li>
<li>使用：配置 image-webpack-loader</li>
</ul><h2 id="Imagemin的优点分析"><a href="#Imagemin的优点分析" class="headerlink" title="Imagemin的优点分析"></a>Imagemin的优点分析</h2><ul>
<li>有很多定制选项</li>
<li>可以引入更多第三方优化插件，例如pngquant</li>
<li>可以处理多种图片格式</li>
</ul><h2 id="Imagemin的压缩原理"><a href="#Imagemin的压缩原理" class="headerlink" title="Imagemin的压缩原理"></a>Imagemin的压缩原理</h2><a id="more"></a>

<ul>
<li>pngquant: 是一款PNG压缩器，通过将图像转换为具有alpha通道（通常比24/32位PNG文件小60-80％）的更高效的8位PNG格式，可显著减小文件大小</li>
<li>pngcrush：其主要目的是通过尝试不同的压缩级别和PNG过滤方法来降低PNG IDAT数据流的大小。</li>
<li>optipng：其设计灵感来自于pngcrush。optipng可将图像文件重新压缩为更小尺寸，而不会丢失任何信息。</li>
<li>tinypng：也是将24位png文件转化为更小有索引的8位图片，同时所有非必要的metadata也会被剥离掉</li>
</ul>
<h2 id="image-webpack-loader"><a href="#image-webpack-loader" class="headerlink" title="image-webpack-loader"></a>image-webpack-loader</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在你的webpack.config.js中，在file-loader之后使用image-webpack-loader</span></span><br><span class="line"><span class="comment">//对于要配置的每个优化程序，请在选项中指定相应的键</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.(gif|png|jpe?g|svg)$/i</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="string">'file-loader'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        mozjpeg: &#123;</span><br><span class="line">                            progressive: <span class="literal">true</span>,</span><br><span class="line">                            quality: <span class="number">65</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">// optipng.enabled: false will disable optipng</span></span><br><span class="line">                        optipng: &#123;</span><br><span class="line">                            enabled: <span class="literal">false</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        pngquant: &#123;</span><br><span class="line">                            quality: [<span class="number">0.65</span>, <span class="number">0.90</span>],</span><br><span class="line">                            speed: <span class="number">4</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        gifsicle: &#123;</span><br><span class="line">                            interlaced: <span class="literal">false</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">// the webp option will enable WEBP</span></span><br><span class="line">                        webp: &#123;</span><br><span class="line">                            quality: <span class="number">75</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Tree Shaking擦除无用的JavaScript和CSS</title>
    <url>/2019-10-17/webpack/%E4%BD%BF%E7%94%A8Tree-Shaking%E6%93%A6%E9%99%A4%E6%97%A0%E7%94%A8%E7%9A%84JavaScript%E5%92%8CCSS/</url>
    <content><![CDATA[<h2 id="tree-shaking-摇树优化"><a href="#tree-shaking-摇树优化" class="headerlink" title="tree shaking(摇树优化)"></a>tree shaking(摇树优化)</h2><ul>
<li>概念：1 个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到bundle 里面去，tree shaking 就是只把用到的方法打入 bundle ，没用到的方法会在uglify 阶段被擦除掉</li>
<li>使用：<ul>
<li>webpack 默认支持，在 .babelrc 里设置 modules: false 即可</li>
<li>production mode的情况下默认开启</li>
</ul>
</li>
<li>要求：<ul>
<li>必须是 ES6 的语法，CJS 的方式不支持</li>
<li>需要tree shaking的模块代码是没有副作用的，否则tree shaking会失效</li>
</ul>
</li>
<li><a href="/2019-10-17/webpack/Tree-Shaking的使用和原理分析">Tree Shaking的使用和原理分析</a></li>
</ul><a id="more"></a>
<h2 id="无用的-CSS-如何删除掉？"><a href="#无用的-CSS-如何删除掉？" class="headerlink" title="无用的 CSS 如何删除掉？"></a>无用的 CSS 如何删除掉？</h2><ul>
<li>PurifyCSS: 遍历代码，识别已经用到的 CSS class，没有用到的已经识别的就会做一个标记。</li>
<li>uncss: HTML 需要通过 jsdom 加载，所有的样式通过PostCSS解析，通过document.querySelector 来识别在 html 文件里面不存在的选择器</li>
</ul>
<h2 id="在-webpack-中如何使用-PurifyCSS"><a href="#在-webpack-中如何使用-PurifyCSS" class="headerlink" title="在 webpack 中如何使用 PurifyCSS?"></a>在 webpack 中如何使用 PurifyCSS?</h2><ul>
<li><p>purifycss-webpack以停止维护，建议使用purgecss-webpack-plugin</p>
</li>
<li><p>使用 <a href="https://github.com/FullHuman/purgecss-webpack-plugin" target="_blank" rel="noopener">purgecss-webpack-plugin</a>和 mini-css-extract-plugin 配合使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> PurgecssPlugin = <span class="built_in">require</span>(<span class="string">'purgecss-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要进行解析的文件目录 绝对路径</span></span><br><span class="line"><span class="keyword">const</span> PATHS = &#123;</span><br><span class="line">    src: path.join(__dirname, <span class="string">'src'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.join(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                styles: &#123;</span><br><span class="line">                    name: <span class="string">'styles'</span>,</span><br><span class="line">                    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                    chunks: <span class="string">'all'</span>,</span><br><span class="line">                    enforce: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    <span class="string">"css-loader"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">"[name].css"</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> PurgecssPlugin(&#123;</span><br><span class="line">            <span class="comment">//path：您可以使用文件数组指定purgecss应分析的内容。它可以是html，pug，blade，...文件。您可以使用glob或glob-all之类的模块轻松获取文件列表</span></span><br><span class="line">            paths: glob.sync(<span class="string">`<span class="subst">$&#123;PATHS.src&#125;</span>/**/*`</span>, &#123; <span class="attr">nodir</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>缩小构建目标</title>
    <url>/2019-10-17/webpack/%E7%BC%A9%E5%B0%8F%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h2 id="缩小构建目标"><a href="#缩小构建目标" class="headerlink" title="缩小构建目标"></a>缩小构建目标</h2><ul>
<li><p>目的：尽可能的少构建模块</p>
</li>
<li><p>比如 exclude 不解析相应的模块，目录。include 只解析解析相应的模块，目录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="comment">//?cacheDirectory=true 开启缓存</span></span><br><span class="line">            use: <span class="string">'babel-loader?cacheDirectory=true'</span>,<span class="comment">//使用babel-loader解析ES6  </span></span><br><span class="line">            exclude: <span class="string">'node_modules'</span>,</span><br><span class="line">            include: <span class="string">'src'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul><a id="more"></a>
<h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>resolve配置，设置模块如何被解析。通过resolve的配置，可以帮助Webpack快速查找依赖，也可以替换对应的依赖。<a href="https://webpack.js.org/configuration/resolve/" target="_blank" rel="noopener">了解更多</a></p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```json</span><br><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [&quot;.js&quot;,&quot;.jsx&quot;,&quot;.json&quot;,&quot;.css&quot;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 每当引入bootstrap模块的时候，它会直接引入bootstrap,而不需要从node_modules文件夹中按模块的查找规则查找</span><br><span class="line"></span><br><span class="line">  ```javascript</span><br><span class="line">  const bootstrap = path.resolve(__dirname, &apos;node_modules/_bootstrap@3.3.7@bootstrap/dist/css/bootstrap.css&apos;);</span><br><span class="line">  resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">          &quot;bootstrap&quot;: bootstrap</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>resolve.modules：告诉 webpack 解析模块时应该搜索的目录</p>
</li>
<li><p>resolve.mainFields：当从 npm 包中导入模块时（例如，import * as D3 from ‘d3’），此选项将决定在 package.json 中使用哪个字段导入模块。根据 webpack 配置中指定的 target 不同，默认值也会有所不同</p>
</li>
<li><p>resolve.mainFiles：解析目录时要使用的文件名，默认是index</p>
</li>
</ul>
<h2 id="减少文件搜索范围"><a href="#减少文件搜索范围" class="headerlink" title="减少文件搜索范围"></a>减少文件搜索范围</h2><ul>
<li><p>优化 resolve.modules 配置（减少模块搜索层级）</p>
</li>
<li><p>优化 resolve.mainFields 配置（优化入口文件分析，搜索过程）</p>
</li>
<li><p>优化 resolve.extensions 配置（缩小扩展名查找范围）</p>
</li>
<li><p>合理使用 alias</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">        <span class="string">'react'</span>: path.resolve(__dirname, <span class="string">'./node_modules/react/umd/react.production.min.js'</span>),</span><br><span class="line">        <span class="string">'react-dom'</span>: path.resolve(__dirname, <span class="string">'./node_modules/react-dom/umd/react-dom.production.min.js'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="string">'.js'</span>],</span><br><span class="line">    mainFields: [<span class="string">'main'</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>充分利用缓存提升二次构建速度</title>
    <url>/2019-10-17/webpack/%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E7%BC%93%E5%AD%98%E6%8F%90%E5%8D%87%E4%BA%8C%E6%AC%A1%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li>目的：提升二次构建速度</li>
<li>缓存思路：<ul>
<li><a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">babel-loader</a> 开启缓存：提升二次解析速度</li>
<li><a href="https://github.com/webpack-contrib/terser-webpack-plugin" target="_blank" rel="noopener">terser-webpack-plugin</a> 开启缓存：提升二次压缩速度</li>
<li>使用 <a href="https://github.com/webpack-contrib/cache-loader" target="_blank" rel="noopener">cache-loader</a> 或者 <a href="https://github.com/mzgoddard/hard-source-webpack-plugin" target="_blank" rel="noopener">hard-source-webpack-plugin</a>：用于缓存 webpack 内部模块处理的中间结果，提升二次模块转换速度</li>
</ul>
</li>
</ul><a id="more"></a>
<p>如果开启了缓存，<strong><em>node_modules</em></strong> 文件加下，会有一个 <strong><em>.cache</em></strong> 文件夹目录。</p>
<h2 id="babel-loader-开启缓存"><a href="#babel-loader-开启缓存" class="headerlink" title="babel-loader 开启缓存"></a>babel-loader 开启缓存</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="comment">//?cacheDirectory=true 开启缓存</span></span><br><span class="line">            use: <span class="string">'babel-loader?cacheDirectory=true'</span><span class="comment">//使用babel-loader解析ES6  </span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="terser-webpack-plugin"><a href="#terser-webpack-plugin" class="headerlink" title="terser-webpack-plugin"></a>terser-webpack-plugin</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">        <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">            parallel: <span class="literal">true</span>,<span class="comment">//开启多进程并行压缩代码</span></span><br><span class="line">            cache: <span class="literal">true</span>,<span class="comment">//开启缓存</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="使用-cache-loader-或者-hard-source-webpack-plugin"><a href="#使用-cache-loader-或者-hard-source-webpack-plugin" class="headerlink" title="使用 cache-loader 或者 hard-source-webpack-plugin"></a>使用 cache-loader 或者 hard-source-webpack-plugin</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hard-source-webpack-plugin 开启缓存</span></span><br><span class="line"><span class="keyword">const</span> HardSourceWebpackPlugin = <span class="built_in">require</span>(<span class="string">'hard-source-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HardSourceWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>进一步分包：预编译资源模块 使用 DLLPlugin 进行分包</title>
    <url>/2019-10-17/webpack/%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%88%86%E5%8C%85%EF%BC%9A%E9%A2%84%E7%BC%96%E8%AF%91%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9D%97-%E4%BD%BF%E7%94%A8-DLLPlugin-%E8%BF%9B%E8%A1%8C%E5%88%86%E5%8C%85/</url>
    <content><![CDATA[<h2 id="分包：设置-Externals"><a href="#分包：设置-Externals" class="headerlink" title="分包：设置 Externals"></a>分包：设置 Externals</h2><ul>
<li>思路：将 react、react-dom 基础包通过 cdn 引入，不打入 bundle 中</li>
<li>方法：使用 html-webpack-externals-plugin</li>
</ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在配置文件中添加HtmlWebpackExternalsPlugin插件</span></span><br><span class="line"><span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">    externals: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">            entry: <span class="string">'https://cdn.bootcss.com/react/15.6.1/react.js'</span>,</span><br><span class="line">            global: <span class="string">'React'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">            entry: <span class="string">'https://cdn.bootcss.com/react/15.6.1/react-dom.js'</span>,</span><br><span class="line">            global: <span class="string">'ReactDOM'</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a>


<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>基础库分离 需要在html中引入基础库<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/react/15.6.1/react.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/react/15.6.1/react-dom.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="预编译资源模块-更好的分包策略"><a href="#预编译资源模块-更好的分包策略" class="headerlink" title="预编译资源模块 更好的分包策略"></a>预编译资源模块 更好的分包策略</h2><ul>
<li>思路：<ul>
<li>使用 <strong><em>webpack.dll..js</em></strong> 把所有的第三方库依赖，react、react-dom、redux、react-redux基础包和业务基础包打包到一个bundle的dll文件里面。</li>
<li>同时也会生成manifest.json文件。manifest.json文件是对分离出来的包的描述。该manifest.json的作用是用来让 DllReferencePlugin 映射到相关的依赖上去。</li>
</ul>
</li>
<li>方法：使用 DLLPlugin 进行分包，DllReferencePlugin引用 manifest.json 包。引用后，就会自动关联DLLPlugin中的包。</li>
<li>说明：<ul>
<li>DllPlugin 通常用于基础包（框架包、业务包）的分离。</li>
<li>SplitChunks 虽然也可以做 DllPlugin 的事情，但是更加推荐使用 SplitChunks 去提取页面间的公共 js 文件。因为使用 SplitChunks 每次去提取基础包还是需要耗费构建时间的，如果是 DllPlugin 只需要预编译一次，后面的基础包时间都可以省略掉。</li>
</ul>
</li>
<li><a href="https://www.webpackjs.com/plugins/dll-plugin/" target="_blank" rel="noopener">DLLPlugin详情</a></li>
</ul>
<h2 id="使用-DLLPlugin-进行分包"><a href="#使用-DLLPlugin-进行分包" class="headerlink" title="使用 DLLPlugin 进行分包"></a>使用 DLLPlugin 进行分包</h2><ul>
<li><p>在一个额外的独立的 webpack.dll.js 配置中，使用 DLLPlugin 进行分包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        <span class="comment">//指定需要进行分离的基础包 library：当前动态链接库的名称 [name] 代表当前动态链接库的名称</span></span><br><span class="line">        library: [</span><br><span class="line">            <span class="string">'react'</span>,</span><br><span class="line">            <span class="string">'react-dom'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].dll.js'</span>,<span class="comment">//输出的动态链接库(dll)的文件名称，[name] 代表当前动态链接库的名称</span></span><br><span class="line">        path: path.join(__dirname, <span class="string">'build/library'</span>),<span class="comment">// 输出的文件目录</span></span><br><span class="line">        library: <span class="string">'[name]'</span><span class="comment">//存放动态链接库的全局变量名称</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            name: <span class="string">'_dll_[name]'</span>,<span class="comment">//该字段的值也就是输出的 manifest.json 文件 中 name 字段的值 例如 library.manifest.json 中就有 "name": "_dll_library"</span></span><br><span class="line">            path: path.join(__dirname, <span class="string">'build/library/[name].manifest.json'</span>)<span class="comment">//</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用-DllReferencePlugin-引用-manifest-json"><a href="#使用-DllReferencePlugin-引用-manifest-json" class="headerlink" title="使用  DllReferencePlugin 引用 manifest.json"></a>使用  DllReferencePlugin 引用 manifest.json</h2><ul>
<li><p>在 webpack.config.js 引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DllReferencePlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/DllReferencePlugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">          context: path.join(__dirname, <span class="string">'build/library'</span>),<span class="comment">//(绝对路径) manifest (或者是内容属性)中请求的上下文 不设置会报错</span></span><br><span class="line">          manifest: <span class="built_in">require</span>(<span class="string">'./build/library/library.manifest.json'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程并行压缩代码</title>
    <url>/2019-10-17/webpack/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="多进程-多实例：并行压缩"><a href="#多进程-多实例：并行压缩" class="headerlink" title="多进程/多实例：并行压缩"></a>多进程/多实例：并行压缩</h2><ul>
<li>使用 <a href="https://github.com/gdborton/webpack-parallel-uglify-plugin" target="_blank" rel="noopener">parallel-uglify-plugin</a> 插件</li>
<li><a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">uglifyjs-webpack-plugin</a> 开启 parallel 参数</li>
<li><a href="https://github.com/webpack-contrib/terser-webpack-plugin" target="_blank" rel="noopener">terser-webpack-plugin</a> 开启 parallel 参数：<strong><em>推荐使用</em></strong></li>
</ul><h2 id="使用-parallel-uglify-plugin-插件"><a href="#使用-parallel-uglify-plugin-插件" class="headerlink" title="使用 parallel-uglify-plugin 插件"></a>使用 parallel-uglify-plugin 插件</h2><a id="more"></a>
<ul>
<li>在通过 new ParallelUglifyPlugin() 实列化时，支持以下参数配置：<ul>
<li>test: 使用正则去匹配哪些文件需要被 ParallelUglifyPlugin 压缩，默认是 /.js$/.</li>
<li>include: 使用正则去包含被 ParallelUglifyPlugin 压缩的文件，默认为 [].</li>
<li>exclude: 使用正则去不包含被 ParallelUglifyPlugin 压缩的文件，默认为 [].</li>
<li>cacheDir: 缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回，cacheDir 用于配置缓存存放的目录路径。默认不会缓存，想开启缓存请设置一个目录路径。</li>
<li>workerCount：开启几个子进程去并发的执行压缩。默认是当前运行电脑的 CPU 核数减去1。</li>
<li>sourceMap：是否为压缩后的代码生成对应的Source Map, 默认不生成，开启后耗时会大大增加，一般不会将压缩后的代码的</li>
<li>sourceMap发送给网站用户的浏览器。</li>
<li>uglifyJS：用于压缩 ES5 代码时的配置，Object 类型，直接透传给 UglifyJS 的参数。</li>
<li>uglifyES：用于压缩 ES6 代码时的配置，Object 类型，直接透传给 UglifyES 的参数。</li>
</ul>
</li>
</ul>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 ParallelUglifyPlugin 插件</span></span><br><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">'webpack-parallel-uglify-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 使用 ParallelUglifyPlugin 并行压缩输出JS代码</span></span><br><span class="line">        <span class="keyword">new</span> ParallelUglifyPlugin(&#123;</span><br><span class="line">            <span class="comment">// 传递给 UglifyJS的参数如下：</span></span><br><span class="line">            uglifyJS: &#123;</span><br><span class="line">                output: &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     是否输出可读性较强的代码，即会保留空格和制表符，默认为输出，为了达到更好的压缩效果，</span></span><br><span class="line"><span class="comment">                     可以设置为false</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    beautify: <span class="literal">false</span>,</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     是否保留代码中的注释，默认为保留，为了达到更好的压缩效果，可以设置为false</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    comments: <span class="literal">false</span></span><br><span class="line">                &#125;,</span><br><span class="line">                compress: &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     是否在UglifyJS删除没有用到的代码时输出警告信息，默认为输出，可以设置为false关闭这些作用</span></span><br><span class="line"><span class="comment">                     不大的警告</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    warnings: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     是否删除代码中所有的console语句，默认为不删除，开启后，会删除所有的console语句</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    drop_console: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     是否内嵌虽然已经定义了，但是只用到一次的变量，比如将 var x = 1; y = x, 转换成 y = 5, 默认为不</span></span><br><span class="line"><span class="comment">                     转换，为了达到更好的压缩效果，可以设置为false</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    collapse_vars: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     是否提取出现了多次但是没有定义成变量去引用的静态值，比如将 x = 'xxx'; y = 'xxx'  转换成</span></span><br><span class="line"><span class="comment">                     var a = 'xxxx'; x = a; y = a; 默认为不转换，为了达到更好的压缩效果，可以设置为false</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    reduce_vars: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="uglifyjs-webpack-plugin-开启-parallel-参数"><a href="#uglifyjs-webpack-plugin-开启-parallel-参数" class="headerlink" title="uglifyjs-webpack-plugin 开启 parallel 参数"></a>uglifyjs-webpack-plugin 开启 parallel 参数</h2><ul>
<li><p>不支持ES6语法</p>
</li>
<li><p>代码演示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">                parallel: <span class="literal">true</span>,<span class="comment">//开启多进程</span></span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="terser-webpack-plugin-开启-parallel-参数"><a href="#terser-webpack-plugin-开启-parallel-参数" class="headerlink" title="terser-webpack-plugin 开启 parallel 参数"></a>terser-webpack-plugin 开启 parallel 参数</h2><ul>
<li><p>代码演示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">                parallel: <span class="literal">true</span>,</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程/多实例构建</title>
    <url>/2019-10-17/webpack/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="资源并行解析可选方案"><a href="#资源并行解析可选方案" class="headerlink" title="资源并行解析可选方案"></a>资源并行解析可选方案</h2><ul>
<li><a href="https://github.com/amireh/happypack" target="_blank" rel="noopener">HappyPack</a></li>
<li><a href="https://github.com/webpack-contrib/thread-loader" target="_blank" rel="noopener">thread-loader</a>：推荐使用</li>
<li><a href="https://github.com/trivago/parallel-webpack" target="_blank" rel="noopener">parallel-webpack</a></li>
</ul><h2 id="多进程-多实例：使用-HappyPack-解析资源"><a href="#多进程-多实例：使用-HappyPack-解析资源" class="headerlink" title="多进程/多实例：使用 HappyPack 解析资源"></a>多进程/多实例：使用 HappyPack 解析资源</h2><ul>
<li><p>原理：</p>
<ul>
<li>每次 webapck 解析一个模块，HappyPack 会将它及它的依赖分配给 worker 线程中</li>
</ul>
</li>
<li><p>代码演示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.plugins = [</span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'jsx'</span>,</span><br><span class="line">    threads: <span class="number">4</span>,</span><br><span class="line">    loaders: [ <span class="string">'babel-loader'</span> ]</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'styles'</span>,</span><br><span class="line">    threads: <span class="number">2</span>,</span><br><span class="line">    loaders: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span> ]</span><br><span class="line">  &#125;)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">exports.module.rules = [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use: <span class="string">'happypack/loader?id=jsx'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: <span class="string">'happypack/loader?id=styles'</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>工作流程：webpack compiler run方法执行后，到达HappyPack。HappyPack会做一些初始化，初始化工作之后，会创建一个线程池。线程池可能包括多个线程。线程池会将构建任务里面的模块进行分配。线程池里面的线程会去各自处理模块以及相关依赖，处理完成之后，会有一个通信的过程。会将处理好的资源传输给HappyPack的主进程。完成整个构建的过程。</p>
<p><img src="/images/26.png" alt="工作流程"></p>
</li>
<li><p><a href="https://github.com/amireh/happypack" target="_blank" rel="noopener">了解更多</a></p>
</li>
</ul><a id="more"></a>

<h2 id="多进程-多实例：使用-thread-loader-解析资源"><a href="#多进程-多实例：使用-thread-loader-解析资源" class="headerlink" title="多进程/多实例：使用 thread-loader 解析资源"></a>多进程/多实例：使用 thread-loader 解析资源</h2><ul>
<li><p>原理：</p>
<ul>
<li>每次 webpack 解析一个模块，thread-loader 会将它及它的依赖分配给 worker 线程中</li>
<li>把这个 loader 放置在其他 loader 之前， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行</li>
</ul>
</li>
<li><p>在 worker 池(worker pool)中运行的 loader 是受到限制的。例如：</p>
<ul>
<li>这些 loader 不能产生新的文件。</li>
<li>这些 loader 不能使用定制的 loader API（也就是说，通过插件）。</li>
<li>这些 loader 无法获取 webpack 的选项设置。</li>
</ul>
</li>
<li><p>每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。</p>
</li>
<li><p>请仅在耗时的 loader 上使用</p>
</li>
<li><p>代码演示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        include: path.resolve(<span class="string">"src"</span>),</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">"thread-loader"</span>,</span><br><span class="line">          <span class="comment">// your expensive loader (e.g babel-loader)</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.webpackjs.com/loaders/thread-loader/" target="_blank" rel="noopener">了解更多</a></p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用高版本的webpack和Node.js</title>
    <url>/2019-10-17/webpack/%E4%BD%BF%E7%94%A8%E9%AB%98%E7%89%88%E6%9C%AC%E7%9A%84webpack%E5%92%8CNode-js/</url>
    <content><![CDATA[<h2 id="使用高版本的webpack和Node-js"><a href="#使用高版本的webpack和Node-js" class="headerlink" title="使用高版本的webpack和Node.js"></a>使用高版本的webpack和Node.js</h2><ul>
<li>V8 带来的优化（for of 替代 forEach、Map 和 Set 替代 Object、includes 替代 indexOf）</li>
<li>默认使用更快的 md4 hash 算法，替代md5 hash</li>
<li>webpacks AST 可以直接从 loader 传递给 AST，减少解析时间</li>
<li>使用字符串方法替代正则表达式</li>
<li>可以从webpack<a href="https://github.com/webpack/webpack/releases" target="_blank" rel="noopener">版本日志</a>，了解做了哪些性能优化</li>
</ul><a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>体积分析：使用webpack-bundle-analyzer</title>
    <url>/2019-10-17/webpack/%E4%BD%93%E7%A7%AF%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%BF%E7%94%A8webpack-bundle-analyzer/</url>
    <content><![CDATA[<h2 id="体积分析：使用webpack-bundle-analyzer"><a href="#体积分析：使用webpack-bundle-analyzer" class="headerlink" title="体积分析：使用webpack-bundle-analyzer"></a>体积分析：使用webpack-bundle-analyzer</h2><ul>
<li><p>代码示例：构建完成后会在 8888 端口展示大小</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">了解更多</a></p>
</li>
</ul><a id="more"></a>
<h2 id="可以分析哪些问题？"><a href="#可以分析哪些问题？" class="headerlink" title="可以分析哪些问题？"></a>可以分析哪些问题？</h2><ul>
<li>依赖的第三方模块文件大小</li>
<li>业务里面的组件代码大小</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>速度分析：使用speed-measure-webpack-plugin</title>
    <url>/2019-10-17/webpack/%E9%80%9F%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%BF%E7%94%A8speed-measure-webpack-plugin/</url>
    <content><![CDATA[<h2 id="速度分析：使用speed-measure-webpack-plugin"><a href="#速度分析：使用speed-measure-webpack-plugin" class="headerlink" title="速度分析：使用speed-measure-webpack-plugin"></a>速度分析：使用speed-measure-webpack-plugin</h2><ul>
<li><p>使用：将默认配置文件包裹起来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SpeedMeasurePlugin = <span class="built_in">require</span>(<span class="string">"speed-measure-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasurePlugin();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将默认的webpack配置文件包裹起来</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MyPlugin(),</span><br><span class="line">    <span class="keyword">new</span> MyOtherPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://github.com/stephencookdev/speed-measure-webpack-plugin" target="_blank" rel="noopener">了解更多</a></p>
</li>
</ul><a id="more"></a>
<h2 id="速度分析插件作用"><a href="#速度分析插件作用" class="headerlink" title="速度分析插件作用"></a>速度分析插件作用</h2><ul>
<li>分析整个打包总耗时</li>
<li>每个插件和loader的耗时情况</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>初级分析：使用webpack内置的stats</title>
    <url>/2019-10-17/webpack/%E5%88%9D%E7%BA%A7%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%BF%E7%94%A8webpack%E5%86%85%E7%BD%AE%E7%9A%84stats/</url>
    <content><![CDATA[<h2 id="使用webpack内置的stats"><a href="#使用webpack内置的stats" class="headerlink" title="使用webpack内置的stats"></a>使用webpack内置的stats</h2><ul>
<li>stats: 构建的统计信息</li>
</ul><h2 id="package-json-中使用-stats"><a href="#package-json-中使用-stats" class="headerlink" title="package.json 中使用 stats"></a>package.json 中使用 stats</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build:stats&quot;: &quot;webpack --config webpack.prod.js --json &gt; stats.json&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><a id="more"></a>
  

<h2 id="Node-js-中使用"><a href="#Node-js-中使用" class="headerlink" title="Node.js 中使用"></a>Node.js 中使用</h2><p><img src="/images/23.png" alt="Node.js 中使用"></p>
<h2 id="上面的方法存在的问题"><a href="#上面的方法存在的问题" class="headerlink" title="上面的方法存在的问题"></a>上面的方法存在的问题</h2><p><img src="/images/24.png" alt="存在的问题"></p>
<ul>
<li>颗粒度太粗, 看不出问题所在</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 性能优化</title>
    <url>/2019-10-17/webpack/Webpack-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="webpack-的性能瓶颈"><a href="#webpack-的性能瓶颈" class="headerlink" title="webpack 的性能瓶颈"></a>webpack 的性能瓶颈</h2><p>webpack 的优化瓶颈，主要是两个方面：</p>
<ul>
<li>webpack 的构建过程太花时间</li>
<li>webpack 打包的结果体积太大</li>
</ul>
<h2 id="webpack构建速度和体积优化策略"><a href="#webpack构建速度和体积优化策略" class="headerlink" title="webpack构建速度和体积优化策略"></a>webpack构建速度和体积优化策略</h2><ul>
<li><a href="/2019-10-17/webpack/初级分析：使用webpack内置的stats">01 | 初级分析：使用webpack内置的stats</a></li>
<li><a href="/2019-10-17/webpack/速度分析：使用speed-measure-webpack-plugin">02 | 速度分析：使用speed-measure-webpack-plugin</a></li>
<li><a href="/2019-10-17/webpack/体积分析：使用webpack-bundle-analyzer">03 | 体积分析：使用webpack-bundle-analyzer</a></li>
<li><a href="/2019-10-17/webpack/使用高版本的webpack和Node-js">04 | 使用高版本的webpack和Node.js</a></li>
<li><a href="/2019-10-17/webpack/多进程-多实例构建">05 | 多进程/多实例构建</a></li>
<li><a href="/2019-10-17/webpack/多进程并行压缩代码">06 | 多进程并行压缩代码</a></li>
<li><a href="/2019-10-17/webpack/进一步分包：预编译资源模块-使用-DLLPlugin-进行分包">07 | 进一步分包：预编译资源模块 使用 DLLPlugin 进行分包</a></li>
<li><a href="/2019-10-17/webpack/充分利用缓存提升二次构建速度">08 | 充分利用缓存提升二次构建速度</a></li>
<li><a href="/2019-10-17/webpack/缩小构建目标">09 | 缩小构建目标</a></li>
<li><a href="/2019-10-17/webpack/使用Tree-Shaking擦除无用的JavaScript和CSS">10 | 使用Tree Shaking擦除无用的JavaScript和CSS</a></li>
<li><a href="/2019-10-17/webpack/使用webpack进行图片压缩">11 | 使用webpack进行图片压缩</a></li>
<li><a href="/2019-10-17/webpack/使用动态Polyfill服务">12 | 使用动态Polyfill服务</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS Prefetch</title>
    <url>/2019-10-17/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/DNS-Prefetch/</url>
    <content><![CDATA[<p><strong><em>DNS(Domain Name System)</em></strong>，翻译为域名解析系统，是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p><p>围绕DNS可做的性能优化非常的多，比如大家所熟知的全局负载均衡(GSLB)，用户可以访问到离自己最近服务器，从而获得最优的访问体验，这项优化更多需要服务端去完成。前端主要关注 <strong><em>DNS Prefetch</em></strong>。</p><a id="more"></a>

<h2 id="DNS-Prefetch原理"><a href="#DNS-Prefetch原理" class="headerlink" title="DNS Prefetch原理"></a>DNS Prefetch原理</h2><p>当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址。</p>
<p>DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度。</p>
<p>如果页面之前访问了，我们可以从浏览器的DNS缓存当中直接读取。减少了解析时间，以及请求次数。</p>
<p>打开DNS Prefetch之后，浏览器会在空闲时间提前将这些域名转化为对应的IP地址，这里为了防止DNS Prefetch阻塞页面渲染影响用户体验，Chrome浏览器的引擎并没有使用它的网络堆栈去进行预解析，而是单独开了8个完全异步的Worker线程专门负责DNS Prefetch。所以很多人认为的DNS Prefetch会影响首屏加载其实是错误的，两者并没有任何关系，所以我们可以大胆放心的使用DNS Prefetch。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="浏览器自动解析"><a href="#浏览器自动解析" class="headerlink" title="浏览器自动解析"></a>浏览器自动解析</h3><p>浏览器引擎在解析HTML页面的时候，会自动获取当前页面所有的a标签herf属性当中的域名，然后进行 <strong><em>DNS Prefetch</em></strong>。这个解析过程是与用户浏览网页并行处理的。但是为了确保安全性，在HTTPS页面中没有开启 <strong><em>DNS Prefetch</em></strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 开启DNS Prefetch</span><br><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</span><br><span class="line"></span><br><span class="line">// 关闭DNS Prefetch</span><br><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="手动解析"><a href="#手动解析" class="headerlink" title="手动解析"></a>手动解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//jkfhto.github.io&quot;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DNS Prefetch解析后的域名对应关系会缓存到本地，一般本地缓存的数量为50~200个</span><br></pre></td></tr></table></figure>

<h2 id="正确的使用姿势"><a href="#正确的使用姿势" class="headerlink" title="正确的使用姿势"></a>正确的使用姿势</h2><ul>
<li>在整个站点的入口声明DNS预解析。通过在站点入口声明了后续其他子页面和子站点可能会访问的域名，浏览器提前进行了DNS预解析。这样用户在访问其他子站点的时候将会间接受益于入口的预解析，降低了DNS lookup所消耗的时间。</li>
<li>根据实际情况配置当前页面的DNS预解析。声明后续操作可能会用到的域名，如发送的异步请求、动态加载图片等等。</li>
<li>并不是DNS prefetch设置的越多越好，虽然是异步线程，实际上还是占用设备的带宽，造成资源竞争。</li>
<li>借助开发者工具，对静态资源域名做手动dns prefetching。</li>
<li>如果是HTTPS网页，考虑是否需要对超链接自动解析，如果需要，添加对应的meta标签。</li>
<li>检查js中发起的跳转至其他域名的情况，对于这些域名，做手动dns prefetching。</li>
<li>对重定向跳转的新域名做手动dns prefetching。比如：页面上有个A域名的链接，但访问A会重定向到B域名的链接，这么在当前页对B域名做手动dns prefetching是有意义的。</li>
</ul>
<h2 id="解决的问题及收益"><a href="#解决的问题及收益" class="headerlink" title="解决的问题及收益"></a>解决的问题及收益</h2><p>DNS Prefetch有效缩短了DNS的解析时间。</p>
<p>如果浏览器最近将一个域名解析为IP地址，所属的操作系统将会缓存，下一次DNS解析时间可以低至0-1ms。 如果结果不在系统本地缓存，则需要读取路由器的缓存，则解析时间的最小值大约为15ms。如果路由器缓存也不存在，则需要读取ISP（运营商）DNS缓存，一般像taobao.com、baidu.com这些常见的域名，读取ISP（运营商）DNS缓存需要的时间在80-120ms，如果是不常见的域名，平均需要200-300ms。一般的网站在运营商这里都能查询的到，所以普遍来说DNS Prefetch可以给一个域名的DNS解析过程带来15-300ms的提升，尤其是一些大量引用很多其他域名资源的网站，提升效果就更加明显了。<br>Chromium对底层缓存进行了建模，当Chrome浏览器启动的时候，就会自动的快速解析浏览器最近一次启动时记录的前10个域名。所以你经常访问的网址就没有DNS解析的延迟，打开速度更快。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://github.com/barretlee/performance-column/issues/3" target="_blank" rel="noopener">性能优化之 DNS Prefetch</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化工具-LightHouse</title>
    <url>/2019-10-17/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7-LightHouse/</url>
    <content><![CDATA[<p>Performance可以给我们提供非常多的信息，但Performance不够直观，需要开发者透过表面的这些参数去分析背后的性能问题。有了这个诉求之后，另一个性能优化工具就出现了，它就是LightHouse。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LightHouse 是 Google 开源的一个自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 当为 Lighthouse 提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。可以参考失败的测试，看看可以采取哪些措施来改进应用。</p><a id="more"></a>

<h2 id="三种使用方式"><a href="#三种使用方式" class="headerlink" title="三种使用方式"></a>三种使用方式</h2><p>可以到谷歌应用商店安装LightHouse，点击添加至Chrome即可。</p>
<p>如果浏览器版本较新的话，可以直接打开 Chrome 开发者工具 (F12)，然后打开 Audits 面板即可。Audits面板集成了 LightHouse 功能，我们可以根据自己的需要，选择对应的限制条件，运行 Run audits，如下图：</p>
<p><img src="/images/LightHouse1.png" alt="LightHouse1"></p>
<p>作为命令行工具运行，命令行工具允许您将 <a href="https://github.com/GoogleChrome/lighthouse" target="_blank" rel="noopener">Lighthouse</a> 集成到持续集成系统。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局安装 lighthouse</span></span><br><span class="line">npm install -g lighthouse</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后输入你的页面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行支持导出HTML格式和JSON格式，我们使用如下命令分别导出：</span></span><br><span class="line"><span class="comment">//导出JSON格式</span></span><br><span class="line">lighthouse https:<span class="comment">//www.imooc.com/  --output json  </span></span><br><span class="line"><span class="comment">//导出HTML格式</span></span><br><span class="line">lighthouse https:<span class="comment">//www.imooc.com/  --output html</span></span><br></pre></td></tr></table></figure>

<h2 id="自动化部分"><a href="#自动化部分" class="headerlink" title="自动化部分"></a>自动化部分</h2><p>可以利用 TravisCI 来自动分析修改后的代码的页面性能。</p>
<p>你只需要在 .travis.yml 里面加入以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">script:</span><br><span class="line">  - npm run lint</span><br><span class="line">  - npm run build</span><br><span class="line">after_success:</span><br><span class="line">  - .<span class="string">"./travis/deploy_pr_gae.sh"</span></span><br><span class="line">  - <span class="keyword">export</span> LH_MIN_PASS_SCORE=<span class="number">96</span></span><br><span class="line">  - <span class="keyword">export</span> LH_TEST_URL=https:<span class="comment">//your.staging.server.com/</span></span><br><span class="line">  - node travis/runlighthouse.js $LH_TEST_URL $LH_MIN_PASS_SCORE</span><br></pre></td></tr></table></figure>

<p>更多详情: <a href="https://github.com/GoogleChromeLabs/lighthousebot" target="_blank" rel="noopener">ebidel/lighthouse-ci</a></p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>以本站为例，使用 <strong><em>chrome lighthouse</em></strong>生成性能优化测试的报告，直接点击Generate report，然后LightHouse就会自动帮我们生成性能优化报告，如下图：</p>
<p><img src="/images/LightHouse2.png" alt="LightHouse2"></p>
<p>性能优化测试的报告主要包括，Performance(页面性能)、Accessibility(可访性)、Best Practise(最佳实践)、SEO(搜索引擎优化)、Progressive Web App(渐进式应用)。我们点击其中的每一项都可以看到给出的具体优化建议，这里我们以Performance为例，如下图：</p>
<p><img src="/images/LightHouse3.png" alt="LightHouse3"></p>
<p>以第一项为例，点击展开可看到更加详细的信息，如下图：</p>
<p><img src="/images/LightHouse4.png" alt="LightHouse4"></p>
<p>这里推荐我们使用下一代图片格式化的技术，原因是JPEG 2000、JPEG XR和WebP等图像格式通常比PNG或JPEG提供更好的压缩，这意味着更快的下载速度和更少的数据消耗。下面还展示了需要替换的图片资源。点击 <strong><em>Learn more</em></strong>，可以跳转到指定的帮助文档。</p>
<h2 id="相关的性能优化工具"><a href="#相关的性能优化工具" class="headerlink" title="相关的性能优化工具"></a>相关的性能优化工具</h2><ul>
<li><strong><a href="https://github.com/treosh/exthouse" target="_blank" rel="noopener">Exthouse</a></strong> - Analyze the impact of a browser extension on web performance.</li>
<li><strong><a href="https://github.com/boyney123/garie" target="_blank" rel="noopener">Garie</a></strong> - An open source tool for monitoring performance using Lighthouse,  PageSpeed Insights, <a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a>, <a href="https://grafana.com/" target="_blank" rel="noopener">Grafana</a> and <a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a>.</li>
<li><strong><a href="https://labs.moduscreate.com/gimbal-web-performance-audit-budgeting" target="_blank" rel="noopener">Gimbal</a></strong> - An <a href="https://github.com/ModusCreateOrg/gimbal" target="_blank" rel="noopener">open source (MIT licensed)</a> tool used to measure, analyze, and budget aspects of a web application. Gimbal also integrates reports with GitHub pull requests.</li>
<li><strong><a href="https://github.com/Cognifide/gradle-lighthouse-plugin" target="_blank" rel="noopener">Gradle Lighthouse Plugin</a></strong> - An open source Gradle plugin that runs Lighthouse tests on multiple URLs and asserts category score thresholds (useful in continuous integration).</li>
<li><strong><a href="https://github.com/github/lightcrawler" target="_blank" rel="noopener">lightcrawler</a></strong> - Crawl a website and run each page found through Lighthouse.</li>
<li><strong><a href="https://github.com/emazzotta/lighthouse-badges" target="_blank" rel="noopener">lighthouse-badges</a></strong> - Generate gh-badges (shields.io) based on Lighthouse performance.</li>
<li><strong><a href="https://www.npmjs.com/package/lighthouse-batch" target="_blank" rel="noopener">lighthouse-batch</a></strong> - Run Lighthouse over a number of sites and generate a summary of their metrics/scores.</li>
<li><strong><a href="https://github.com/foo-software/lighthouse-check-action" target="_blank" rel="noopener">lighthouse-check-action</a></strong> - A Github Action to run Lighthouse in a workflow, featuring Slack notifications and report upload to S3.</li>
<li><strong><a href="https://circleci.com/orbs/registry/orb/foo-software/lighthouse-check" target="_blank" rel="noopener">lighthouse-check-orb</a></strong> - A CircleCI Orb to run Lighthouse in a workflow, featuring Slack notifications and report upload to S3.</li>
<li><strong><a href="https://github.com/andreasonny83/lighthouse-ci" target="_blank" rel="noopener">lighthouse-ci</a></strong> - Run Lighthouse and assert scores satisfy your custom thresholds.</li>
<li><strong><a href="https://github.com/treosh/lighthouse-ci-action" target="_blank" rel="noopener">lighthouse-ci-action</a></strong> - A Github Action that makes it easy to run Lighthouse in CI and keep your pages small using performance budgets.</li>
<li><strong><a href="https://github.com/thearegee/lighthouse-cron" target="_blank" rel="noopener">lighthouse-cron</a></strong> - Cron multiple batch Lighthouse audits and emit results for sending to remote server.</li>
<li><strong><a href="https://github.com/carlesnunez/lighthouse-gh-reporter" target="_blank" rel="noopener">lighthouse-gh-reporter</a></strong> - Run Lighthouse in CI and report back in a comment on your pull requests</li>
<li><strong><a href="https://github.com/ebidel/lighthouse-hue" target="_blank" rel="noopener">lighthouse-hue</a></strong> - Set the color of Philips Hue lights based on a Lighthouse score</li>
<li><strong><a href="https://github.com/justinribeiro/lighthouse-jest-example" target="_blank" rel="noopener">lighthouse-jest-example</a></strong> - Gather performance metrics via Lighthouse and assert results with Jest; uses Puppeteer to start Chrome with network emulation settings defined by WebPageTest.</li>
<li><strong><a href="https://github.com/joytocode/lighthouse-lambda" target="_blank" rel="noopener">lighthouse-lambda</a></strong> - Run Lighthouse on AWS Lambda with prebuilt stable desktop Headless Chrome.</li>
<li><strong><a href="https://github.com/manekinekko/lighthouse-magic-light" target="_blank" rel="noopener">lighthouse-magic-light</a></strong> - Set the color of the MagicLight Bluetooth Smart Light Bulb based on Lighthouse score</li>
<li><strong><a href="https://github.com/rishichawda/lighthouse-mocha-example" target="_blank" rel="noopener">lighthouse-mocha-example</a></strong> - Run Lighthouse performance tests with Mocha and chrome-launcher.</li>
<li><strong><a href="https://github.com/verivox/lighthouse-monitor" target="_blank" rel="noopener">lighthouse-monitor</a></strong> - Run Lighthouse against all your URLs. Send metrics to any backend you want, save all reports with automatic data retention, and compare any two results in a web UI.</li>
<li><strong><a href="https://github.com/foo-software/lighthouse-persist" target="_blank" rel="noopener">lighthouse-persist</a></strong> - Run Lighthouse and upload HTML reports to an AWS S3 bucket.</li>
<li><strong><a href="https://github.com/godaddy/lighthouse4u" target="_blank" rel="noopener">lighthouse4u</a></strong> - LH4U provides Google Lighthouse as a service, surfaced by both a friendly UI+API, and backed by Elastic Search for easy querying and visualization.</li>
<li><strong><a href="https://performance-budgets.netlify.com/" target="_blank" rel="noopener">performance-budgets</a></strong> - Easily assert Lighthouse budgets with Docker.</li>
<li><strong><a href="https://github.com/paulirish/pwmetrics/" target="_blank" rel="noopener">pwmetrics</a></strong> - Gather performance metrics</li>
<li><strong><a href="https://www.npmjs.com/package/react-lighthouse-viewer" target="_blank" rel="noopener">react-lighthouse-viewer</a></strong> - Render a Lighthouse JSON report in a React Component.</li>
<li><strong><a href="https://github.com/addyosmani/webpack-lighthouse-plugin" target="_blank" rel="noopener">webpack-lighthouse-plugin</a></strong> - Run Lighthouse from a Webpack build.</li>
</ul>
<p><a href="https://github.com/GoogleChrome/lighthouse" target="_blank" rel="noopener">了解更多</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://juejin.im/post/5ba73d1de51d450e551a0d08" target="_blank" rel="noopener">网站性能调优开发工具: Lighthouse, Puppeteer 以及进阶部分丨 Google 开发者大会 2018</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化工具-浏览器performance面板</title>
    <url>/2019-10-16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7-%E6%B5%8F%E8%A7%88%E5%99%A8performance%E9%9D%A2%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.首先我们需要打开新的无痕窗口，进入隐身模式，可以保证Chrome在一个相对干净的环境下运行。这里是为了避免相关的浏览器插件带来的干扰，这些插件可能会影响我们分析性能表现。使用快捷键 <strong><em>ctrl + shift + N</em></strong> 即可打开chrome新的无痕窗口</p><p><img src="/images/performance%E9%9D%A2%E6%9D%BF1.jpg" alt="performance面板1"></p><p>2.按F12进入开发者工具，打开performance面板。</p><a id="more"></a>


<p>3.点击最左侧的黑色圆就可以开始一个新的监测记录，也可以点击刷新按钮记录整个刷新过程中的监测记录。然后右侧我们如果勾选了Screenshots，就可以记录整个监测过程中每一帧的截图。如果勾选了Memory，我们就可以看到内存的详细使用情况以及垃圾回收的周期，也可以观察到内存有无泄漏的情况。</p>
<p>4.点击最右侧的小齿轮，可以看到一些配置项，打开CPU的节流开关，可以模拟移动端项目。打开Network的节流开关，我们模拟弱网(2g/3g)条件下网站的一些表现情况，然后根据弱网的具体表现进行相关优化。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>我们打开performance面板之后，然后点击刷新按钮，就可以看到页面加载过程中的性能表现：</p>
<p><img src="/images/performance%E9%9D%A2%E6%9D%BF2.png" alt="performance面板2"></p>
<p>其从上到下是：</p>
<ul>
<li>工具栏</li>
<li>FPS图表</li>
<li>CPU图表</li>
<li>NET图表</li>
<li>HEAP图标</li>
<li>Network图表</li>
<li>Frames图表</li>
<li>Timings</li>
<li>Main图表</li>
<li>Raster图表</li>
<li>GPU图表</li>
<li>Summary面板</li>
<li>等…</li>
</ul>
<h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p>开始记录，停止记录和配置记录期间捕获的信息。</p>
<p><img src="/images/performance%E9%9D%A2%E6%9D%BF4.png" alt="performance面板4"></p>
<h3 id="FPS，CPU，NET，HEAP"><a href="#FPS，CPU，NET，HEAP" class="headerlink" title="FPS，CPU，NET，HEAP"></a>FPS，CPU，NET，HEAP</h3><p><img src="/images/performance%E9%9D%A2%E6%9D%BF3.png" alt="performance面板3"></p>
<ul>
<li><p>FPS：这个指标是衡量动画是否流畅的一个重要指标。图中的绿色柱状图很高，这就代表FPS帧率很高，体验也就越流畅，如果FPS帧率较低，那么图中则会是红色的横条，表明帧率较低，影响用户体验。当帧率不影响使用的时候横条是不会出现的。</p>
</li>
<li><p>CPU：CPU自然就是展示CPU的使用情况。这个指标和下面的Sumarry指标是一一对应，而且这里它们的颜色所代表含义也是相同的，每个颜色代表各个过程所耗费的时间。从图中我们可以看到，整个加载过程中，白色部分(ldle)占比是最大的，这里代表的是空闲性能，第二大占比的橙色对应的是脚本加载时间，我们可以试着从加快脚本加载速度方面去优化页面。</p>
</li>
<li><p>NET：这个是展示各个请求所花费的具体时间，这里看不太清，我们可以直接去 Network 面板当中去具体观察各个请求所花费的时间，然后针对具体的请求具体分析。</p>
</li>
<li><p>HEAP：这里展示的是请求过程中内存的使用情况，这个指标对性能优化帮助不大。</p>
<p>左右移动鼠标，就可以看到各个时间点的截图，这在分析动画执行的各个阶段，以及了loading的各个阶段的时候尤其有用.</p>
</li>
</ul>
<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><p><img src="/images/performance%E9%9D%A2%E6%9D%BF5.png" alt="performance面板5"></p>
<p>代表主线程， 一段横条代表执行一个事件(函数)，长度越长，花费的时间越多; 竖向代表调用栈。在栈里，上面的事件调用了下面的事件。如果在这些横条中右上角是红色的，就表示在该段代码执行过程中可能存在性能问题。</p>
<p>图中各种颜色的矩形代表加载过程中做的所有工作。调用堆栈就像是浏览器当中的解释器，我们可以利用它追踪函数的执行流。当浏览器中调用了多个函数，通过这种机制可以追踪到哪个函数正在执行，具体函数体中又调用了哪个函数。这里我们点击一个右上角是红色的矩形，如下图：</p>
<p><img src="/images/performance%E9%9D%A2%E6%9D%BF6.jpg" alt="performance面板6"></p>
<p>点击之后我们看到了这个事件下对应的一些具体信息，这里我们还可以点击Range右侧链接，点击之后会直接跳到sources面板对应的代码位置，这个功能可以说大大方便了我们定位具体的代码，根据定位到的代码段，阅读代码我们可以分析，优化性能。如下图：</p>
<p><img src="/images/performance%E9%9D%A2%E6%9D%BF7.jpg" alt="performance面板7"></p>
<h3 id="Summary面板"><a href="#Summary面板" class="headerlink" title="Summary面板"></a>Summary面板</h3><p>HTML 文件为蓝色。<br>脚本为黄色。<br>样式表为紫色。<br>媒体文件为绿色。<br>其他资源为灰色。</p>
<h3 id="Bottom-Up"><a href="#Bottom-Up" class="headerlink" title="Bottom-Up"></a>Bottom-Up</h3><p>代表调用堆栈的前后调用关系，展示浏览器执行的各个操作所占用的时间</p>
<ul>
<li>self-time 指除去子操作这个操作本身消耗的时间</li>
<li>total-time 这个操作从开始到结束消耗的时间（包含子事件）</li>
</ul>
<h3 id="Call-Tree"><a href="#Call-Tree" class="headerlink" title="Call Tree"></a>Call Tree</h3><p>调用树。Call Tree与Main中的事件一一对应。可以看到整个事件的调用栈（从最顶层到最底层）</p>
<h3 id="Event-Log"><a href="#Event-Log" class="headerlink" title="Event Log"></a>Event Log</h3><p>事件日志</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" target="_blank" rel="noopener">Get Started With Analyzing Runtime Performance</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化衡量指标</title>
    <url>/2019-10-16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h2 id="Performance-API"><a href="#Performance-API" class="headerlink" title="Performance API"></a>Performance API</h2><p>这个 API 是 HTML5 新增的特性。过去我们要统计脚本的运行时间，会使用 Date.getTime() 去获取对应的时间；如果要获取白屏时间是在 head 末尾插入一段获取时间戳的代码，然后用这个时间戳减去开始接收数据的那个时间戳，得出的结果为白屏时间。这样的方法无疑是笨重的，而且获取的时间无法更精确(只能到ms级别)，而且一些后台比较关注的时间根本无法获取。W3C 为了解决这个问题，在 HTML5 推出的时候，新增了这个 API 。</p><a id="more"></a>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">Performance</a> 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API" target="_blank" rel="noopener">Navigation Timing API</a>、 <a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API" target="_blank" rel="noopener">User Timing API</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API" target="_blank" rel="noopener">Resource Timing API</a>。该类型的对象可以通过调用只读属性 Window.performance 来获得。</p>
<p>在控制台输入window.performance，能够获取到相关信息，如下图：</p>
<p><img src="/images/Performance1.png" alt="Performance1"></p>
<p><strong><em>performance</em></strong> 包括了五个属性，其中 <strong><em>timing</em></strong> 是我们需要重点关注的，<strong><em>timing</em></strong> 是一个对象，其中key值是性能优化指标，value值是对应的时间戳。其中这些时间戳与页面整个加载过程中的关键节点是有着一一对应的关系。</p>
<p><img src="/images/Performance2.jpg" alt="Performance2"></p>
<p>从图中可以看到很多指标都是成对出现，这里我们直接求差值，就可以求出对应页面加载过程中关键节点的耗时，这里我们介绍几个比较常用的，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timingInfo = <span class="built_in">window</span>.performance.timing;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DNS解析，DNS查询耗时</span></span><br><span class="line">timingInfo.domainLookupEnd - timingInfo.domainLookupStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP连接耗时</span></span><br><span class="line">timingInfo.connectEnd - timingInfo.connectStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得首字节耗费时间，也叫TTFB</span></span><br><span class="line">timingInfo.responseStart - timingInfo.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// domReady时间(与DomContentLoad事件对应)</span></span><br><span class="line">timingInfo.domContentLoadedEventStart - timingInfo.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM资源下载</span></span><br><span class="line">timingInfo.responseEnd - timingInfo.responseStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备新页面时间耗时</span></span><br><span class="line">timingInfo.fetchStart - timingInfo.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向耗时</span></span><br><span class="line">timingInfo.redirectEnd - timingInfo.redirectStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Appcache 耗时</span></span><br><span class="line">timingInfo.domainLookupStart - timingInfo.fetchStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unload 前文档耗时</span></span><br><span class="line">timingInfo.unloadEventEnd - timingInfo.unloadEventStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request请求耗时</span></span><br><span class="line">timingInfo.responseEnd - timingInfo.requestStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求完毕至DOM加载</span></span><br><span class="line">timingInfo.domInteractive - timingInfo.responseEnd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释dom树耗时</span></span><br><span class="line">timingInfo.domComplete - timingInfo.domInteractive;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从开始至load总耗时</span></span><br><span class="line">timingInfo.loadEventEnd - timingInfo.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白屏时间</span></span><br><span class="line">timingInfo.responseStart - timingInfo.fetchStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首屏时间</span></span><br><span class="line">timingInfo.domComplete - timingInfo.fetchStart;</span><br></pre></td></tr></table></figure>

<h2 id="感官性能优化指标"><a href="#感官性能优化指标" class="headerlink" title="感官性能优化指标"></a>感官性能优化指标</h2><p>普通用户感官体验联系更加紧密的一些指标：</p>
<ul>
<li>First Paint(简称FP)：表示文档中任一元素首次渲染时间。用于标记导航之后浏览器在屏幕上渲染像素的时间点。这个不难理解，就是浏览器开始请求网页到网页首帧绘制的时间点。这个指标表明了网页请求是否成功。</li>
<li>First Contentful Paint(简称FCP)：当浏览器首次渲染任何文本，图像（包括背景图像），非白色画布或SVG时。这个指标就是我们日常说的白屏时间。</li>
<li>First Meaningful Paint(简称FMP)：首次有意义的绘制，这个指标反映的是主要内容出现在页面上所需要的时间，如果FMP时间过长的话，这里就要考虑是不是静态文件阻塞了主线程。这是一个很主观的指标。根据业务的不同，每一个网站的有效内容都是不相同的，有效内容就是网页中”主角元素”。</li>
<li>Time To Interactive(TTI):可交互时间，等到服务器通过HTTP协议将响应全部返回之后，便开始DOM Tree 的构建，完成之后，网页变成可交互状态，到此为止便是网页的可交互时间。用户可以进行正常的事件输入交互操作，这个指标是最重要的用户体验指标，用户最关心的就是什么时候可以进行交互，所以通常这个指标是我们优化的重点。</li>
</ul>
<p><img src="/images/Performance3.jpg" alt="感官性能优化指标"></p>
<ul>
<li>我们可以在控制台输入 <strong><em>window.performance.getEntriesByType(‘paint’)</em></strong> 获取，<strong><em>First Paint(简称FP)</em></strong>，<strong><em>First Contentful Paint(简称FCP)</em></strong>。</li>
<li>另外2个指标我们可以通过性能优化工具 <a href="https://github.com/GoogleChrome/lighthouse" target="_blank" rel="noopener">Lighthouse</a> 实时测量进行获取。</li>
</ul>
<p><img src="/images/Performance4.png" alt="感官性能优化指标2"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://github.com/ChenChenJoke/JokerWebFont/tree/master/Performance" target="_blank" rel="noopener">Web性能优化：Performance，数据搜集方法</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化</title>
    <url>/2019-10-16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="什么是前端性能优化"><a href="#什么是前端性能优化" class="headerlink" title="什么是前端性能优化"></a>什么是前端性能优化</h2><p>从用户访问资源到资源完整的展现在用户面前的过程中，通过技术手段和优化策略，缩短每个步骤的处理时间从而提升整个资源的访问和呈现速度。</p><h2 id="为什么要做前端性能优化"><a href="#为什么要做前端性能优化" class="headerlink" title="为什么要做前端性能优化"></a>为什么要做前端性能优化</h2><p>在构建web站点的过程中，任何一个细节都有可能影响网站的访问速度，如果不了解性能优化知识，很多不利网站访问速度的因素会形成累加，从而严重影响网站的性能，导致网站访问速度变慢，用户体验低下，最终导致用户流失。</p><a id="more"></a>

<h2 id="从浏览器发起请求到页面能正常浏览都有哪些阶段"><a href="#从浏览器发起请求到页面能正常浏览都有哪些阶段" class="headerlink" title="从浏览器发起请求到页面能正常浏览都有哪些阶段"></a>从浏览器发起请求到页面能正常浏览都有哪些阶段</h2><ul>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>HTTP 请求抛出</li>
<li>服务端处理请求，HTTP 响应返回</li>
<li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户</li>
</ul>
<p>针对这五个过程进行分解，我们可以将前端性能优化划分为<strong><em>网络层面</em></strong>和<strong><em>渲染层面</em></strong>两个大的维度，并以此来进行扩展，学习。</p>
<h2 id="性能优化的具体方法"><a href="#性能优化的具体方法" class="headerlink" title="性能优化的具体方法"></a>性能优化的具体方法</h2><h3 id="内容层面"><a href="#内容层面" class="headerlink" title="内容层面"></a>内容层面</h3><ul>
<li>1、DNS解析优化（DNS缓存、减少DNS查找、keep-alive、适当的主机域名）</li>
<li>2、避免重定向（/还是需要的）</li>
<li>3、切分到多个域名</li>
<li>4、杜绝404</li>
</ul>
<h3 id="网络传输阶段"><a href="#网络传输阶段" class="headerlink" title="网络传输阶段"></a>网络传输阶段</h3><ul>
<li>1、减少传输过程中实体的大小<ul>
<li>缓存</li>
<li>cookie优化</li>
<li>文件压缩（Accept-Encoding：g-zip）</li>
</ul>
</li>
<li>2、减少请求的次数<ul>
<li>文件适当的合并</li>
<li>雪碧图</li>
</ul>
</li>
<li>3、异步加载（并发）</li>
<li>4、预加载、延后加载、按需加载</li>
</ul>
<h3 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h3><ul>
<li>1、js放底部，css放顶部</li>
<li>2、减少重绘和回流</li>
<li>3、合理使用Viewport 等meta头部</li>
<li>4、减少dom节点</li>
</ul>
<h3 id="脚本执行阶段"><a href="#脚本执行阶段" class="headerlink" title="脚本执行阶段"></a>脚本执行阶段</h3><ul>
<li>1、缓存节点，尽量减少节点的查找</li>
<li>2、减少节点的操作（innerHTML）</li>
<li>3、避免无谓的循环，break、continue、return的适当使用</li>
<li>4、事件委托</li>
</ul>
<h3 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h3><p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//jkfhto.github.io&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>通过长连接、预连接、接入 SPDY 协议。优化TCP连接。</p>
<h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><ul>
<li>减少 HTTP请求数</li>
<li>减小请求体积</li>
</ul>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/grandPang/article/details/51329289" target="_blank" rel="noopener">前端性能优化归纳总结篇</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入 URL 到页面加载完成，发生了什么？</title>
    <url>/2019-10-16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>从前端的角度出发，主要包括以下几个方面：</p><ul>
<li>浏览器的地址栏输入URL并按下回车。</li>
<li>浏览器查找当前URL是否存在缓存，并比较缓存是否过期。</li>
<li>通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址。</li>
<li>然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接（三次握手）。</li>
<li>随后我们向服务端抛出我们的 HTTP 请求。</li>
<li>服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端。</li>
<li>拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作。</li>
<li>关闭TCP连接（四次挥手）。</li>
</ul><a id="more"></a>

<h3 id="三次握手简单说明"><a href="#三次握手简单说明" class="headerlink" title="三次握手简单说明"></a>三次握手简单说明</h3><p> 所谓三次握手（Three-Way Handshake）即建立TCP连接，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。</p>
<ul>
<li>1.客户端–发送带有SYN标志的数据包–一次握手–服务端（客户端：我要连接你了，可以吗？）</li>
<li>2.服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端（服务端：嗯，我准备好了，连接我吧。）</li>
<li>3.客户端–发送带有带有ACK标志的数据包–三次握手–服务端（客户端：那我连接你咯。）</li>
</ul>
<h3 id="四次挥手简单说明"><a href="#四次挥手简单说明" class="headerlink" title="四次挥手简单说明"></a>四次挥手简单说明</h3><ul>
<li>客户端-发送一个FIN，用来关闭客户端到服务器的数据传送（客户端向服务器发送一个断开连接的请求）</li>
<li>服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号（服务器接到请求后发送确认收到请求的信号）</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端（服务器向主机发送断开通知）</li>
<li>客户端-发回ACK报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.iteye.com/blog/uule-2213562" target="_blank" rel="noopener">TCP协议的三次握手和四次挥手</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Event Loop 运行机制</title>
    <url>/2019-10-14/Javascript/Event-Loop-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。</p><h2 id="进程和线程基本概念"><a href="#进程和线程基本概念" class="headerlink" title="进程和线程基本概念"></a>进程和线程基本概念</h2><p>拿出在教科书里的概念：</p><ul>
<li>1、调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li>
<li>2、并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</li>
<li>3、拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源；</li>
<li>4、系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。进程和线程的关系：</li>
</ul><a id="more"></a>


<p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p>
<p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p>
<p>处理机分给线程，即真正在处理机上运行的是线程；</p>
<p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体。</p>
<p>基本总结，一个进程可以有多个线程，线程之间可以相互通信。</p>
<p>进程是 CPU资源分配的最小单位；线程是 CPU调度的最小单位。</p>
<h3 id="图示解析"><a href="#图示解析" class="headerlink" title="图示解析"></a>图示解析</h3><p><img src="/images/EventLoop3.jpg" alt="进程和线程"></p>
<ul>
<li>进程好比图中的工厂，有单独的专属自己的工厂资源。</li>
<li>线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n的关系。也就是说一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>
<li>工厂的空间是工人们共享的，这象征一个进程的内存空间是共享的，每个线程都可用这些共享内存。</li>
<li>多个工厂之间独立存在。</li>
</ul>
<h3 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h3><ul>
<li>多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</li>
<li>多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li>
</ul>
<p>以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p>
<p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p>
<ul>
<li>GUI 渲染线程</li>
<li>JavaScript引擎线程</li>
<li>定时触发器线程</li>
<li>事件触发线程</li>
<li>异步http请求线程</li>
</ul>
<h3 id="1-GUI渲染线程"><a href="#1-GUI渲染线程" class="headerlink" title="1.GUI渲染线程"></a>1.GUI渲染线程</h3><p>主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。<br>当界面需要重绘或者由于某种操作引发回流时，将执行该线程。<br>该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。</p>
<h3 id="2-JS引擎线程"><a href="#2-JS引擎线程" class="headerlink" title="2.JS引擎线程"></a>2.JS引擎线程</h3><p>该线程当然是主要负责处理 JavaScript脚本，执行代码。<br>也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。<br>当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。</p>
<h3 id="3-定时器触发线程"><a href="#3-定时器触发线程" class="headerlink" title="3.定时器触发线程"></a>3.定时器触发线程</h3><p>负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。<br>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。</p>
<h3 id="4-事件触发线程"><a href="#4-事件触发线程" class="headerlink" title="4.事件触发线程"></a>4.事件触发线程</h3><p>主要负责将准备好的事件交给 JS引擎线程执行。</p>
<p>比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。</p>
<h3 id="5-异步http请求线程"><a href="#5-异步http请求线程" class="headerlink" title="5.异步http请求线程"></a>5.异步http请求线程</h3><p>负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。</p>
<p>主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。</p>
<h2 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h2><p>JS 执行是单线程的，意味着 JS 在执行代码的时候一次只能处理一个任务，必须按队列顺序逐个执行。JS 的主要功效是处理前端交互，其中就包括操作 DOM 节点。试想若 JS 是多线程，在处理网页交互时，一个线程需要删除 DOM 节点，另一个线程却是要操作同一个 DOM 节点，这样该如何判断先执行哪个线程？但若队列中存在多个任务，上一个任务的执行会阻塞下一个任务，导致代码执行效率低下。就像 AJAX 请求线程，发出请求后需要等待响应结果，期间 CPU 却是空闲的。对此，JS的事件循环机制（Event Loop）很好地解决了问题。</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里所谓的单线程指的是主线程是单线程的,所以在Node中主线程依旧是单线程的。</span><br></pre></td></tr></table></figure>

<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>JavaScript 将任务分为两种：同步任务和异步任务。</p>
<ul>
<li>同步任务：执行完后能立即得出结果的任务。同步任务在主线程中执行，上一个任务的执行会阻塞下一个任务，在执行过程中产生堆栈。堆中存储复杂数据类型（Object），栈中存储基本数据类型（String、Number、Boolean、Null、Undefined、Symbol）。</li>
<li>异步任务：执行后无法立即得出结果，需要等待一段时间获得相应的任务。其中又分为宏任务（Macrotask）和微任务（Microtask）。<ul>
<li>宏任务：script（整体代码）、setTimeout、setInterval、setImmediate、I/O操作（mouse click、keypress、network event）、UI渲染、requestAnimationTrame等。</li>
<li>微任务：Promise.then、MutationObserver、process.nextTick()等。</li>
</ul>
</li>
</ul>
<h2 id="浏览器-Event-Loop-过程解析"><a href="#浏览器-Event-Loop-过程解析" class="headerlink" title="浏览器 Event Loop 过程解析"></a>浏览器 Event Loop 过程解析</h2><p>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>
<p>JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p>
<p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p>
<ul>
<li><p>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</p>
</li>
<li><p>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</p>
</li>
<li><p>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的（如下图所示）。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</p>
</li>
<li><p>执行渲染操作，更新界面（敲黑板划重点）。</p>
</li>
<li><p>检查是否存在 Web worker 任务，如果有，则对其进行处理 。</p>
</li>
<li><p>上述过程循环往复，直到两个队列都清空</p>
</li>
</ul>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<p>执行过程分析：</p>
<p>全局上下文 <strong><em>（script 标签）</em></strong> 被推入调用栈，同步代码执行。打印 <strong><em>script start</em></strong>，遇到 <strong><em>setTimeout</em></strong>，推入到<strong><em>macro 队列</em></strong>。遇到<strong><em>Promise.resolve().then</em></strong>推入到<strong><em>micro 队列</em></strong>，遇到同步代码。打印 <strong><em>script end</em></strong>。</p>
<p><strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>promise1</em></strong>，遇到 <strong><em>then</em></strong>，推入到<strong><em>macro 队列</em></strong>。<strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>promise2</em></strong>。<strong><em>micro 队列</em></strong> 清空。</p>
<p><strong><em>macro 队列</em></strong> 执行出队列操作，打印 <strong><em>setTimeout</em></strong>，<strong><em>macro 队列</em></strong> 清空。</p>
<h3 id="更复杂的例子"><a href="#更复杂的例子" class="headerlink" title="更复杂的例子"></a>更复杂的例子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="comment">// async2().then(function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log('async1 end')</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise3'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2 end</span></span><br><span class="line"><span class="comment">// Promise1</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// promise3</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<p>执行过程分析：</p>
<p>全局上下文 <strong><em>（script 标签）</em></strong> 被推入调用栈，同步代码执行。打印 <strong><em>script start</em></strong>，遇到 <strong><em>setTimeout</em></strong>，推入到<strong><em>macro 队列</em></strong>。执行 <strong><em>async1</em></strong> ，打印 <strong><em>async1 start</em></strong> 。执行 <strong><em>await async2()</em></strong>，相当于先执行 <strong><em>async2</em></strong> 这个 <strong><em>Promise</em></strong> 函数，打印 <strong><em>async2 end</em></strong>，然后执行 <strong><em>then</em></strong>，<strong><em>micro</em></strong> 任务 <strong><em>console.log(‘async1 end’)</em></strong> 入队列。遇到 <strong><em>new Promise</em></strong>，同步任务，打印 <strong><em>Promise1</em></strong>，执行 <strong><em>resolve()</em></strong>，<strong><em>micro</em></strong> 任务 <strong><em>console.log(‘promise2’)</em></strong> 入队列。遇到同步任务，打印 <strong><em>script end</em></strong>；</p>
<p><strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>async1 end</em></strong>，然后打印 <strong><em>promise2</em></strong>，遇到 <strong><em>then</em></strong>，<strong><em>console.log(‘promise3’)</em></strong>，推入到<strong><em>macro 队列</em></strong>。<strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>promise3</em></strong>。<strong><em>micro 队列</em></strong> 清空。</p>
<p><strong><em>macro 队列</em></strong> 执行出队列操作，打印 <strong><em>setTimeout</em></strong>，<strong><em>macro 队列</em></strong> 清空。</p>
<h2 id="NodeJS-Event-Loop-过程解析"><a href="#NodeJS-Event-Loop-过程解析" class="headerlink" title="NodeJS Event Loop 过程解析"></a>NodeJS Event Loop 过程解析</h2><p><img src="/images/EventLoop.jpg" alt="Event Loop"></p>
<p>Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。</p>
<p><img src="/images/EventLoop2.jpg" alt="Event Loop2"></p>
<h3 id="Node-js的运行机制如下"><a href="#Node-js的运行机制如下" class="headerlink" title="Node.js的运行机制如下:"></a>Node.js的运行机制如下:</h3><ul>
<li>V8引擎解析JavaScript脚本。</li>
<li>解析后的代码，调用Node API。</li>
<li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li>V8引擎再将结果返回给用户。</li>
</ul>
<p>Node的Event loop一共分为6个阶段，每个细节具体如下：</p>
<ul>
<li>timers: 执行setTimeout和setInterval中到期的callback。</li>
<li>pending callback: 执行延迟到下一个循环迭代的 I/O 回调。</li>
<li>idle, prepare: 仅在内部使用。</li>
<li>poll: 最重要的阶段，执行pending callback，检索新的 I/O 事件;执行与 I/O 相关的回调，在适当的情况下回阻塞在这个阶段。</li>
<li>check: 执行setImmediate() 设定的callbacks。</li>
<li>close callbacks: 执行close事件的callback，例如socket.on(‘close’[,fn])或者http.server.on(‘close, fn)。</li>
</ul>
<h3 id="timers"><a href="#timers" class="headerlink" title="timers"></a>timers</h3><p>执行 <strong><em>setTimeout</em></strong> 和 <strong><em>setInterval</em></strong> 中到期的 <strong><em>callback</em></strong>，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行<strong><em>callback</em></strong> 回调，但是由于 <strong><em>system的调度</em></strong> 可能会延时，达不到预期时间。</p>
<h3 id="pending-callbacks"><a href="#pending-callbacks" class="headerlink" title="pending callbacks"></a>pending callbacks</h3><p>此阶段执行某些系统操作的回调，例如TCP错误的类型。 例如，如果TCP套接字在尝试连接时收到ECONNREFUSED，则某些* nix系统希望等待报告错误。 这将在pending callbacks阶段执行。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 阶段有两个重要的功能：</p>
<ul>
<li>执行与 I/O 相关的回调</li>
<li>然后，处理 poll 队列里的事件</li>
</ul>
<p>当事件循环进入 <strong><em>poll</em></strong> 阶段并且在 <strong><em>timers</em></strong> 队列中没有可以执行定时器时，将发生以下两种情况之一</p>
<ul>
<li>如果 <strong><em>poll</em></strong> 队列不为空，事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制。遇到 <strong><em>setImmediate</em></strong> 将其回调放入 <strong><em>setImmediate</em></strong> 队列。</li>
<li>如果poll队列为空，则会发生以下情况：<ul>
<li>如果有 <strong><em>setImmediate()</em></strong> 回调，则会立即停止执行 <strong><em>poll</em></strong> 阶段并进入执行 <strong><em>check</em></strong> 阶段以执行 <strong><em>setImmediate</em></strong> 回调，清空 <strong><em>check</em></strong>队列。执行完<strong><em>setImmediate</em></strong> ，事件循环将绕回 timers 阶段</li>
<li>如果没有 <strong><em>setImmediate()</em></strong> 回调，一方面将等待 <strong><em>I/O</em></strong> 相关的回调被添加到 <strong><em>poll</em></strong> 队列中，然后立即执行。另一方面如果一个或多个计时器回调已准备就绪，则事件循环将绕回 <strong><em>timers</em></strong> 阶段以执行这些计时器的回调。简言之就是，<strong><em>I/O</em></strong> 相关的回调和 <strong><em>timers</em></strong> 相关的回调谁先有结果就先执行谁。</li>
</ul>
</li>
</ul>
<h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p>此阶段允许人员在 <strong><em>poll</em></strong> 阶段完成后立即执行回调。如果 <strong><em>poll</em></strong> 阶段变为空闲状态，并且脚本已排队使用 setImmediate()，则事件循环继续到 <strong><em>check</em></strong> 阶段而不是等待。</p>
<p><strong><em>setImmediate()</em></strong> 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个 <strong><em>libuv API</em></strong> 来安排回调在 <strong><em>poll</em></strong> 阶段完成后执行。</p>
<p>通常，在执行代码时，事件循环最终将达到 <strong><em>poll</em></strong> 阶段，等待传入连接、请求等。如果已经调度了回调setImmediate()，并且轮询阶段变为空闲，则它将结束并且到达check阶段，而不是等待poll事件。</p>
<h3 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h3><p>如果 <strong><em>socket</em></strong> 或 <strong><em>handle</em></strong> 处理函数突然关闭（例如 socket.destroy()），则’close’ 事件将在这个阶段发出。否则它将通过 process.nextTick() 发出。</p>
<h3 id="setImmediate-的setTimeout-的区别"><a href="#setImmediate-的setTimeout-的区别" class="headerlink" title="setImmediate() 的setTimeout()的区别"></a>setImmediate() 的setTimeout()的区别</h3><p>setImmediate() 和 setTimeout() 很类似，但何时调用行为完全不同。</p>
<ul>
<li>setImmediate()：设计用于在当前poll阶段完成后check阶段执行脚本 。</li>
<li>setTimeout()：安排在经过最小（ms）后运行的脚本，在timers阶段执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码的执行结果，受到进程性能的限制。其结果也不一致。</p>
<p>如果在I / O周期内移动两个调用，则始终首先执行 <strong><em>setImmediate</em></strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>主要原因是在 <strong><em>I/O</em></strong> 阶段读取文件后，事件循环会先进入 <strong><em>poll</em></strong> 阶段，发现有 <strong><em>setImmediate</em></strong> 需要执行，会立即进入check阶段执行<strong><em>setImmediate</em></strong> 的回调。</p>
<p>然后再进入 <strong><em>timers</em></strong> 阶段，执行 <strong><em>setTimeout</em></strong>，打印 <strong><em>timeout</em></strong>。</p>
<h3 id="Process-nextTick"><a href="#Process-nextTick" class="headerlink" title="Process.nextTick()"></a>Process.nextTick()</h3><p>当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p>
<h3 id="一个完整的-NodeJS-Event-Loop-过程"><a href="#一个完整的-NodeJS-Event-Loop-过程" class="headerlink" title="一个完整的 NodeJS Event Loop 过程"></a>一个完整的 <strong><em>NodeJS Event Loop</em></strong> 过程</h3><p>一个完整的 <strong><em>NodeJS Event Loop</em></strong> 过程，可以概括为以下阶段：</p>
<ul>
<li>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li>
<li>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</li>
<li>上一步我们出队的是一个 <strong><em>macro-task</em></strong>，这一步我们处理的是 <strong><em>micro-task</em></strong>。会逐个执行队列中的任务并把它出队，直到队列被清空。同时请注意， <strong><em>Process.nextTick</em></strong> 的优先级高于 <strong><em>Promise.then</em></strong></li>
<li>进入 <strong><em>timers</em></strong> 阶段，执行 <strong><em>setTimeout</em></strong> 和 <strong><em>setInterval</em></strong> 中到期的 <strong><em>callback</em></strong>。</li>
<li>如果 <strong><em>timers</em></strong> 阶段，没有 <strong><em>setTimeout</em></strong> 和 <strong><em>setInterval</em></strong> 到期的回调，会进入 <strong><em>poll</em></strong> 阶段。当事件循环进入poll阶段并且在timers中没有可以执行定时器时，将发生以下两种情况之一。<ul>
<li>如果 <strong><em>poll</em></strong> 队列不为空，事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制。遇到 <strong><em>setImmediate</em></strong> 将其回调放入 <strong><em>setImmediate</em></strong> 队列。</li>
<li>如果poll队列为空，则会发生以下情况：<ul>
<li>如果有 <strong><em>setImmediate()</em></strong> 回调，则会立即停止执行 <strong><em>poll</em></strong> 阶段并进入执行 <strong><em>check</em></strong> 阶段以执行 <strong><em>setImmediate</em></strong> 回调，清空 <strong><em>check</em></strong>队列。执行完<strong><em>setImmediate</em></strong> ，事件循环将绕回 timers 阶段</li>
<li>如果没有 <strong><em>setImmediate()</em></strong> 回调，一方面将等待 <strong><em>I/O</em></strong> 相关的回调被添加到 <strong><em>poll</em></strong> 队列中，然后立即执行。另一方面如果一个或多个计时器回调已准备就绪，则事件循环将绕回 <strong><em>timers</em></strong> 阶段以执行这些计时器的回调。简言之就是，<strong><em>I/O</em></strong> 相关的回调和 <strong><em>timers</em></strong> 相关的回调谁先有结果就先执行谁。</li>
</ul>
</li>
</ul>
</li>
<li>注意，<strong><em>pending callback</em></strong>，<strong><em>idle, prepare</em></strong> 这两个阶段我们通常不用考虑。</li>
<li>同时请注意，如果node版本为v11.x，会执行一个 <strong><em>macro-task</em></strong>，然后处理 <strong><em>micro-task</em></strong>。会逐个执行 <strong><em>micro-task</em></strong> 队列中的任务并把它出队，直到队列被清空，与浏览器效果类似。如果node版本为v11.x以下版本，会执行完所有的 <strong><em>macro-task</em></strong>，清空 <strong><em>macro-task</em></strong> 队列。然后，执行 <strong><em>macro-task</em></strong>，清空 <strong><em>micro-task</em></strong> 队列。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> endTime = +<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout用时共计："</span> + (endTime - beginTime) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">fs.readFile(path.resolve(__dirname, <span class="string">'./test copy.js'</span>), () =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> endTime = +<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"readFile1用时共计："</span> + (endTime - beginTime) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'aaaa'</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">fs.readFile(path.resolve(__dirname, <span class="string">'./test copy.js'</span>), () =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> endTime = +<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"readFile2用时共计："</span> + (endTime - beginTime) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bbb'</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate2'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况1</span></span><br><span class="line"><span class="comment">// readFile1用时共计：3ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// timeout用时共计：14ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// readFile2用时共计：15ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况2</span></span><br><span class="line"><span class="comment">// timeout用时共计：3ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// readFile1用时共计：12ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// readFile2用时共计：13ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况3</span></span><br><span class="line"><span class="comment">// readFile2用时共计：2ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"><span class="comment">// timeout用时共计：12ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// readFile1用时共计：12ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况4</span></span><br><span class="line"><span class="comment">// readFile1用时共计：2ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// readFile2用时共计：9ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"><span class="comment">// timeout用时共计：10ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.zhufengpeixun.cn/main/course/index.html" target="_blank" rel="noopener">珠峰前端架构师</a></li>
<li><a href="https://juejin.im/post/5c3d8956e51d4511dc72c200" target="_blank" rel="noopener">一次弄懂Event Loop（彻底解决此类面试问题）</a></li>
<li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">The Node.js Event Loop, Timers, and process.nextTick()</a></li>
<li><a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218" target="_blank" rel="noopener">浏览器与Node的事件循环(Event Loop)有何区别?</a></li>
</ul>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP 面向切片编程</title>
    <url>/2019-10-14/Javascript/AOP-%E9%9D%A2%E5%90%91%E5%88%87%E7%89%87%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="AOP-面向切片编程"><a href="#AOP-面向切片编程" class="headerlink" title="AOP 面向切片编程"></a>AOP 面向切片编程</h2><p><strong><em>AOP（面向切面编程）</em></strong> 的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括<strong><em>日志统计</em></strong>、<strong><em>安全控制</em></strong>、<strong><em>异常处理</em></strong> 等。把这些功能抽离出来之后，再通过 <strong><em>动态植入</em></strong> 的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的 <strong><em>纯净</em></strong> 和 <strong><em>高内聚性</em></strong> ，其次是可以很方便地复用日志统计等功能模块。</p><a id="more"></a>
<p>在 JavaScript中实现 <strong><em>AOP</em></strong>，都是指把一个函数<strong><em>动态植入</em></strong>到另外一个函数之中，通常是基于<strong><em>高阶函数</em></strong>实现的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高阶函数，返回一个新的函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforefn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __self = <span class="keyword">this</span>; <span class="comment">// 保存原函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回包含了原函数和新函数的"代理"函数</span></span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行新函数，修正 this</span></span><br><span class="line">        <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行原函数 并返回原函数执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数，返回一个新的函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterfn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行原函数</span></span><br><span class="line">        afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行新函数，修正 this</span></span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">// 返回原函数执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">func = func.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line">func();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="数据统计上报"><a href="#数据统计上报" class="headerlink" title="数据统计上报"></a>数据统计上报</h2><p><strong><em>分离业务代码和数据统计</em></strong> 代码，无论在什么语言中，都是 <strong><em>AOP</em></strong> 的经典应用之一。在项目开发的结尾阶段难免要加上很多统计数据的代码，这些过程可能让我们被迫改动早已封装好的函数。</p>
<p>比如页面中有一个登录 button，点击这个 button会弹出登录浮层，与此同时要进行数据上报，来统计有多少用户点击了这个登录 button：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">tag</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>点击打开登录浮层<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</span></span><br><span class="line"><span class="javascript">        log( <span class="keyword">this</span>.getAttribute( <span class="string">'tag'</span> ) );</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"> tag </span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'上报标签为: '</span> + tag);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// (new Image).src = 'http:// xxx.com/report?tag=' + tag; // 真正的上报代码略</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById( <span class="string">'button'</span> ).onclick = showLogin;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>showLogin</em></strong> 函数里，既要负责打开登录浮层，又要负责数据上报，这是两个层面的功能，在此处却被耦合在一个函数里。使用 <strong><em>AOP</em></strong> 分离之后，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">tag</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>点击打开登录浮层<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterfn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">            afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> ret;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'上报标签为: '</span> + <span class="keyword">this</span>.getAttribute(<span class="string">'tag'</span>));</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    showLogin = showLogin.after(log); <span class="comment">// 打开登录浮层之后上报数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).onclick = showLogin;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="用AOP动态改变函数的参数"><a href="#用AOP动态改变函数的参数" class="headerlink" title="用AOP动态改变函数的参数"></a>用AOP动态改变函数的参数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span> (<span class="params">type, url, param</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(param); <span class="comment">// 发送 ajax 请求的代码略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getToken = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Token'</span>;</span><br><span class="line">&#125;</span><br><span class="line">ajax = ajax.before(<span class="function"><span class="keyword">function</span> (<span class="params">type, url, param</span>) </span>&#123;</span><br><span class="line">    param.Token = getToken();</span><br><span class="line">&#125;);</span><br><span class="line">ajax(<span class="string">'get'</span>, <span class="string">'http:// xxx.com/userinfo'</span>, &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;);</span><br><span class="line"><span class="comment">// 从 ajax 函数打印的 log可以看到， Token 参数已经被附加到了 ajax 请求的参数中：</span></span><br><span class="line"><span class="comment">// &#123; name: "sven", Token: "Token" &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>beforefn</em></strong> 和原函数 <strong><em>__self</em></strong>  共用一组参数列表<strong><em>arguments</em></strong> ，当我们在 <strong><em>beforefn</em></strong> 的函数体内改变 <strong><em>arguments</em></strong> 的时候，原函数 <strong><em>__self</em></strong> 接收的参数列表自然也会变化。</p>
<p>明显可以看到，用 <strong><em>AOP</em></strong> 的方式给 <strong><em>ajax</em></strong> 函数动态装饰上 <strong><em>Token</em></strong> 参数，保证了 <strong><em>ajax</em></strong> 函数是一个相对纯净的函数，提高了 <strong><em>ajax</em></strong> 函数的可复用性，它在被迁往其他项目的时候，不需要做任何修改。</p>
<h2 id="插件式的表单验证"><a href="#插件式的表单验证" class="headerlink" title="插件式的表单验证"></a>插件式的表单验证</h2><p>在表单数据提交给后台之前，常常要做一些校验，比如登录的时候需要验证用户名和密码是否为空，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line">    密码： <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"submitBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>),</span></span><br><span class="line"><span class="javascript">        password = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>),</span></span><br><span class="line"><span class="javascript">        submitBtn = <span class="built_in">document</span>.getElementById(<span class="string">'submitBtn'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforefn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) === <span class="literal">false</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// beforefn 返回 false 的情况直接 return，不再执行后面的原函数</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 可以做相关提示操作</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> validata = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (username.value === <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'用户名不能为空'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (password.value === <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'密码不能为空'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> formSubmit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> param = &#123;</span></span><br><span class="line">            username: username.value,</span><br><span class="line">            password: password.value</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        ajax(<span class="string">'http:// xxx.com/login'</span>, param);</span></span><br><span class="line">    &#125;</span><br><span class="line">    formSubmit = formSubmit.before(validata);</span><br><span class="line"><span class="javascript">    submitBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        formSubmit();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>校验输入和提交表单的代码完全分离开来，它们不再有任何耦合关系。</p>
<p>值得注意的是，因为函数通过 <strong><em>Function.prototype.before</em></strong> 或者 <strong><em>Function.prototype.after</em></strong> 被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">func.a = <span class="string">'a'</span>;</span><br><span class="line">func = func.after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(func.a); <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure>

<p>另外，这种装饰方式也叠加了<strong><em>函数的作用域</em></strong>，如果装饰的链条过长，性能上也会受到一些影响。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">javascript 设计模式与开发实践</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-深拷贝浅析</title>
    <url>/2019-10-14/Javascript/JavaScript-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(object))</span><br></pre></td></tr></table></figure><p>该方法有以下几个问题：</p><ul>
<li>会忽略 undefined</li>
<li>会忽略 symbol</li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
<li>不能正确处理new Date()</li>
<li>不能处理正则</li>
</ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'111'</span>,</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    b: <span class="built_in">Symbol</span>(<span class="string">'111'</span>),</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;name: "111"&#125;</span></span><br></pre></td></tr></table></figure><a id="more"></a>





<h2 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj,hash = new WeakMap(</span>))</span>&#123;</span><br><span class="line">    <span class="comment">//避免引用循环 比较对象与对象属性是否相等</span></span><br><span class="line">    <span class="comment">// if (obj === parent) return parent;</span></span><br><span class="line">    <span class="comment">//处理null undefined</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">//处理string boolean number</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">    <span class="keyword">if</span>(hash.has(obj))&#123;</span><br><span class="line">        <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理 array object</span></span><br><span class="line">    <span class="keyword">let</span> instance = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">    hash.set(obj, instance)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="comment">//递归实现深拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key))&#123;</span><br><span class="line">            instance[key] = deepClone(obj[key], hash);</span><br><span class="line">            <span class="comment">// instance[key] = deepClone(obj[key], obj);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line">obj.b = obj;</span><br><span class="line"><span class="keyword">var</span> cloneObj = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(cloneObj === obj, cloneObj)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-高阶函数浅析</title>
    <url>/2019-10-13/Javascript/JavaScript-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数英文叫 Higher-order function，它的定义很简单，就是至少满足下列一个条件的函数：</p><ul>
<li>函数作为返回值</li>
<li>函数作为参数传递</li>
</ul><p>也就是说高阶函数是对其他函数进行操作的函数，可以将它们作为参数传递，或者是返回函数。 </p><h2 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h2><p>JavaScript 语言中内置了一些高阶函数，比如 Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce，它们接受一个函数作为参数，并使用这个函数作用到列表的每一个元素</p><a id="more"></a>



<h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map"></a>Array.prototype.map</h3><p><strong><em>map()</em></strong> 函数返回一个新的数组，新数组中的元素是<strong><em>回调函数（callback）</em></strong>作用于指定数组中的元素后返回的结果。</p>
<ul>
<li>不会改变原始数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), <span class="title">thisValue</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>function(currentValue, index,arr)：必须。函数，数组中的每个元素都会执行这个函数<ul>
<li>currentValue：必须。当前元素的值</li>
<li>可选。当前元素的索引值</li>
<li>arr：可选。当前元素属于的数组对象</li>
</ul>
</li>
<li>thisValue：可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined”</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( arr2 );</span><br><span class="line"><span class="comment">// [2, 6, 12, 18]</span></span><br><span class="line"><span class="built_in">console</span>.log( arr1 );</span><br><span class="line"><span class="comment">// [1, 3, 6, 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter"></a>Array.prototype.filter</h3><p><strong><em>filter()</em></strong> 方法返回一个新数组, 新数组中的元素是通过检查指定数组中符合条件的所有元素。</p>
<ul>
<li>不会对空数组进行检测</li>
<li>不会改变原始数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), <span class="title">thisValue</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>function(currentValue, index,arr)：必须。函数，数组中的每个元素都会执行这个函数<ul>
<li>currentValue：必须。当前元素的值</li>
<li>可选。当前元素的索引值</li>
<li>arr：可选。当前元素属于的数组对象</li>
</ul>
</li>
<li>thisValue：可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined”</li>
</ul>
<p>数组去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.filter( <span class="function">(<span class="params">element, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf( element ) === index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( arr2 );</span><br><span class="line"><span class="comment">// [1, 2, 3, 5, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log( arr1 );</span><br><span class="line"><span class="comment">// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce"></a>Array.prototype.reduce</h3><p><strong><em>reduce()</em></strong> 方法对数组中的每个元素执行一个由您提供的<strong><em>reducer</em></strong>函数(升序执行)，回调函数<strong><em>（callback）</em></strong>，将其结果汇总为单个返回值。除了 <strong><em>callback</em></strong> 之外还可以接受初始值 <strong><em>initialValue</em></strong> 值（可选）</p>
<ul>
<li><p>如果没有提供 initialValue，那么第一次调用 callback 函数时，accumulator 使用原数组中的第一个元素，currentValue 即是数组中的第二个元素。 在没有初始值的空数组上调用 reduce 将报错。</p>
</li>
<li><p>如果提供了 initialValue，那么将作为第一次调用 callback 函数时的第一个参数的值，即 accumulator，currentValue 使用原数组中的第一个元素。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>)</span>&#123;&#125;, initialValue)</span><br></pre></td></tr></table></figure>

<ul>
<li>function(accumulator, currentValue, currentIndex, array)：必须。函数<ul>
<li>Accumulator (acc)：累计器</li>
<li>Current Value (cur)：当前值</li>
<li>Current Index (idx)：当前索引 可选</li>
<li>Source Array (src)：源数组 可选</li>
</ul>
</li>
<li>initialValue：initialValue</li>
</ul>
<p>数组求和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> sum = arr.reduce(<span class="function">(<span class="params">accumulator, currentValue, currentIndex, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( sum );</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log( arr );</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h2><h3 id="isType-函数"><a href="#isType-函数" class="headerlink" title="isType 函数"></a>isType 函数</h3><p>通过 <strong><em>Object.prototype.toString.call</em></strong>判断类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isType = <span class="function"><span class="params">type</span> =&gt;</span> <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object '</span> + type + <span class="string">']'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isType(<span class="string">'String'</span>)(<span class="string">'123'</span>) <span class="comment">// true</span></span><br><span class="line">isType(<span class="string">'Array'</span>)([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// true</span></span><br><span class="line">isType(<span class="string">'Number'</span>)(<span class="number">123</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="add-函数"><a href="#add-函数" class="headerlink" title="add 函数"></a>add 函数</h3><p>一个常见的面试题，用 JS 实现一个无限累加的函数 add，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)； <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)； <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>都是将函数作为返回值输出，然后接收新的参数并进行计算。</p>
<p>我们知道打印函数时会自动调用 toString()方法，函数 add(a) 返回一个闭包 sum(b)，函数 sum() 中累加计算 a = a + b，只需要重写sum.toString()方法返回结果值 a 就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        a = a + b; <span class="comment">// 求和</span></span><br><span class="line">        <span class="keyword">return</span> sum; <span class="comment">// 返回求和函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写toString()方法</span></span><br><span class="line">    sum.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">// 返回求和函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://muyiy.cn/blog/6/6.1.html" target="_blank" rel="noopener">https://muyiy.cn/blog/6/6.1.html</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript深入之继承的多种方式和优缺点</title>
    <url>/2019-10-12/Javascript/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'kevin'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()) <span class="comment">// kevin</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p>核心： 将父类的实例作为子类的原型</p>
<p>特点：实例可继承的属性有：Child实例的构造函数的属性，父类构造函数属性，父类原型的属性。</p>
<p>缺点：</p>
<ul>
<li>1.父类引用类型的属性被所有实例共享。</li>
<li>2.在创建 Child 的实例时，不能向Parent传参。</li>
</ul>
<h2 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2.借用构造函数"></a>2.借用构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.names = [<span class="string">'kevin'</span>, <span class="string">'daisy'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">'yayu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["kevin", "daisy"]</span></span><br></pre></td></tr></table></figure>

<p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类。</p>
<p>特点：</p>
<ul>
<li>解决了原型链继承中，子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承（call多个父类对象）</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能继承父类构造函数的属性和方法，不能继承原型上的属性/方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，浪费内存，影响性能</li>
</ul>
<h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line">child1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors); <span class="comment">// ["red", "blue", "green", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'daisy'</span>, <span class="string">'20'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors); <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure>

<p>核心：原型链继承和经典继承双剑合璧。</p>
<p>优点：可以继承父类原型上的属性，可以传参，可复用。融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p>
<p>缺点：调用了两次父类构造函数（耗内存）。</p>
<h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// o一般指向父类原型</span></span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="comment">// 实例化空函数，可以继承父类原型上的方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是 ES5 <strong><em>Object.create</em></strong> 的模拟实现，将传入的对象作为创建的对象的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'kevin'</span>,</span><br><span class="line">    friends: [<span class="string">'daisy'</span>, <span class="string">'kelly'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">var</span> person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'person1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.firends.push(<span class="string">'taylor'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["daisy", "kelly", "taylor"]</span></span><br></pre></td></tr></table></figure>

<p>注意：修改<strong><em>person1.name</em></strong>的值，<strong><em>person2.name</em></strong>的值并未发生改变，并不是因为<strong><em>person1</em></strong>和<strong><em>person2</em></strong>有独立的 <strong>*name *</strong>值，而是因为<strong><em>person1.name = ‘person1’</em></strong>，给<strong><em>person1</em></strong>添加了 <strong><em>name</em></strong> 值，并非修改了原型上的 <strong><em>name</em></strong> 值，<strong><em>person2.name</em></strong>获取的是原型上的值。</p>
<p>核心：使用一个空函数作为过渡对象，让空函数的prototype 指向需要继承的对象，返回实例化的空函数。</p>
<p>优点：空函数作为过渡对象，构造函数无内容，可以较少开销。</p>
<p>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>
<h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = createObj(o);</span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心：寄生式继承就是对原型式继承的第二次封装，在第二次封装过程中对继承的对象进行了扩展，这样新创建的对象不仅可以继承父类中的属性和方法而且还添加了新的属性和方法。</p>
<h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// o一般指向父类原型</span></span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="comment">// 实例化空函数，可以继承父类原型上的方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过原型式继承，继承父类原型上的属性和方法</span></span><br><span class="line">    <span class="keyword">var</span> prototype = createObj(parent.prototype);</span><br><span class="line">    <span class="comment">// 添加新的属性，修复子类的构造函数</span></span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    <span class="comment">// 修改子类的原型，保留子类的构造函数，继承父类原型上的属性和方法</span></span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  借用构造函数</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">prototype(Child, Parent);</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>

<p>核心：寄生式继承和借用构造函数的经典组合。</p>
<p>借用构造函数，继承了构造函数中的属性和方法。通过原型继承可以继承父类原型的属性和方法，由于原型继承中，使用空函数作为过渡对象，构造函数无内容，可以较少开销。直接通过原型继承存在一个问题，子类的构造函数将会丢失。所以通过，寄生式继承对原型继承的结果进行扩展，修复其构造函数指向的不正确问题。最后将子类原型指向这个结果。</p>
<p>寄生组合式继承是引用类型最理想的继承范式。</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>==和===的区别是什么？</title>
    <url>/2019-10-12/Javascript/%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>==</strong>是抽象相等运算符，而<strong>===</strong>是严格相等运算符。<br><strong>==</strong>运算符是在进行必要的类型转换后，再比较。<br><strong>===</strong>运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回false。<br>使用<strong>==</strong>时，可能发生一些特别的事情，例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">'1'</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == [<span class="number">1</span>]; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">''</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">'0'</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p>除了方便与null或undefined比较时，最好不使用==运算符</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript深入之new的模拟实现</title>
    <url>/2019-10-12/Javascript/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8Bnew%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="new实例化"><a href="#new实例化" class="headerlink" title="new实例化"></a>new实例化</h2><ul>
<li>返回一个新的对象</li>
<li>新对象可以访问构造函数里的属性和方法</li>
<li>新对象可以访问 prototype 上的属性和方法</li>
</ul><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 mockNew，来模拟 new 的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 需要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 获取需要实例化的构造函数</span></span><br><span class="line">    <span class="comment">// shift 会返回构造函数，修改原数组，所以 arguments 会被去除第一个参数</span></span><br><span class="line">    <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 继承原型上的属性和方法</span></span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="comment">//继承构造函数的属性和方法</span></span><br><span class="line">    Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<h2 id="兼容返回值类型"><a href="#兼容返回值类型" class="headerlink" title="兼容返回值类型"></a>兼容返回值类型</h2><p>我们还需要判断构造函数的返回值，如果构造函数的返回值是一个引用类型的对象，我们就返回构造函数的返回值，如果不是，我们该返回什么就返回什么。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 需要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 获取需要实例化的构造函数</span></span><br><span class="line">    <span class="comment">// shift 会返回构造函数，修改原数组，所以 arguments 会被去除第一个参数</span></span><br><span class="line">    <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 继承原型上的属性和方法</span></span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="comment">// 继承构造函数的属性和方法</span></span><br><span class="line">    <span class="keyword">var</span> result = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 兼容返回值类型 </span></span><br><span class="line">    <span class="comment">// 如果构造函数的返回值是一个引用类型的对象，我们就返回构造函数的返回值，否则返回obj</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/13</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>bind的模拟实现</title>
    <url>/2019-10-12/Javascript/bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="bind的作用"><a href="#bind的作用" class="headerlink" title="bind的作用"></a>bind的作用</h2><ul>
<li>bind()方法返回一个新的函数,</li>
<li>新函数的this值指向传入的第一个参数，this被绑定了</li>
<li>bind 的时候可以传递参数，进行绑定</li>
<li>bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效</li>
</ul><h2 id="返回函数的模拟实现"><a href="#返回函数的模拟实现" class="headerlink" title="返回函数的模拟实现"></a>返回函数的模拟实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="兼容参数处理"><a href="#兼容参数处理" class="headerlink" title="兼容参数处理"></a>兼容参数处理</h2><p>bind 的时候可以传递参数，进行绑定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//绑定参数</span></span><br><span class="line">    <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 指向函数 返回结果</span></span><br><span class="line">        <span class="comment">// 最终执行结果的参数，需要将bindArgs，args使用concat合并</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(context, bindArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="兼容构造函数"><a href="#兼容构造函数" class="headerlink" title="兼容构造函数"></a>兼容构造函数</h2><p>bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 指向函数 返回结果</span></span><br><span class="line">        <span class="comment">// 最终执行结果的参数，需要将bindArgs，args使用concat合并</span></span><br><span class="line">        <span class="comment">// bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，this指向fBound，但传入的参数依然生效</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : context, bindArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="兼容绑定函数原型上的属性"><a href="#兼容绑定函数原型上的属性" class="headerlink" title="兼容绑定函数原型上的属性"></a>兼容绑定函数原型上的属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 指向函数 返回结果</span></span><br><span class="line">        <span class="comment">// 最终执行结果的参数，需要将bindArgs，args使用concat合并</span></span><br><span class="line">        <span class="comment">// bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，this指向fBound，但传入的参数依然生效</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : context, bindArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span></span><br><span class="line">    <span class="comment">// 直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype</span></span><br><span class="line">    <span class="comment">// fBound.prototype = this.prototype;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过一个空函数来进行中转</span></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="兼容调用-bind-的不是函数"><a href="#兼容调用-bind-的不是函数" class="headerlink" title="兼容调用 bind 的不是函数"></a>兼容调用 bind 的不是函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用bind的不是函数，直接报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 指向函数 返回结果</span></span><br><span class="line">        <span class="comment">// 最终执行结果的参数，需要将bindArgs，args使用concat合并</span></span><br><span class="line">        <span class="comment">// bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，this指向fBound，但传入的参数依然生效</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : context, bindArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span></span><br><span class="line">    <span class="comment">// 直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype</span></span><br><span class="line">    <span class="comment">// fBound.prototype = this.prototype;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过一个空函数来进行中转</span></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/12</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>call和apply的模拟实现</title>
    <url>/2019-10-12/Javascript/call%E5%92%8Capply%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="call的特点"><a href="#call的特点" class="headerlink" title="call的特点"></a>call的特点</h2><ul>
<li>可以改变当前函数的this指向</li>
<li>让当前函数执行</li>
</ul><h2 id="call模拟实现"><a href="#call模拟实现" class="headerlink" title="call模拟实现"></a>call模拟实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;<span class="comment">// 兼容context，Object(context)兼容context为string的情况</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>; <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">//获取参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    <span class="comment">// args 会自动调用 Array.toString() 这个方法</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args +<span class="string">')'</span>);</span><br><span class="line">    <span class="comment">// 删除该函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="apply-模拟实现"><a href="#apply-模拟实现" class="headerlink" title="apply 模拟实现"></a>apply 模拟实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;<span class="comment">// 兼容context，Object(context)兼容context为string的情况</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>; <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (!args) &#123;</span><br><span class="line">        <span class="comment">// 没有传参直接直接函数</span></span><br><span class="line">        result = context.fn()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = args.length; i &lt; len; i++) &#123;</span><br><span class="line">            arr.push(<span class="string">'args['</span> + i + <span class="string">']'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// arr 会自动调用 Array.toString() 这个方法</span></span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + arr + <span class="string">')'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除该函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用let、var和const创建变量有什么区别？</title>
    <url>/2019-10-12/Javascript/%E4%BD%BF%E7%94%A8let%E3%80%81var%E5%92%8Cconst%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<p>用<strong><em>var</em></strong>声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。<strong><em>let</em></strong>和<strong><em>const</em></strong>是块级作用域，意味着它们只能在最近的一组花括号<strong><em>（function、if-else 代码块或 for 循环中）</em></strong>中访问。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 所有变量在函数中都可访问</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">'bar'</span>;</span><br><span class="line">  <span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line">  <span class="keyword">const</span> qux = <span class="string">'qux'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// bar</span></span><br><span class="line">  <span class="built_in">console</span>.log(baz); <span class="comment">// baz</span></span><br><span class="line">  <span class="built_in">console</span>.log(qux); <span class="comment">// qux</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// ReferenceError: bar is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// ReferenceError: baz is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(qux); <span class="comment">// ReferenceError: qux is not defined</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">'bar'</span>;</span><br><span class="line">  <span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line">  <span class="keyword">const</span> qux = <span class="string">'qux'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 var 声明的变量在函数作用域上都可访问</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// let 和 const 定义的变量在它们被定义的语句块之外不可访问</span></span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// ReferenceError: baz is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(qux); <span class="comment">// ReferenceError: qux is not defined</span></span><br></pre></td></tr></table></figure>

<p><strong><em>var</em></strong>会使变量提升，这意味着变量可以在声明之前使用。<strong><em>let</em></strong>和<strong><em>const</em></strong>不会使变量提升，提前使用会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// ReferenceError: can't access lexical declaration 'baz' before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// ReferenceError: can't access lexical declaration 'bar' before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure>

<p>用<strong><em>var</em></strong>重复声明不会报错，但<strong><em>let</em></strong>和<strong><em>const</em></strong>会。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// "bar"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">'qux'</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'baz' has already been declared</span></span><br></pre></td></tr></table></figure>

<p><strong><em>let</em></strong>和<strong><em>const</em></strong>的区别在于：<strong><em>let</em></strong>允许多次赋值，而<strong><em>const</em></strong>只允许一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样不会报错。</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">'foo'</span>;</span><br><span class="line">foo = <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样会报错。</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="string">'baz'</span>;</span><br><span class="line">baz = <span class="string">'qux'</span>;</span><br></pre></td></tr></table></figure>

<p>全局作用域下，使用<strong><em>var</em></strong>声明的变量会挂载到<strong><em>window</em></strong>对象上，使用<strong><em>let</em></strong>，<strong><em>const</em></strong>声明的变量不会挂载到<strong><em>window</em></strong>对象上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> c =<span class="number">30</span>;</span><br><span class="line"><span class="built_in">window</span>.a; <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">window</span>.b; <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">window</span>.c; <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>null、undefined和未声明变量之间有什么区别？如何检查判断这些状态值？</title>
    <url>/2019-10-12/Javascript/null%E3%80%81undefined%E5%92%8C%E6%9C%AA%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E5%88%A4%E6%96%AD%E8%BF%99%E4%BA%9B%E7%8A%B6%E6%80%81%E5%80%BC%EF%BC%9F/</url>
    <content><![CDATA[<p>当你没有提前使用<strong><em>var</em></strong>、<strong><em>let</em></strong>或<strong><em>const</em></strong>声明变量，就为一个变量赋值时，该变量是未声明变量<strong><em>（undeclared variables）</em></strong>。未声明变量会脱离当前作用域，成为全局作用域下定义的变量。<strong><em>在严格模式下</em></strong>，给未声明的变量赋值，会抛出<strong><em>ReferenceError</em></strong>错误。和使用全局变量一样，使用未声明变量也是非常不好的做法，应当尽可能避免。要检查判断它们，需要将用到它们的代码放在<strong><em>try/catch</em></strong>语句中。</p><a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">1</span>; <span class="comment">// 在严格模式下，抛出 ReferenceError 错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>当一个变量已经声明，但没有赋值时，该变量的值是<strong><em>undefined</em></strong>。如果一个函数的执行结果被赋值给一个变量，但是这个函数却没有返回任何值，那么该变量的值是<strong><em>undefined</em></strong>。要检查它，需要使用严格相等（===）；或者使用<strong><em>typeof</em></strong>，它会返回<strong><em>‘undefined’</em></strong>字符串。请注意，不能使用非严格相等（==）来检查，因为如果变量值为<strong><em>null</em></strong>，使用非严格相等也会返回<strong><em>true</em></strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo === <span class="string">'undefined'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo == <span class="literal">null</span>); <span class="comment">// true. 错误，不要使用非严格相等！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> baz = bar();</span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong><em>null</em></strong> 只能被显式赋值给变量。它表示空值，与被显式赋值 <strong><em>undefined</em></strong> 的意义不同。要检查判断<strong><em>null</em></strong>值，需要使用严格相等运算符。请注意，和前面一样，不能使用非严格相等（==）来检查，因为如果变量值为<strong><em>undefined</em></strong>，使用非严格相等也会返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo == <span class="literal">undefined</span>); <span class="comment">// true. 错误，不要使用非严格相等！</span></span><br></pre></td></tr></table></figure>

<p>作为一种个人习惯，我从不使用未声明变量。如果定义了暂时没有用到的变量，我会在声明后明确地给它们赋值为<strong><em>null</em></strong>。</p>
<ul>
<li>null：表示一个值被定义了，定义为“空值”；</li>
<li>undefined：表示根本不存在定义。</li>
</ul>
<p>所以设置一个值为 <strong><em>null</em></strong> 是合理的，如<br><strong><em>objA.valueA = null</em></strong>;</p>
<p>但设置一个值为 <strong><em>undefined</em></strong> 是不合理的</p>
<p><strong><em>null</em></strong> 表示”没有对象”，即该处不应该有值。典型用法是：</p>
<ul>
<li>1.作为函数的参数，表示该函数的参数不是对象。</li>
<li>2.作为对象原型链的终点。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)<span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p><code>undefined</code> 表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<ul>
<li>1.变量被声明了，但没有赋值时，就等于undefined。</li>
<li>2.调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>
<li>3.对象没有赋值的属性，该属性的值为undefined。</li>
<li>4.函数没有返回值时，默认返回undefined。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/questions/javascript-questions.md#nullundefined%E5%92%8C%E6%9C%AA%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E5%88%A4%E6%96%AD%E8%BF%99%E4%BA%9B%E7%8A%B6%E6%80%81%E5%80%BC" target="_blank" rel="noopener">https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/questions/javascript-questions.md#nullundefined%E5%92%8C%E6%9C%AA%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E5%88%A4%E6%96%AD%E8%BF%99%E4%BA%9B%E7%8A%B6%E6%80%81%E5%80%BC</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2019-10-12/Javascript/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>把接收多个参数的函数变换成接收一个单一参数（最初函数的第一个参数）的函数，并返回接受剩余的参数而且返回结果的新函数的技术。</p><p>简单的说，柯里化函数持续地返回一个新函数直到所有的参数用尽为止。这些参数全部保持“活着”的状态（通过闭包），然后当柯里化链中的最后一个函数被返回和执行时会全部被用来执行。</p><a id="more"></a>

<p>提高函数的适用性，同时降低函数的通用性；其实现方式就是固定一些可以预期的参数，然后返回一个特定的函数</p>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的add函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingAdd</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)           <span class="comment">// 3</span></span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>)   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="函数柯里化的好处"><a href="#函数柯里化的好处" class="headerlink" title="函数柯里化的好处"></a>函数柯里化的好处</h2><ul>
<li>参数复用：提前绑定好函数里面的某些参数,达到参数复用的效果,提高了适用性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常正则验证字符串 reg.test(txt)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数封装后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg, txt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check(<span class="regexp">/\d+/g</span>, <span class="string">'test'</span>)       <span class="comment">//false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>, <span class="string">'test'</span>)    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = curryingCheck(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line"></span><br><span class="line">hasNumber(<span class="string">'test1'</span>)      <span class="comment">// true</span></span><br><span class="line">hasNumber(<span class="string">'testtest'</span>)   <span class="comment">// false</span></span><br><span class="line">hasLetter(<span class="string">'21212'</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>提前返回<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//兼容现代浏览器以及IE浏览器的事件添加方法</span></span><br><span class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.attachEvent(<span class="string">'on'</span> + event, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上面的方法有什么问题呢？很显然，我们每次使用addEvent为元素添加事件的时候，会走一遍if…else if …，其实只要一次判定就可以了，怎么做？–柯里化。它相对一第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了浏览器支持的事件绑定，避免每次都进行判断。改为下面这样子的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.attachEvent(<span class="string">'on'</span> + event, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ul>
<li>延迟运行</li>
</ul>
<p>与 <strong><em>call/apply</em></strong> 方法直接执行不同，bind 方法将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数， 这符合柯里化特点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(target, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数柯里化实现"><a href="#函数柯里化实现" class="headerlink" title="函数柯里化实现"></a>函数柯里化实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, args = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">..._</span>) </span>&#123;</span><br><span class="line">        args.push(..._); <span class="comment">//使用args保存参数</span></span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; fn.length) &#123;</span><br><span class="line">            <span class="comment">// 递归调用 返回一个新的函数 并保存传递的参数</span></span><br><span class="line">            <span class="keyword">return</span> currying(fn, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行被柯里化的函数  需要将参数进行结构</span></span><br><span class="line">            <span class="keyword">return</span> fn(...args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = currying(add)(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于函数柯里化实现类型判断</span></span><br><span class="line"><span class="keyword">const</span> isType = <span class="function">(<span class="params">type, content</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(content) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isString = currying(isType)(<span class="string">'String'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(isString(<span class="string">'111'</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.call(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkType = <span class="built_in">Object</span>.prototype.toString.uncurrying();</span><br><span class="line"><span class="built_in">console</span>.log(checkType(<span class="string">'111'</span>)) <span class="comment">// '[object String]'</span></span><br></pre></td></tr></table></figure>

<h2 id="函数反柯里化实现"><a href="#函数反柯里化实现" class="headerlink" title="函数反柯里化实现"></a>函数反柯里化实现</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006096034" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006096034</a></p>
<p><a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">https://www.jianshu.com/p/2975c25e4d71</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流和防抖</title>
    <url>/2019-10-12/Javascript/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/</url>
    <content><![CDATA[<h1 id="函数节流和防抖"><a href="#函数节流和防抖" class="headerlink" title="函数节流和防抖"></a>函数节流和防抖</h1><p>窗口的resize、scroll、输入框内容校验等操作时，如果这些操作处理函数是较为复杂或页面频繁重渲染等操作时，在这种情况下如果事件触发的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用<strong><em>debounce（防抖）</em></strong>和<strong><em>throttle（节流）</em></strong>的方式来<strong><em>减少触发的频率</em></strong>，同时又不影响实际效果。</p><a id="more"></a>
<h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h2><p>当持续触发事件时，<strong><em>debounce</em></strong> 会合并事件且不会去触发事件，当一定时间内没有触发再这个事件时，才真正去触发事件，只会触发最后一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> timer = <span class="literal">null</span>, context, args;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = debounce(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"触发滚动"</span>, e)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<h3 id="立刻执行"><a href="#立刻执行" class="headerlink" title="立刻执行"></a>立刻执行</h3><p>不希望非要等到事件停止触发后才执行，希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。</p>
<p>加个 immediate 参数判断是否是立刻执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>, context, args;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 判断绑定的函数是否已经执行了 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> didRun = !timer;</span><br><span class="line">            <span class="keyword">if</span> (didRun) &#123;</span><br><span class="line">                <span class="comment">//没有执行过，立刻执行</span></span><br><span class="line">                callback.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>此时注意一点，就是绑定的函数可能是有返回值的，所以我们也要返回函数的执行结果，但是当 <strong><em>immediate</em></strong> 为 false 的时候，因为使用了 <strong><em>setTimeout</em></strong> ，我们将 <strong><em>func.apply(context, args)</em></strong> 的返回值赋给变量，最后再<strong><em>return</em></strong> 的时候，值将会一直是<strong><em>undefined</em></strong>，所以我们只在 <strong><em>immediate</em></strong> 为 <strong><em>true</em></strong> 的时候返回函数的执行结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>, context, args;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 判断绑定的函数是否已经执行了 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> didRun = !timer;</span><br><span class="line">            <span class="keyword">if</span> (didRun) &#123;</span><br><span class="line">                <span class="comment">//没有执行过，立刻执行</span></span><br><span class="line">                result = callback.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p>最后我们再思考一个小需求，我希望能<strong><em>取消 debounce</em></strong> 函数，比如说我 <strong><em>debounce</em></strong> 的时间间隔是 10 秒钟，<strong><em>immediat</em></strong>e 为 <strong><em>true</em></strong>，这样的话，我只有等 10 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行啦。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>, context, args;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 判断绑定的函数是否已经执行了 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> didRun = !timer;</span><br><span class="line">            <span class="keyword">if</span> (didRun) &#123;</span><br><span class="line">                <span class="comment">//没有执行过，立刻执行</span></span><br><span class="line">                result = callback.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消防抖</span></span><br><span class="line">    debounced.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 清除timeout</span></span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="comment">// 重置timeout</span></span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p>
<p>根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。</p>
<p>我们用 <strong><em>leading</em></strong> 代表首次是否执行，<strong><em>trailing</em></strong> 代表结束后是否再执行一次。</p>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<h3 id="使用时间戳"><a href="#使用时间戳" class="headerlink" title="使用时间戳"></a>使用时间戳</h3><p>使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> context, args;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">var</span>  now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; delay) &#123;</span><br><span class="line">            previous = now;</span><br><span class="line">            callback.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h3><p>接下来，我们讲讲第二种实现方式，使用定时器。</p>
<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，重置定时器，这样就可以设置下个定时器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 重置定时器</span></span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                callback.apply(context, args)</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较使用时间戳，使用定时器两个方法：</p>
<p>第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行<br>第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件</p>
<h3 id="双剑合璧"><a href="#双剑合璧" class="headerlink" title="双剑合璧"></a>双剑合璧</h3><p>想要控制第一次是否立刻执行，事件停止触发后是否会再执行一次事件。</p>
<p>那我们设置个 <strong><em>options</em></strong> 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定:</p>
<ul>
<li>leading：false 表示禁用第一次执行</li>
<li>trailing: false 表示禁用停止触发的回调<br>默认会开启第一次立刻执行，事件停止触发后会再执行一次事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果禁用第一次立刻执行 设置previous为0，throttled函数remaining会确保大于0 throttled函数会执行else if条件语句里面的内容，从而达到节流的效果，如果没有禁用第一次立刻执行，需要重置previous为当前时间</span></span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="comment">// 执行完重置timeout</span></span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 执行函数</span></span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="comment">// 触发第一次操作时，默认会第一次立刻执行，第一次执行remaining会小于0，程序会执行 if条件语句的内容，快速执行第二次点击previous = now;remaining会大于0，会执行else if条件语句里面的内容</span></span><br><span class="line">        <span class="comment">// 触发第一次操作时，如果禁用第一次立刻执行，当前previous为0，将previous设置为now，remaining会大于0 程序会执行else if条件语句里面的内容</span></span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="comment">// 获取触发函数剩余的时间</span></span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 绑定arguments</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="comment">// 清除timeout</span></span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置时间</span></span><br><span class="line">            previous = now;</span><br><span class="line">            <span class="comment">// 执行函数</span></span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// 事件停止触发后会再执行一次事件</span></span><br><span class="line">            <span class="comment">// 通过计时器setTimeout，设置remaining时间后执行事件触发，达到节流</span></span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。</li>
<li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>debounce<ul>
<li>search搜索，用户在不断输入值时，用防抖来节约请求资源。</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ul>
</li>
<li>throttle<ul>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/post/5b8de829f265da43623c4261" target="_blank" rel="noopener">https://juejin.im/post/5b8de829f265da43623c4261</a></p>
<p><a href="https://juejin.im/post/5b7b88d46fb9a019e9767405?utm_medium=fe&amp;utm_source=weixinqun" target="_blank" rel="noopener">https://juejin.im/post/5b7b88d46fb9a019e9767405?utm_medium=fe&amp;utm_source=weixinqun</a></p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/22</a></p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/26</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>普通函数和箭头函数的区别</title>
    <url>/2019-10-12/Javascript/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>1.箭头函数没有prototype(原型)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="params">()</span> =&gt;</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">a.__proto__===<span class="built_in">Function</span>.prototype;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>2.箭头函数的this指向它被创建时的上下文</p><a id="more"></a>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    id: <span class="number">22</span>,</span><br><span class="line">    print: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;,</span><br><span class="line">    print2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;,</span><br><span class="line">    print3: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    print4: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.print(); <span class="comment">// undefined</span></span><br><span class="line">obj.print2(); <span class="comment">// 22</span></span><br><span class="line">obj.print3(); <span class="comment">// undefined</span></span><br><span class="line">obj.print4(); <span class="comment">// 22</span></span><br></pre></td></tr></table></figure>

<p>3.在构造函数里使用箭头函数的主要优点是它的 this 只与箭头函数创建时的 this 保持一致，并且不会修改。所以，当用构造函数去创建一个新的对象的时候，箭头函数的 this 总是指向新创建的对象。正常函数的 this 是可以在执行过程中被改变的，而箭头函数的 this 则会一直保持一致。所以在使用箭头函数的时候，你就不需要担心它的上下文被改变了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">firstName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">this</span>.sayName1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.firstName); &#125;;</span><br><span class="line">    <span class="keyword">this</span>.sayName2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.firstName); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> john = <span class="keyword">new</span> Person(<span class="string">'John'</span>);</span><br><span class="line"><span class="keyword">const</span> dave = <span class="keyword">new</span> Person(<span class="string">'Dave'</span>);</span><br><span class="line"></span><br><span class="line">john.sayName1(); <span class="comment">// John</span></span><br><span class="line">john.sayName2(); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数的 this 可以被修改，而箭头函数则不会</span></span><br><span class="line">john.sayName1.call(dave); <span class="comment">// Dave (因为 "this" 现在指向了 dave 对象)</span></span><br><span class="line">john.sayName2.call(dave); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line">john.sayName1.apply(dave); <span class="comment">// Dave (因为 "this" 现在指向了 dave 对象)</span></span><br><span class="line">john.sayName2.apply(dave); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line">john.sayName1.bind(dave)(); <span class="comment">// Dave (因为 "this" 现在指向了 dave 对象)</span></span><br><span class="line">john.sayName2.bind(dave)(); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sayNameFromWindow1 = john.sayName1;</span><br><span class="line">sayNameFromWindow1(); <span class="comment">// undefined (因为 "this" 现在指向了 Window 对象)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sayNameFromWindow2 = john.sayName2;</span><br><span class="line">sayNameFromWindow2(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>4.如果箭头函数外层没有普通函数，严格模式和非严格模式下它的this都会指向window(全局对象)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    print: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> obj.print(); <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>5.更简洁的语法</p>
<p>箭头函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于普通函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.不能使用new</p>
<p>箭头函数作为匿名函数,是不能作为构造函数的,不能使用new</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  value:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(); <span class="comment">//TypeError: B is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>7.不绑定arguments，用rest参数…解决</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*常规函数使用arguments*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);   <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*箭头函数不能使用arguments*/</span></span><br><span class="line"><span class="keyword">const</span> test2 = <span class="function">(<span class="params">a</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>)&#125;  <span class="comment">//ReferenceError: arguments is not defined</span></span><br><span class="line"><span class="comment">/*箭头函数使用reset参数...解决*/</span></span><br><span class="line"><span class="keyword">let</span> test3=<span class="function">(<span class="params">...a</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(a)&#125; <span class="comment">//22</span></span><br><span class="line"></span><br><span class="line">test1(<span class="number">1</span>);</span><br><span class="line">test2(<span class="number">2</span>);</span><br><span class="line">test3(<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>);</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数的注意事项："><a href="#箭头函数的注意事项：" class="headerlink" title="箭头函数的注意事项："></a>箭头函数的注意事项：</h2><p>1.不能简单返回对象字面量</p>
<p>如果要返回对象时需要用小括号包起来，因为大括号被占用解释为代码块了，正确写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;  <span class="comment">// undefined 想返回一个对象，大括号被占用解释为代码块，执行后返回undefined</span></span><br><span class="line"><span class="keyword">var</span> func2 = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);  <span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>2.箭头函数不能当做Generator函数，不能使用yield关键字</p>
<p>3.箭头函数不能换行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = ()</span><br><span class="line">          =&gt;<span class="number">1</span>; <span class="comment">//SyntaxError: Unexpected token =&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>call、apply 及 bind 函数的区别</title>
    <url>/2019-10-12/Javascript/call%E3%80%81apply-%E5%8F%8A-bind-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>call和apply都用于调用函数，第一个参数将用作函数内 this 的值。然而，call接受逗号分隔的参数作为后面的参数，而apply接受一个参数数组作为后面的参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p><code>bind()</code>方法返回一个新的函数, 新函数的<code>this</code>值指向传入的第一个参数，<code>this</code>被绑定了</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>简述JavaScript中的this</title>
    <url>/2019-10-12/Javascript/%E7%AE%80%E8%BF%B0JavaScript%E4%B8%AD%E7%9A%84this/</url>
    <content><![CDATA[<p>粗略地讲，函数的调用方式决定了<code>this</code>的值，谁调用的函数，<code>this</code>就指向谁。<code>this</code>取值符合以下规则：</p><p>1.如果函数作为构造函数用，那么其中的<code>this</code>就代表它即将<code>new</code>出来的对象。</p><p>2.如果<code>appl</code>、<code>call</code>或<code>bind</code>方法用于调用、创建一个函数，this的值就取传入的对象的值。</p><p>3.如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的<code>this</code>指向该对象。比如当<code>obj.method()</code>被调用时，函数内的 <code>this</code> 将绑定到<code>obj</code>对象。</p><a id="more"></a>



<p>4.如果调用函数不符合上述规则，那么<code>this</code>的值指向全局对象<code>（global object）</code>。浏览器环境下<code>this</code>的值指向<code>window</code>对象，但是在严格模式下<code>(&#39;use strict&#39;)</code>，<code>this</code>的值为<code>undefined</code>。</p>
<p>5.如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定<code>this</code>的值。</p>
<p>6.如果该函数是 ES2015 中的<code>箭头函数</code>，将忽略上面的所有规则，<code>this</code>被设置为它被<code>创建时的上下文</code>。</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
