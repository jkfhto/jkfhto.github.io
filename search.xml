<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前端性能优化衡量指标</title>
    <url>/2019-10-16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h2 id="Performance-API"><a href="#Performance-API" class="headerlink" title="Performance API"></a>Performance API</h2><p>这个 API 是 HTML5 新增的特性。过去我们要统计脚本的运行时间，会使用 Date.getTime() 去获取对应的时间；如果要获取白屏时间是在 head 末尾插入一段获取时间戳的代码，然后用这个时间戳减去开始接收数据的那个时间戳，得出的结果为白屏时间。这样的方法无疑是笨重的，而且获取的时间无法更精确(只能到ms级别)，而且一些后台比较关注的时间根本无法获取。W3C 为了解决这个问题，在 HTML5 推出的时候，新增了这个 API 。</p><a id="more"></a>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">Performance</a> 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API" target="_blank" rel="noopener">Navigation Timing API</a>、 <a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API" target="_blank" rel="noopener">User Timing API</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API" target="_blank" rel="noopener">Resource Timing API</a>。该类型的对象可以通过调用只读属性 Window.performance 来获得。</p>
<p>在控制台输入window.performance，能够获取到相关信息，如下图：</p>
<p><img src="/images/Performance1.png" alt="Performance1"></p>
<p><strong><em>performance</em></strong> 包括了五个属性，其中 <strong><em>timing</em></strong> 是我们需要重点关注的，<strong><em>timing</em></strong> 是一个对象，其中key值是性能优化指标，value值是对应的时间戳。其中这些时间戳与页面整个加载过程中的关键节点是有着一一对应的关系。</p>
<p><img src="/images/Performance2.jpg" alt="Performance2"></p>
<p>从图中可以看到很多指标都是成对出现，这里我们直接求差值，就可以求出对应页面加载过程中关键节点的耗时，这里我们介绍几个比较常用的，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timingInfo = <span class="built_in">window</span>.performance.timing;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DNS解析，DNS查询耗时</span></span><br><span class="line">timingInfo.domainLookupEnd - timingInfo.domainLookupStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP连接耗时</span></span><br><span class="line">timingInfo.connectEnd - timingInfo.connectStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得首字节耗费时间，也叫TTFB</span></span><br><span class="line">timingInfo.responseStart - timingInfo.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// domReady时间(与DomContentLoad事件对应)</span></span><br><span class="line">timingInfo.domContentLoadedEventStart - timingInfo.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM资源下载</span></span><br><span class="line">timingInfo.responseEnd - timingInfo.responseStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备新页面时间耗时</span></span><br><span class="line">timingInfo.fetchStart - timingInfo.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向耗时</span></span><br><span class="line">timingInfo.redirectEnd - timingInfo.redirectStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Appcache 耗时</span></span><br><span class="line">timingInfo.domainLookupStart - timingInfo.fetchStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unload 前文档耗时</span></span><br><span class="line">timingInfo.unloadEventEnd - timingInfo.unloadEventStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request请求耗时</span></span><br><span class="line">timingInfo.responseEnd - timingInfo.requestStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求完毕至DOM加载</span></span><br><span class="line">timingInfo.domInteractive - timingInfo.responseEnd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释dom树耗时</span></span><br><span class="line">timingInfo.domComplete - timingInfo.domInteractive;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从开始至load总耗时</span></span><br><span class="line">timingInfo.loadEventEnd - timingInfo.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白屏时间</span></span><br><span class="line">timingInfo.responseStart - timingInfo.fetchStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首屏时间</span></span><br><span class="line">timingInfo.domComplete - timingInfo.fetchStart;</span><br></pre></td></tr></table></figure>

<h2 id="感官性能优化指标"><a href="#感官性能优化指标" class="headerlink" title="感官性能优化指标"></a>感官性能优化指标</h2><p>普通用户感官体验联系更加紧密的一些指标：</p>
<ul>
<li>First Paint(简称FP)：表示文档中任一元素首次渲染时间。用于标记导航之后浏览器在屏幕上渲染像素的时间点。这个不难理解，就是浏览器开始请求网页到网页首帧绘制的时间点。这个指标表明了网页请求是否成功。</li>
<li>First Contentful Paint(简称FCP)：当浏览器首次渲染任何文本，图像（包括背景图像），非白色画布或SVG时。这个指标就是我们日常说的白屏时间。</li>
<li>First Meaningful Paint(简称FMP)：首次有意义的绘制，这个指标反映的是主要内容出现在页面上所需要的时间，如果FMP时间过长的话，这里就要考虑是不是静态文件阻塞了主线程。这是一个很主观的指标。根据业务的不同，每一个网站的有效内容都是不相同的，有效内容就是网页中”主角元素”。</li>
<li>Time To Interactive(TTI):可交互时间，等到服务器通过HTTP协议将响应全部返回之后，便开始DOM Tree 的构建，完成之后，网页变成可交互状态，到此为止便是网页的可交互时间。用户可以进行正常的事件输入交互操作，这个指标是最重要的用户体验指标，用户最关心的就是什么时候可以进行交互，所以通常这个指标是我们优化的重点。</li>
</ul>
<p><img src="/images/Performance3.jpg" alt="感官性能优化指标"></p>
<ul>
<li>我们可以在控制台输入 <strong><em>window.performance.getEntriesByType(‘paint’)</em></strong> 获取，<strong><em>First Paint(简称FP)</em></strong>，<strong><em>First Contentful Paint(简称FCP)</em></strong>。</li>
<li>另外2个指标我们可以通过性能优化工具 <a href="https://github.com/GoogleChrome/lighthouse" target="_blank" rel="noopener">Lighthouse</a> 实时测量进行获取。</li>
</ul>
<p><img src="/images/Performance4.png" alt="感官性能优化指标2"></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化</title>
    <url>/2019-10-16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="什么是前端性能优化"><a href="#什么是前端性能优化" class="headerlink" title="什么是前端性能优化"></a>什么是前端性能优化</h2><p>从用户访问资源到资源完整的展现在用户面前的过程中，通过技术手段和优化策略，缩短每个步骤的处理时间从而提升整个资源的访问和呈现速度。</p><h2 id="为什么要做前端性能优化"><a href="#为什么要做前端性能优化" class="headerlink" title="为什么要做前端性能优化"></a>为什么要做前端性能优化</h2><p>在构建web站点的过程中，任何一个细节都有可能影响网站的访问速度，如果不了解性能优化知识，很多不利网站访问速度的因素会形成累加，从而严重影响网站的性能，导致网站访问速度变慢，用户体验低下，最终导致用户流失。</p><a id="more"></a>

<h2 id="从浏览器发起请求到页面能正常浏览都有哪些阶段"><a href="#从浏览器发起请求到页面能正常浏览都有哪些阶段" class="headerlink" title="从浏览器发起请求到页面能正常浏览都有哪些阶段"></a>从浏览器发起请求到页面能正常浏览都有哪些阶段</h2><ul>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>HTTP 请求抛出</li>
<li>服务端处理请求，HTTP 响应返回</li>
<li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户</li>
</ul>
<p>针对这五个过程进行分解，我们可以将前端性能优化划分为<strong><em>网络层面</em></strong>和<strong><em>渲染层面</em></strong>两个大的维度，并以此来进行扩展，学习。</p>
<h2 id="性能优化的具体方法"><a href="#性能优化的具体方法" class="headerlink" title="性能优化的具体方法"></a>性能优化的具体方法</h2><h3 id="内容层面"><a href="#内容层面" class="headerlink" title="内容层面"></a>内容层面</h3><ul>
<li>1、DNS解析优化（DNS缓存、减少DNS查找、keep-alive、适当的主机域名）</li>
<li>2、避免重定向（/还是需要的）</li>
<li>3、切分到多个域名</li>
<li>4、杜绝404</li>
</ul>
<h3 id="网络传输阶段"><a href="#网络传输阶段" class="headerlink" title="网络传输阶段"></a>网络传输阶段</h3><ul>
<li>1、减少传输过程中实体的大小<ul>
<li>缓存</li>
<li>cookie优化</li>
<li>文件压缩（Accept-Encoding：g-zip）</li>
</ul>
</li>
<li>2、减少请求的次数<ul>
<li>文件适当的合并</li>
<li>雪碧图</li>
</ul>
</li>
<li>3、异步加载（并发）</li>
<li>4、预加载、延后加载、按需加载</li>
</ul>
<h3 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h3><ul>
<li>1、js放底部，css放顶部</li>
<li>2、减少重绘和回流</li>
<li>3、合理使用Viewport 等meta头部</li>
<li>4、减少dom节点</li>
</ul>
<h3 id="脚本执行阶段"><a href="#脚本执行阶段" class="headerlink" title="脚本执行阶段"></a>脚本执行阶段</h3><ul>
<li>1、缓存节点，尽量减少节点的查找</li>
<li>2、减少节点的操作（innerHTML）</li>
<li>3、避免无谓的循环，break、continue、return的适当使用</li>
<li>4、事件委托</li>
</ul>
<h3 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h3><p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//jkfhto.github.io&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>通过长连接、预连接、接入 SPDY 协议。优化TCP连接。</p>
<h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><ul>
<li>减少 HTTP请求数</li>
<li>减小请求体积</li>
</ul>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/grandPang/article/details/51329289" target="_blank" rel="noopener">前端性能优化归纳总结篇</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入 URL 到页面加载完成，发生了什么？</title>
    <url>/2019-10-16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>从前端的角度出发，主要包括以下几个方面：</p><ul>
<li>浏览器的地址栏输入URL并按下回车。</li>
<li>浏览器查找当前URL是否存在缓存，并比较缓存是否过期。</li>
<li>通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址。</li>
<li>然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接（三次握手）。</li>
<li>随后我们向服务端抛出我们的 HTTP 请求。</li>
<li>服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端。</li>
<li>拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作。</li>
<li>关闭TCP连接（四次挥手）。</li>
</ul><a id="more"></a>

<h3 id="三次握手简单说明"><a href="#三次握手简单说明" class="headerlink" title="三次握手简单说明"></a>三次握手简单说明</h3><p> 所谓三次握手（Three-Way Handshake）即建立TCP连接，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。</p>
<ul>
<li>1.客户端–发送带有SYN标志的数据包–一次握手–服务端（客户端：我要连接你了，可以吗？）</li>
<li>2.服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端（服务端：嗯，我准备好了，连接我吧。）</li>
<li>3.客户端–发送带有带有ACK标志的数据包–三次握手–服务端（客户端：那我连接你咯。）</li>
</ul>
<h3 id="四次挥手简单说明"><a href="#四次挥手简单说明" class="headerlink" title="四次挥手简单说明"></a>四次挥手简单说明</h3><ul>
<li>客户端-发送一个FIN，用来关闭客户端到服务器的数据传送（客户端向服务器发送一个断开连接的请求）</li>
<li>服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号（服务器接到请求后发送确认收到请求的信号）</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端（服务器向主机发送断开通知）</li>
<li>客户端-发回ACK报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.iteye.com/blog/uule-2213562" target="_blank" rel="noopener">TCP协议的三次握手和四次挥手</a></li>
</ul>
]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Event Loop 运行机制</title>
    <url>/2019-10-14/Javascript/Event-Loop-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。</p><h2 id="进程和线程基本概念"><a href="#进程和线程基本概念" class="headerlink" title="进程和线程基本概念"></a>进程和线程基本概念</h2><p>拿出在教科书里的概念：</p><ul>
<li>1、调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li>
<li>2、并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</li>
<li>3、拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源；</li>
<li>4、系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。进程和线程的关系：</li>
</ul><a id="more"></a>


<p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p>
<p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p>
<p>处理机分给线程，即真正在处理机上运行的是线程；</p>
<p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体。</p>
<p>基本总结，一个进程可以有多个线程，线程之间可以相互通信。</p>
<h2 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h2><p>JS 执行是单线程的，意味着 JS 在执行代码的时候一次只能处理一个任务，必须按队列顺序逐个执行。JS 的主要功效是处理前端交互，其中就包括操作 DOM 节点。试想若 JS 是多线程，在处理网页交互时，一个线程需要删除 DOM 节点，另一个线程却是要操作同一个 DOM 节点，这样该如何判断先执行哪个线程？但若队列中存在多个任务，上一个任务的执行会阻塞下一个任务，导致代码执行效率低下。就像 AJAX 请求线程，发出请求后需要等待响应结果，期间 CPU 却是空闲的。对此，JS的事件循环机制（Event Loop）很好地解决了问题。</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里所谓的单线程指的是主线程是单线程的,所以在Node中主线程依旧是单线程的。</span><br></pre></td></tr></table></figure>

<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>JavaScript 将任务分为两种：同步任务和异步任务。</p>
<ul>
<li>同步任务：执行完后能立即得出结果的任务。同步任务在主线程中执行，上一个任务的执行会阻塞下一个任务，在执行过程中产生堆栈。堆中存储复杂数据类型（Object），栈中存储基本数据类型（String、Number、Boolean、Null、Undefined、Symbol）。</li>
<li>异步任务：执行后无法立即得出结果，需要等待一段时间获得相应的任务。其中又分为宏任务（Macrotask）和微任务（Microtask）。<ul>
<li>宏任务：script（整体代码）、setTimeout、setInterval、setImmediate、I/O操作（mouse click、keypress、network event）、UI渲染、requestAnimationTrame等。</li>
<li>微任务：Promise.then、MutationObserver、process.nextTick()等。</li>
</ul>
</li>
</ul>
<h2 id="浏览器-Event-Loop-过程解析"><a href="#浏览器-Event-Loop-过程解析" class="headerlink" title="浏览器 Event Loop 过程解析"></a>浏览器 Event Loop 过程解析</h2><p>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>
<p>JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p>
<p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p>
<ul>
<li><p>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</p>
</li>
<li><p>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</p>
</li>
<li><p>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的（如下图所示）。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</p>
</li>
<li><p>执行渲染操作，更新界面（敲黑板划重点）。</p>
</li>
<li><p>检查是否存在 Web worker 任务，如果有，则对其进行处理 。</p>
</li>
<li><p>上述过程循环往复，直到两个队列都清空</p>
</li>
</ul>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<p>执行过程分析：</p>
<p>全局上下文 <strong><em>（script 标签）</em></strong> 被推入调用栈，同步代码执行。打印 <strong><em>script start</em></strong>，遇到 <strong><em>setTimeout</em></strong>，推入到<strong><em>macro 队列</em></strong>。遇到<strong><em>Promise.resolve().then</em></strong>推入到<strong><em>micro 队列</em></strong>，遇到同步代码。打印 <strong><em>script end</em></strong>。</p>
<p><strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>promise1</em></strong>，遇到 <strong><em>then</em></strong>，推入到<strong><em>macro 队列</em></strong>。<strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>promise2</em></strong>。<strong><em>micro 队列</em></strong> 清空。</p>
<p><strong><em>macro 队列</em></strong> 执行出队列操作，打印 <strong><em>setTimeout</em></strong>，<strong><em>macro 队列</em></strong> 清空。</p>
<h3 id="更复杂的例子"><a href="#更复杂的例子" class="headerlink" title="更复杂的例子"></a>更复杂的例子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="comment">// async2().then(function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log('async1 end')</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise3'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2 end</span></span><br><span class="line"><span class="comment">// Promise1</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// promise3</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<p>执行过程分析：</p>
<p>全局上下文 <strong><em>（script 标签）</em></strong> 被推入调用栈，同步代码执行。打印 <strong><em>script start</em></strong>，遇到 <strong><em>setTimeout</em></strong>，推入到<strong><em>macro 队列</em></strong>。执行 <strong><em>async1</em></strong> ，打印 <strong><em>async1 start</em></strong> 。执行 <strong><em>await async2()</em></strong>，相当于先执行 <strong><em>async2</em></strong> 这个 <strong><em>Promise</em></strong> 函数，打印 <strong><em>async2 end</em></strong>，然后执行 <strong><em>then</em></strong>，<strong><em>micro</em></strong> 任务 <strong><em>console.log(‘async1 end’)</em></strong> 入队列。遇到 <strong><em>new Promise</em></strong>，同步任务，打印 <strong><em>Promise1</em></strong>，执行 <strong><em>resolve()</em></strong>，<strong><em>micro</em></strong> 任务 <strong><em>console.log(‘promise2’)</em></strong> 入队列。遇到同步任务，打印 <strong><em>script end</em></strong>；</p>
<p><strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>async1 end</em></strong>，然后打印 <strong><em>promise2</em></strong>，遇到 <strong><em>then</em></strong>，<strong><em>console.log(‘promise3’)</em></strong>，推入到<strong><em>macro 队列</em></strong>。<strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>promise3</em></strong>。<strong><em>micro 队列</em></strong> 清空。</p>
<p><strong><em>macro 队列</em></strong> 执行出队列操作，打印 <strong><em>setTimeout</em></strong>，<strong><em>macro 队列</em></strong> 清空。</p>
<h2 id="NodeJS-Event-Loop-过程解析"><a href="#NodeJS-Event-Loop-过程解析" class="headerlink" title="NodeJS Event Loop 过程解析"></a>NodeJS Event Loop 过程解析</h2><p><img src="/images/EventLoop.jpg" alt="Event Loop"></p>
<p>Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。</p>
<p><img src="/images/EventLoop2.jpg" alt="Event Loop2"></p>
<p>Node的Event loop一共分为6个阶段，每个细节具体如下：</p>
<ul>
<li>timers: 执行setTimeout和setInterval中到期的callback。</li>
<li>pending callback: 执行延迟到下一个循环迭代的 I/O 回调。</li>
<li>idle, prepare: 仅在内部使用。</li>
<li>poll: 最重要的阶段，执行pending callback，检索新的 I/O 事件;执行与 I/O 相关的回调，在适当的情况下回阻塞在这个阶段。</li>
<li>check: 执行setImmediate() 设定的callbacks。</li>
<li>close callbacks: 执行close事件的callback，例如socket.on(‘close’[,fn])或者http.server.on(‘close, fn)。</li>
</ul>
<h3 id="timers"><a href="#timers" class="headerlink" title="timers"></a>timers</h3><p>执行 <strong><em>setTimeout</em></strong> 和 <strong><em>setInterval</em></strong> 中到期的 <strong><em>callback</em></strong>，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行<strong><em>callback</em></strong> 回调，但是由于 <strong><em>system的调度</em></strong> 可能会延时，达不到预期时间。</p>
<h3 id="pending-callbacks"><a href="#pending-callbacks" class="headerlink" title="pending callbacks"></a>pending callbacks</h3><p>此阶段执行某些系统操作的回调，例如TCP错误的类型。 例如，如果TCP套接字在尝试连接时收到ECONNREFUSED，则某些* nix系统希望等待报告错误。 这将在pending callbacks阶段执行。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 阶段有两个重要的功能：</p>
<ul>
<li>执行与 I/O 相关的回调</li>
<li>然后，处理 poll 队列里的事件</li>
</ul>
<p>当事件循环进入 <strong><em>poll</em></strong> 阶段并且在 <strong><em>timers</em></strong> 队列中没有可以执行定时器时，将发生以下两种情况之一</p>
<ul>
<li>如果 <strong><em>poll</em></strong> 队列不为空，事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制。遇到 <strong><em>setImmediate</em></strong> 将其回调放入 <strong><em>setImmediate</em></strong> 队列。</li>
<li>如果poll队列为空，则会发生以下情况：<ul>
<li>如果有 <strong><em>setImmediate()</em></strong> 回调，则会立即停止执行 <strong><em>poll</em></strong> 阶段并进入执行 <strong><em>check</em></strong> 阶段以执行 <strong><em>setImmediate</em></strong> 回调，清空 <strong><em>check</em></strong>队列。执行完<strong><em>setImmediate</em></strong> ，事件循环将绕回 timers 阶段</li>
<li>如果没有 <strong><em>setImmediate()</em></strong> 回调，一方面将等待 <strong><em>I/O</em></strong> 相关的回调被添加到 <strong><em>poll</em></strong> 队列中，然后立即执行。另一方面如果一个或多个计时器回调已准备就绪，则事件循环将绕回 <strong><em>timers</em></strong> 阶段以执行这些计时器的回调。简言之就是，<strong><em>I/O</em></strong> 相关的回调和 <strong><em>timers</em></strong> 相关的回调谁先有结果就先执行谁。</li>
</ul>
</li>
</ul>
<h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p>此阶段允许人员在 <strong><em>poll</em></strong> 阶段完成后立即执行回调。如果 <strong><em>poll</em></strong> 阶段变为空闲状态，并且脚本已排队使用 setImmediate()，则事件循环继续到 <strong><em>check</em></strong> 阶段而不是等待。</p>
<p><strong><em>setImmediate()</em></strong> 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个 <strong><em>libuv API</em></strong> 来安排回调在 <strong><em>poll</em></strong> 阶段完成后执行。</p>
<p>通常，在执行代码时，事件循环最终将达到 <strong><em>poll</em></strong> 阶段，等待传入连接、请求等。如果已经调度了回调setImmediate()，并且轮询阶段变为空闲，则它将结束并且到达check阶段，而不是等待poll事件。</p>
<h3 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h3><p>如果 <strong><em>socket</em></strong> 或 <strong><em>handle</em></strong> 处理函数突然关闭（例如 socket.destroy()），则’close’ 事件将在这个阶段发出。否则它将通过 process.nextTick() 发出。</p>
<h3 id="setImmediate-的setTimeout-的区别"><a href="#setImmediate-的setTimeout-的区别" class="headerlink" title="setImmediate() 的setTimeout()的区别"></a>setImmediate() 的setTimeout()的区别</h3><p>setImmediate() 和 setTimeout() 很类似，但何时调用行为完全不同。</p>
<ul>
<li>setImmediate()：设计用于在当前poll阶段完成后check阶段执行脚本 。</li>
<li>setTimeout()：安排在经过最小（ms）后运行的脚本，在timers阶段执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码的执行结果，受到进程性能的限制。其结果也不一致。</p>
<p>如果在I / O周期内移动两个调用，则始终首先执行 <strong><em>setImmediate</em></strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>主要原因是在 <strong><em>I/O</em></strong> 阶段读取文件后，事件循环会先进入 <strong><em>poll</em></strong> 阶段，发现有 <strong><em>setImmediate</em></strong> 需要执行，会立即进入check阶段执行<strong><em>setImmediate</em></strong> 的回调。</p>
<p>然后再进入 <strong><em>timers</em></strong> 阶段，执行 <strong><em>setTimeout</em></strong>，打印 <strong><em>timeout</em></strong>。</p>
<h3 id="Process-nextTick"><a href="#Process-nextTick" class="headerlink" title="Process.nextTick()"></a>Process.nextTick()</h3><p>当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p>
<h3 id="一个完整的-NodeJS-Event-Loop-过程"><a href="#一个完整的-NodeJS-Event-Loop-过程" class="headerlink" title="一个完整的 NodeJS Event Loop 过程"></a>一个完整的 <strong><em>NodeJS Event Loop</em></strong> 过程</h3><p>一个完整的 <strong><em>NodeJS Event Loop</em></strong> 过程，可以概括为以下阶段：</p>
<ul>
<li>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li>
<li>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</li>
<li>上一步我们出队的是一个 <strong><em>macro-task</em></strong>，这一步我们处理的是 <strong><em>micro-task</em></strong>。会逐个执行队列中的任务并把它出队，直到队列被清空。同时请注意， <strong><em>Process.nextTick</em></strong> 的优先级高于 <strong><em>Promise.then</em></strong></li>
<li>进入 <strong><em>timers</em></strong> 阶段，执行 <strong><em>setTimeout</em></strong> 和 <strong><em>setInterval</em></strong> 中到期的 <strong><em>callback</em></strong>。</li>
<li>如果 <strong><em>timers</em></strong> 阶段，没有 <strong><em>setTimeout</em></strong> 和 <strong><em>setInterval</em></strong> 到期的回调，会进入 <strong><em>poll</em></strong> 阶段。当事件循环进入poll阶段并且在timers中没有可以执行定时器时，将发生以下两种情况之一。<ul>
<li>如果 <strong><em>poll</em></strong> 队列不为空，事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制。遇到 <strong><em>setImmediate</em></strong> 将其回调放入 <strong><em>setImmediate</em></strong> 队列。</li>
<li>如果poll队列为空，则会发生以下情况：<ul>
<li>如果有 <strong><em>setImmediate()</em></strong> 回调，则会立即停止执行 <strong><em>poll</em></strong> 阶段并进入执行 <strong><em>check</em></strong> 阶段以执行 <strong><em>setImmediate</em></strong> 回调，清空 <strong><em>check</em></strong>队列。执行完<strong><em>setImmediate</em></strong> ，事件循环将绕回 timers 阶段</li>
<li>如果没有 <strong><em>setImmediate()</em></strong> 回调，一方面将等待 <strong><em>I/O</em></strong> 相关的回调被添加到 <strong><em>poll</em></strong> 队列中，然后立即执行。另一方面如果一个或多个计时器回调已准备就绪，则事件循环将绕回 <strong><em>timers</em></strong> 阶段以执行这些计时器的回调。简言之就是，<strong><em>I/O</em></strong> 相关的回调和 <strong><em>timers</em></strong> 相关的回调谁先有结果就先执行谁。</li>
</ul>
</li>
</ul>
</li>
<li>注意，<strong><em>pending callback</em></strong>，<strong><em>idle, prepare</em></strong> 这两个阶段我们通常不用考虑。</li>
<li>同时请注意，如果node版本为v11.x，会执行一个 <strong><em>macro-task</em></strong>，然后处理 <strong><em>micro-task</em></strong>。会逐个执行 <strong><em>micro-task</em></strong> 队列中的任务并把它出队，直到队列被清空，与浏览器效果类似。如果node版本为v11.x以下版本，会执行完所有的 <strong><em>macro-task</em></strong>，清空 <strong><em>macro-task</em></strong> 队列。然后，执行 <strong><em>macro-task</em></strong>，清空 <strong><em>micro-task</em></strong> 队列。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> endTime = +<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout用时共计："</span> + (endTime - beginTime) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">fs.readFile(path.resolve(__dirname, <span class="string">'./test copy.js'</span>), () =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> endTime = +<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"readFile1用时共计："</span> + (endTime - beginTime) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'aaaa'</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">fs.readFile(path.resolve(__dirname, <span class="string">'./test copy.js'</span>), () =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> endTime = +<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"readFile2用时共计："</span> + (endTime - beginTime) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bbb'</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate2'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况1</span></span><br><span class="line"><span class="comment">// readFile1用时共计：3ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// timeout用时共计：14ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// readFile2用时共计：15ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况2</span></span><br><span class="line"><span class="comment">// timeout用时共计：3ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// readFile1用时共计：12ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// readFile2用时共计：13ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况3</span></span><br><span class="line"><span class="comment">// readFile2用时共计：2ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"><span class="comment">// timeout用时共计：12ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// readFile1用时共计：12ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况4</span></span><br><span class="line"><span class="comment">// readFile1用时共计：2ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// readFile2用时共计：9ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"><span class="comment">// timeout用时共计：10ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.zhufengpeixun.cn/main/course/index.html" target="_blank" rel="noopener">珠峰前端架构师</a></li>
<li><a href="https://juejin.im/post/5c3d8956e51d4511dc72c200" target="_blank" rel="noopener">一次弄懂Event Loop（彻底解决此类面试问题）</a></li>
<li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">The Node.js Event Loop, Timers, and process.nextTick()</a></li>
</ul>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP 面向切片编程</title>
    <url>/2019-10-14/Javascript/AOP-%E9%9D%A2%E5%90%91%E5%88%87%E7%89%87%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="AOP-面向切片编程"><a href="#AOP-面向切片编程" class="headerlink" title="AOP 面向切片编程"></a>AOP 面向切片编程</h2><p><strong><em>AOP（面向切面编程）</em></strong> 的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括<strong><em>日志统计</em></strong>、<strong><em>安全控制</em></strong>、<strong><em>异常处理</em></strong> 等。把这些功能抽离出来之后，再通过 <strong><em>动态植入</em></strong> 的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的 <strong><em>纯净</em></strong> 和 <strong><em>高内聚性</em></strong> ，其次是可以很方便地复用日志统计等功能模块。</p><a id="more"></a>
<p>在 JavaScript中实现 <strong><em>AOP</em></strong>，都是指把一个函数<strong><em>动态植入</em></strong>到另外一个函数之中，通常是基于<strong><em>高阶函数</em></strong>实现的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高阶函数，返回一个新的函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforefn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __self = <span class="keyword">this</span>; <span class="comment">// 保存原函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回包含了原函数和新函数的"代理"函数</span></span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行新函数，修正 this</span></span><br><span class="line">        <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行原函数 并返回原函数执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数，返回一个新的函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterfn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行原函数</span></span><br><span class="line">        afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行新函数，修正 this</span></span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">// 返回原函数执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">func = func.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line">func();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="数据统计上报"><a href="#数据统计上报" class="headerlink" title="数据统计上报"></a>数据统计上报</h2><p><strong><em>分离业务代码和数据统计</em></strong> 代码，无论在什么语言中，都是 <strong><em>AOP</em></strong> 的经典应用之一。在项目开发的结尾阶段难免要加上很多统计数据的代码，这些过程可能让我们被迫改动早已封装好的函数。</p>
<p>比如页面中有一个登录 button，点击这个 button会弹出登录浮层，与此同时要进行数据上报，来统计有多少用户点击了这个登录 button：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">tag</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>点击打开登录浮层<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</span></span><br><span class="line"><span class="javascript">        log( <span class="keyword">this</span>.getAttribute( <span class="string">'tag'</span> ) );</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"> tag </span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'上报标签为: '</span> + tag);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// (new Image).src = 'http:// xxx.com/report?tag=' + tag; // 真正的上报代码略</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById( <span class="string">'button'</span> ).onclick = showLogin;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>showLogin</em></strong> 函数里，既要负责打开登录浮层，又要负责数据上报，这是两个层面的功能，在此处却被耦合在一个函数里。使用 <strong><em>AOP</em></strong> 分离之后，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">tag</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>点击打开登录浮层<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterfn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">            afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> ret;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'上报标签为: '</span> + <span class="keyword">this</span>.getAttribute(<span class="string">'tag'</span>));</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    showLogin = showLogin.after(log); <span class="comment">// 打开登录浮层之后上报数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).onclick = showLogin;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="用AOP动态改变函数的参数"><a href="#用AOP动态改变函数的参数" class="headerlink" title="用AOP动态改变函数的参数"></a>用AOP动态改变函数的参数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span> (<span class="params">type, url, param</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(param); <span class="comment">// 发送 ajax 请求的代码略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getToken = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Token'</span>;</span><br><span class="line">&#125;</span><br><span class="line">ajax = ajax.before(<span class="function"><span class="keyword">function</span> (<span class="params">type, url, param</span>) </span>&#123;</span><br><span class="line">    param.Token = getToken();</span><br><span class="line">&#125;);</span><br><span class="line">ajax(<span class="string">'get'</span>, <span class="string">'http:// xxx.com/userinfo'</span>, &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;);</span><br><span class="line"><span class="comment">// 从 ajax 函数打印的 log可以看到， Token 参数已经被附加到了 ajax 请求的参数中：</span></span><br><span class="line"><span class="comment">// &#123; name: "sven", Token: "Token" &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>beforefn</em></strong> 和原函数 <strong><em>__self</em></strong>  共用一组参数列表<strong><em>arguments</em></strong> ，当我们在 <strong><em>beforefn</em></strong> 的函数体内改变 <strong><em>arguments</em></strong> 的时候，原函数 <strong><em>__self</em></strong> 接收的参数列表自然也会变化。</p>
<p>明显可以看到，用 <strong><em>AOP</em></strong> 的方式给 <strong><em>ajax</em></strong> 函数动态装饰上 <strong><em>Token</em></strong> 参数，保证了 <strong><em>ajax</em></strong> 函数是一个相对纯净的函数，提高了 <strong><em>ajax</em></strong> 函数的可复用性，它在被迁往其他项目的时候，不需要做任何修改。</p>
<h2 id="插件式的表单验证"><a href="#插件式的表单验证" class="headerlink" title="插件式的表单验证"></a>插件式的表单验证</h2><p>在表单数据提交给后台之前，常常要做一些校验，比如登录的时候需要验证用户名和密码是否为空，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line">    密码： <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"submitBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>),</span></span><br><span class="line"><span class="javascript">        password = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>),</span></span><br><span class="line"><span class="javascript">        submitBtn = <span class="built_in">document</span>.getElementById(<span class="string">'submitBtn'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforefn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) === <span class="literal">false</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// beforefn 返回 false 的情况直接 return，不再执行后面的原函数</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 可以做相关提示操作</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> validata = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (username.value === <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'用户名不能为空'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (password.value === <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'密码不能为空'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> formSubmit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> param = &#123;</span></span><br><span class="line">            username: username.value,</span><br><span class="line">            password: password.value</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        ajax(<span class="string">'http:// xxx.com/login'</span>, param);</span></span><br><span class="line">    &#125;</span><br><span class="line">    formSubmit = formSubmit.before(validata);</span><br><span class="line"><span class="javascript">    submitBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        formSubmit();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>校验输入和提交表单的代码完全分离开来，它们不再有任何耦合关系。</p>
<p>值得注意的是，因为函数通过 <strong><em>Function.prototype.before</em></strong> 或者 <strong><em>Function.prototype.after</em></strong> 被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">func.a = <span class="string">'a'</span>;</span><br><span class="line">func = func.after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(func.a); <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure>

<p>另外，这种装饰方式也叠加了<strong><em>函数的作用域</em></strong>，如果装饰的链条过长，性能上也会受到一些影响。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">javascript 设计模式与开发实践</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-深拷贝浅析</title>
    <url>/2019-10-14/Javascript/JavaScript-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(object))</span><br></pre></td></tr></table></figure><p>该方法有以下几个问题：</p><ul>
<li>会忽略 undefined</li>
<li>会忽略 symbol</li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
<li>不能正确处理new Date()</li>
<li>不能处理正则</li>
</ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'111'</span>,</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    b: <span class="built_in">Symbol</span>(<span class="string">'111'</span>),</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;name: "111"&#125;</span></span><br></pre></td></tr></table></figure><a id="more"></a>





<h2 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj,hash = new WeakMap(</span>))</span>&#123;</span><br><span class="line">    <span class="comment">//避免引用循环 比较对象与对象属性是否相等</span></span><br><span class="line">    <span class="comment">// if (obj === parent) return parent;</span></span><br><span class="line">    <span class="comment">//处理null undefined</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">//处理string boolean number</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">    <span class="keyword">if</span>(hash.has(obj))&#123;</span><br><span class="line">        <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理 array object</span></span><br><span class="line">    <span class="keyword">let</span> instance = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">    hash.set(obj, instance)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="comment">//递归实现深拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key))&#123;</span><br><span class="line">            instance[key] = deepClone(obj[key], hash);</span><br><span class="line">            <span class="comment">// instance[key] = deepClone(obj[key], obj);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line">obj.b = obj;</span><br><span class="line"><span class="keyword">var</span> cloneObj = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(cloneObj === obj, cloneObj)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-高阶函数浅析</title>
    <url>/2019-10-13/Javascript/JavaScript-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数英文叫 Higher-order function，它的定义很简单，就是至少满足下列一个条件的函数：</p><ul>
<li>函数作为返回值</li>
<li>函数作为参数传递</li>
</ul><p>也就是说高阶函数是对其他函数进行操作的函数，可以将它们作为参数传递，或者是返回函数。 </p><h2 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h2><p>JavaScript 语言中内置了一些高阶函数，比如 Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce，它们接受一个函数作为参数，并使用这个函数作用到列表的每一个元素</p><a id="more"></a>



<h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map"></a>Array.prototype.map</h3><p><strong><em>map()</em></strong> 函数返回一个新的数组，新数组中的元素是<strong><em>回调函数（callback）</em></strong>作用于指定数组中的元素后返回的结果。</p>
<ul>
<li>不会改变原始数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), <span class="title">thisValue</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>function(currentValue, index,arr)：必须。函数，数组中的每个元素都会执行这个函数<ul>
<li>currentValue：必须。当前元素的值</li>
<li>可选。当前元素的索引值</li>
<li>arr：可选。当前元素属于的数组对象</li>
</ul>
</li>
<li>thisValue：可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined”</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( arr2 );</span><br><span class="line"><span class="comment">// [2, 6, 12, 18]</span></span><br><span class="line"><span class="built_in">console</span>.log( arr1 );</span><br><span class="line"><span class="comment">// [1, 3, 6, 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter"></a>Array.prototype.filter</h3><p><strong><em>filter()</em></strong> 方法返回一个新数组, 新数组中的元素是通过检查指定数组中符合条件的所有元素。</p>
<ul>
<li>不会对空数组进行检测</li>
<li>不会改变原始数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), <span class="title">thisValue</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>function(currentValue, index,arr)：必须。函数，数组中的每个元素都会执行这个函数<ul>
<li>currentValue：必须。当前元素的值</li>
<li>可选。当前元素的索引值</li>
<li>arr：可选。当前元素属于的数组对象</li>
</ul>
</li>
<li>thisValue：可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined”</li>
</ul>
<p>数组去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.filter( <span class="function">(<span class="params">element, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf( element ) === index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( arr2 );</span><br><span class="line"><span class="comment">// [1, 2, 3, 5, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log( arr1 );</span><br><span class="line"><span class="comment">// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce"></a>Array.prototype.reduce</h3><p><strong><em>reduce()</em></strong> 方法对数组中的每个元素执行一个由您提供的<strong><em>reducer</em></strong>函数(升序执行)，回调函数<strong><em>（callback）</em></strong>，将其结果汇总为单个返回值。除了 <strong><em>callback</em></strong> 之外还可以接受初始值 <strong><em>initialValue</em></strong> 值（可选）</p>
<ul>
<li><p>如果没有提供 initialValue，那么第一次调用 callback 函数时，accumulator 使用原数组中的第一个元素，currentValue 即是数组中的第二个元素。 在没有初始值的空数组上调用 reduce 将报错。</p>
</li>
<li><p>如果提供了 initialValue，那么将作为第一次调用 callback 函数时的第一个参数的值，即 accumulator，currentValue 使用原数组中的第一个元素。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>)</span>&#123;&#125;, initialValue)</span><br></pre></td></tr></table></figure>

<ul>
<li>function(accumulator, currentValue, currentIndex, array)：必须。函数<ul>
<li>Accumulator (acc)：累计器</li>
<li>Current Value (cur)：当前值</li>
<li>Current Index (idx)：当前索引 可选</li>
<li>Source Array (src)：源数组 可选</li>
</ul>
</li>
<li>initialValue：initialValue</li>
</ul>
<p>数组求和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> sum = arr.reduce(<span class="function">(<span class="params">accumulator, currentValue, currentIndex, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( sum );</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log( arr );</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h2><h3 id="isType-函数"><a href="#isType-函数" class="headerlink" title="isType 函数"></a>isType 函数</h3><p>通过 <strong><em>Object.prototype.toString.call</em></strong>判断类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isType = <span class="function"><span class="params">type</span> =&gt;</span> <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object '</span> + type + <span class="string">']'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isType(<span class="string">'String'</span>)(<span class="string">'123'</span>) <span class="comment">// true</span></span><br><span class="line">isType(<span class="string">'Array'</span>)([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// true</span></span><br><span class="line">isType(<span class="string">'Number'</span>)(<span class="number">123</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="add-函数"><a href="#add-函数" class="headerlink" title="add 函数"></a>add 函数</h3><p>一个常见的面试题，用 JS 实现一个无限累加的函数 add，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)； <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)； <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>都是将函数作为返回值输出，然后接收新的参数并进行计算。</p>
<p>我们知道打印函数时会自动调用 toString()方法，函数 add(a) 返回一个闭包 sum(b)，函数 sum() 中累加计算 a = a + b，只需要重写sum.toString()方法返回结果值 a 就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        a = a + b; <span class="comment">// 求和</span></span><br><span class="line">        <span class="keyword">return</span> sum; <span class="comment">// 返回求和函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写toString()方法</span></span><br><span class="line">    sum.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">// 返回求和函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://muyiy.cn/blog/6/6.1.html" target="_blank" rel="noopener">https://muyiy.cn/blog/6/6.1.html</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript深入之继承的多种方式和优缺点</title>
    <url>/2019-10-12/Javascript/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'kevin'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()) <span class="comment">// kevin</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p>核心： 将父类的实例作为子类的原型</p>
<p>特点：实例可继承的属性有：Child实例的构造函数的属性，父类构造函数属性，父类原型的属性。</p>
<p>缺点：</p>
<ul>
<li>1.父类引用类型的属性被所有实例共享。</li>
<li>2.在创建 Child 的实例时，不能向Parent传参。</li>
</ul>
<h2 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2.借用构造函数"></a>2.借用构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.names = [<span class="string">'kevin'</span>, <span class="string">'daisy'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">'yayu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["kevin", "daisy"]</span></span><br></pre></td></tr></table></figure>

<p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类。</p>
<p>特点：</p>
<ul>
<li>解决了原型链继承中，子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承（call多个父类对象）</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能继承父类构造函数的属性和方法，不能继承原型上的属性/方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，浪费内存，影响性能</li>
</ul>
<h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line">child1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors); <span class="comment">// ["red", "blue", "green", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'daisy'</span>, <span class="string">'20'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors); <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure>

<p>核心：原型链继承和经典继承双剑合璧。</p>
<p>优点：可以继承父类原型上的属性，可以传参，可复用。融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p>
<p>缺点：调用了两次父类构造函数（耗内存）。</p>
<h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// o一般指向父类原型</span></span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="comment">// 实例化空函数，可以继承父类原型上的方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是 ES5 <strong><em>Object.create</em></strong> 的模拟实现，将传入的对象作为创建的对象的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'kevin'</span>,</span><br><span class="line">    friends: [<span class="string">'daisy'</span>, <span class="string">'kelly'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">var</span> person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'person1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.firends.push(<span class="string">'taylor'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["daisy", "kelly", "taylor"]</span></span><br></pre></td></tr></table></figure>

<p>注意：修改<strong><em>person1.name</em></strong>的值，<strong><em>person2.name</em></strong>的值并未发生改变，并不是因为<strong><em>person1</em></strong>和<strong><em>person2</em></strong>有独立的 <strong>*name *</strong>值，而是因为<strong><em>person1.name = ‘person1’</em></strong>，给<strong><em>person1</em></strong>添加了 <strong><em>name</em></strong> 值，并非修改了原型上的 <strong><em>name</em></strong> 值，<strong><em>person2.name</em></strong>获取的是原型上的值。</p>
<p>核心：使用一个空函数作为过渡对象，让空函数的prototype 指向需要继承的对象，返回实例化的空函数。</p>
<p>优点：空函数作为过渡对象，构造函数无内容，可以较少开销。</p>
<p>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>
<h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = createObj(o);</span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心：寄生式继承就是对原型式继承的第二次封装，在第二次封装过程中对继承的对象进行了扩展，这样新创建的对象不仅可以继承父类中的属性和方法而且还添加了新的属性和方法。</p>
<h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// o一般指向父类原型</span></span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="comment">// 实例化空函数，可以继承父类原型上的方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过原型式继承，继承父类原型上的属性和方法</span></span><br><span class="line">    <span class="keyword">var</span> prototype = createObj(parent.prototype);</span><br><span class="line">    <span class="comment">// 添加新的属性，修复子类的构造函数</span></span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    <span class="comment">// 修改子类的原型，保留子类的构造函数，继承父类原型上的属性和方法</span></span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  借用构造函数</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">prototype(Child, Parent);</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>

<p>核心：寄生式继承和借用构造函数的经典组合。</p>
<p>借用构造函数，继承了构造函数中的属性和方法。通过原型继承可以继承父类原型的属性和方法，由于原型继承中，使用空函数作为过渡对象，构造函数无内容，可以较少开销。直接通过原型继承存在一个问题，子类的构造函数将会丢失。所以通过，寄生式继承对原型继承的结果进行扩展，修复其构造函数指向的不正确问题。最后将子类原型指向这个结果。</p>
<p>寄生组合式继承是引用类型最理想的继承范式。</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>==和===的区别是什么？</title>
    <url>/2019-10-12/Javascript/%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>==</strong>是抽象相等运算符，而<strong>===</strong>是严格相等运算符。<br><strong>==</strong>运算符是在进行必要的类型转换后，再比较。<br><strong>===</strong>运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回false。<br>使用<strong>==</strong>时，可能发生一些特别的事情，例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">'1'</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == [<span class="number">1</span>]; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">''</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">'0'</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p>除了方便与null或undefined比较时，最好不使用==运算符</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript深入之new的模拟实现</title>
    <url>/2019-10-12/Javascript/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8Bnew%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="new实例化"><a href="#new实例化" class="headerlink" title="new实例化"></a>new实例化</h2><ul>
<li>返回一个新的对象</li>
<li>新对象可以访问构造函数里的属性和方法</li>
<li>新对象可以访问 prototype 上的属性和方法</li>
</ul><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 mockNew，来模拟 new 的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 需要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 获取需要实例化的构造函数</span></span><br><span class="line">    <span class="comment">// shift 会返回构造函数，修改原数组，所以 arguments 会被去除第一个参数</span></span><br><span class="line">    <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 继承原型上的属性和方法</span></span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="comment">//继承构造函数的属性和方法</span></span><br><span class="line">    Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<h2 id="兼容返回值类型"><a href="#兼容返回值类型" class="headerlink" title="兼容返回值类型"></a>兼容返回值类型</h2><p>我们还需要判断构造函数的返回值，如果构造函数的返回值是一个引用类型的对象，我们就返回构造函数的返回值，如果不是，我们该返回什么就返回什么。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 需要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 获取需要实例化的构造函数</span></span><br><span class="line">    <span class="comment">// shift 会返回构造函数，修改原数组，所以 arguments 会被去除第一个参数</span></span><br><span class="line">    <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 继承原型上的属性和方法</span></span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="comment">// 继承构造函数的属性和方法</span></span><br><span class="line">    <span class="keyword">var</span> result = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 兼容返回值类型 </span></span><br><span class="line">    <span class="comment">// 如果构造函数的返回值是一个引用类型的对象，我们就返回构造函数的返回值，否则返回obj</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/13</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>bind的模拟实现</title>
    <url>/2019-10-12/Javascript/bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="bind的作用"><a href="#bind的作用" class="headerlink" title="bind的作用"></a>bind的作用</h2><ul>
<li>bind()方法返回一个新的函数,</li>
<li>新函数的this值指向传入的第一个参数，this被绑定了</li>
<li>bind 的时候可以传递参数，进行绑定</li>
<li>bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效</li>
</ul><h2 id="返回函数的模拟实现"><a href="#返回函数的模拟实现" class="headerlink" title="返回函数的模拟实现"></a>返回函数的模拟实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="兼容参数处理"><a href="#兼容参数处理" class="headerlink" title="兼容参数处理"></a>兼容参数处理</h2><p>bind 的时候可以传递参数，进行绑定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//绑定参数</span></span><br><span class="line">    <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 指向函数 返回结果</span></span><br><span class="line">        <span class="comment">// 最终执行结果的参数，需要将bindArgs，args使用concat合并</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(context, bindArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="兼容构造函数"><a href="#兼容构造函数" class="headerlink" title="兼容构造函数"></a>兼容构造函数</h2><p>bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 指向函数 返回结果</span></span><br><span class="line">        <span class="comment">// 最终执行结果的参数，需要将bindArgs，args使用concat合并</span></span><br><span class="line">        <span class="comment">// bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，this指向fBound，但传入的参数依然生效</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : context, bindArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="兼容绑定函数原型上的属性"><a href="#兼容绑定函数原型上的属性" class="headerlink" title="兼容绑定函数原型上的属性"></a>兼容绑定函数原型上的属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 指向函数 返回结果</span></span><br><span class="line">        <span class="comment">// 最终执行结果的参数，需要将bindArgs，args使用concat合并</span></span><br><span class="line">        <span class="comment">// bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，this指向fBound，但传入的参数依然生效</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : context, bindArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span></span><br><span class="line">    <span class="comment">// 直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype</span></span><br><span class="line">    <span class="comment">// fBound.prototype = this.prototype;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过一个空函数来进行中转</span></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="兼容调用-bind-的不是函数"><a href="#兼容调用-bind-的不是函数" class="headerlink" title="兼容调用 bind 的不是函数"></a>兼容调用 bind 的不是函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用bind的不是函数，直接报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 指向函数 返回结果</span></span><br><span class="line">        <span class="comment">// 最终执行结果的参数，需要将bindArgs，args使用concat合并</span></span><br><span class="line">        <span class="comment">// bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，this指向fBound，但传入的参数依然生效</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : context, bindArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span></span><br><span class="line">    <span class="comment">// 直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype</span></span><br><span class="line">    <span class="comment">// fBound.prototype = this.prototype;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过一个空函数来进行中转</span></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/12</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>call和apply的模拟实现</title>
    <url>/2019-10-12/Javascript/call%E5%92%8Capply%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="call的特点"><a href="#call的特点" class="headerlink" title="call的特点"></a>call的特点</h2><ul>
<li>可以改变当前函数的this指向</li>
<li>让当前函数执行</li>
</ul><h2 id="call模拟实现"><a href="#call模拟实现" class="headerlink" title="call模拟实现"></a>call模拟实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;<span class="comment">// 兼容context，Object(context)兼容context为string的情况</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>; <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">//获取参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    <span class="comment">// args 会自动调用 Array.toString() 这个方法</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args +<span class="string">')'</span>);</span><br><span class="line">    <span class="comment">// 删除该函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="apply-模拟实现"><a href="#apply-模拟实现" class="headerlink" title="apply 模拟实现"></a>apply 模拟实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;<span class="comment">// 兼容context，Object(context)兼容context为string的情况</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>; <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (!args) &#123;</span><br><span class="line">        <span class="comment">// 没有传参直接直接函数</span></span><br><span class="line">        result = context.fn()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = args.length; i &lt; len; i++) &#123;</span><br><span class="line">            arr.push(<span class="string">'args['</span> + i + <span class="string">']'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// arr 会自动调用 Array.toString() 这个方法</span></span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + arr + <span class="string">')'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除该函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用let、var和const创建变量有什么区别？</title>
    <url>/2019-10-12/Javascript/%E4%BD%BF%E7%94%A8let%E3%80%81var%E5%92%8Cconst%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<p>用<strong><em>var</em></strong>声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。<strong><em>let</em></strong>和<strong><em>const</em></strong>是块级作用域，意味着它们只能在最近的一组花括号<strong><em>（function、if-else 代码块或 for 循环中）</em></strong>中访问。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 所有变量在函数中都可访问</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">'bar'</span>;</span><br><span class="line">  <span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line">  <span class="keyword">const</span> qux = <span class="string">'qux'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// bar</span></span><br><span class="line">  <span class="built_in">console</span>.log(baz); <span class="comment">// baz</span></span><br><span class="line">  <span class="built_in">console</span>.log(qux); <span class="comment">// qux</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// ReferenceError: bar is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// ReferenceError: baz is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(qux); <span class="comment">// ReferenceError: qux is not defined</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">'bar'</span>;</span><br><span class="line">  <span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line">  <span class="keyword">const</span> qux = <span class="string">'qux'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 var 声明的变量在函数作用域上都可访问</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// let 和 const 定义的变量在它们被定义的语句块之外不可访问</span></span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// ReferenceError: baz is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(qux); <span class="comment">// ReferenceError: qux is not defined</span></span><br></pre></td></tr></table></figure>

<p><strong><em>var</em></strong>会使变量提升，这意味着变量可以在声明之前使用。<strong><em>let</em></strong>和<strong><em>const</em></strong>不会使变量提升，提前使用会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// ReferenceError: can't access lexical declaration 'baz' before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// ReferenceError: can't access lexical declaration 'bar' before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure>

<p>用<strong><em>var</em></strong>重复声明不会报错，但<strong><em>let</em></strong>和<strong><em>const</em></strong>会。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// "bar"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">'qux'</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'baz' has already been declared</span></span><br></pre></td></tr></table></figure>

<p><strong><em>let</em></strong>和<strong><em>const</em></strong>的区别在于：<strong><em>let</em></strong>允许多次赋值，而<strong><em>const</em></strong>只允许一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样不会报错。</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">'foo'</span>;</span><br><span class="line">foo = <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样会报错。</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="string">'baz'</span>;</span><br><span class="line">baz = <span class="string">'qux'</span>;</span><br></pre></td></tr></table></figure>

<p>全局作用域下，使用<strong><em>var</em></strong>声明的变量会挂载到<strong><em>window</em></strong>对象上，使用<strong><em>let</em></strong>，<strong><em>const</em></strong>声明的变量不会挂载到<strong><em>window</em></strong>对象上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> c =<span class="number">30</span>;</span><br><span class="line"><span class="built_in">window</span>.a; <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">window</span>.b; <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">window</span>.c; <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>null、undefined和未声明变量之间有什么区别？如何检查判断这些状态值？</title>
    <url>/2019-10-12/Javascript/null%E3%80%81undefined%E5%92%8C%E6%9C%AA%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E5%88%A4%E6%96%AD%E8%BF%99%E4%BA%9B%E7%8A%B6%E6%80%81%E5%80%BC%EF%BC%9F/</url>
    <content><![CDATA[<p>当你没有提前使用<strong><em>var</em></strong>、<strong><em>let</em></strong>或<strong><em>const</em></strong>声明变量，就为一个变量赋值时，该变量是未声明变量<strong><em>（undeclared variables）</em></strong>。未声明变量会脱离当前作用域，成为全局作用域下定义的变量。<strong><em>在严格模式下</em></strong>，给未声明的变量赋值，会抛出<strong><em>ReferenceError</em></strong>错误。和使用全局变量一样，使用未声明变量也是非常不好的做法，应当尽可能避免。要检查判断它们，需要将用到它们的代码放在<strong><em>try/catch</em></strong>语句中。</p><a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">1</span>; <span class="comment">// 在严格模式下，抛出 ReferenceError 错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>当一个变量已经声明，但没有赋值时，该变量的值是<strong><em>undefined</em></strong>。如果一个函数的执行结果被赋值给一个变量，但是这个函数却没有返回任何值，那么该变量的值是<strong><em>undefined</em></strong>。要检查它，需要使用严格相等（===）；或者使用<strong><em>typeof</em></strong>，它会返回<strong><em>‘undefined’</em></strong>字符串。请注意，不能使用非严格相等（==）来检查，因为如果变量值为<strong><em>null</em></strong>，使用非严格相等也会返回<strong><em>true</em></strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo === <span class="string">'undefined'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo == <span class="literal">null</span>); <span class="comment">// true. 错误，不要使用非严格相等！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> baz = bar();</span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong><em>null</em></strong> 只能被显式赋值给变量。它表示空值，与被显式赋值 <strong><em>undefined</em></strong> 的意义不同。要检查判断<strong><em>null</em></strong>值，需要使用严格相等运算符。请注意，和前面一样，不能使用非严格相等（==）来检查，因为如果变量值为<strong><em>undefined</em></strong>，使用非严格相等也会返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo == <span class="literal">undefined</span>); <span class="comment">// true. 错误，不要使用非严格相等！</span></span><br></pre></td></tr></table></figure>

<p>作为一种个人习惯，我从不使用未声明变量。如果定义了暂时没有用到的变量，我会在声明后明确地给它们赋值为<strong><em>null</em></strong>。</p>
<ul>
<li>null：表示一个值被定义了，定义为“空值”；</li>
<li>undefined：表示根本不存在定义。</li>
</ul>
<p>所以设置一个值为 <strong><em>null</em></strong> 是合理的，如<br><strong><em>objA.valueA = null</em></strong>;</p>
<p>但设置一个值为 <strong><em>undefined</em></strong> 是不合理的</p>
<p><strong><em>null</em></strong> 表示”没有对象”，即该处不应该有值。典型用法是：</p>
<ul>
<li>1.作为函数的参数，表示该函数的参数不是对象。</li>
<li>2.作为对象原型链的终点。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)<span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p><code>undefined</code> 表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<ul>
<li>1.变量被声明了，但没有赋值时，就等于undefined。</li>
<li>2.调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>
<li>3.对象没有赋值的属性，该属性的值为undefined。</li>
<li>4.函数没有返回值时，默认返回undefined。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/questions/javascript-questions.md#nullundefined%E5%92%8C%E6%9C%AA%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E5%88%A4%E6%96%AD%E8%BF%99%E4%BA%9B%E7%8A%B6%E6%80%81%E5%80%BC" target="_blank" rel="noopener">https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/questions/javascript-questions.md#nullundefined%E5%92%8C%E6%9C%AA%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E5%88%A4%E6%96%AD%E8%BF%99%E4%BA%9B%E7%8A%B6%E6%80%81%E5%80%BC</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2019-10-12/Javascript/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>把接收多个参数的函数变换成接收一个单一参数（最初函数的第一个参数）的函数，并返回接受剩余的参数而且返回结果的新函数的技术。</p><p>简单的说，柯里化函数持续地返回一个新函数直到所有的参数用尽为止。这些参数全部保持“活着”的状态（通过闭包），然后当柯里化链中的最后一个函数被返回和执行时会全部被用来执行。</p><a id="more"></a>

<p>提高函数的适用性，同时降低函数的通用性；其实现方式就是固定一些可以预期的参数，然后返回一个特定的函数</p>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的add函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingAdd</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)           <span class="comment">// 3</span></span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>)   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="函数柯里化的好处"><a href="#函数柯里化的好处" class="headerlink" title="函数柯里化的好处"></a>函数柯里化的好处</h2><ul>
<li>参数复用：提前绑定好函数里面的某些参数,达到参数复用的效果,提高了适用性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常正则验证字符串 reg.test(txt)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数封装后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg, txt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check(<span class="regexp">/\d+/g</span>, <span class="string">'test'</span>)       <span class="comment">//false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>, <span class="string">'test'</span>)    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = curryingCheck(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line"></span><br><span class="line">hasNumber(<span class="string">'test1'</span>)      <span class="comment">// true</span></span><br><span class="line">hasNumber(<span class="string">'testtest'</span>)   <span class="comment">// false</span></span><br><span class="line">hasLetter(<span class="string">'21212'</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>提前返回<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//兼容现代浏览器以及IE浏览器的事件添加方法</span></span><br><span class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.attachEvent(<span class="string">'on'</span> + event, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上面的方法有什么问题呢？很显然，我们每次使用addEvent为元素添加事件的时候，会走一遍if…else if …，其实只要一次判定就可以了，怎么做？–柯里化。它相对一第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了浏览器支持的事件绑定，避免每次都进行判断。改为下面这样子的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.attachEvent(<span class="string">'on'</span> + event, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ul>
<li>延迟运行</li>
</ul>
<p>与 <strong><em>call/apply</em></strong> 方法直接执行不同，bind 方法将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数， 这符合柯里化特点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(target, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006096034" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006096034</a></p>
<p><a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">https://www.jianshu.com/p/2975c25e4d71</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流和防抖</title>
    <url>/2019-10-12/Javascript/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/</url>
    <content><![CDATA[<h1 id="函数节流和防抖"><a href="#函数节流和防抖" class="headerlink" title="函数节流和防抖"></a>函数节流和防抖</h1><p>窗口的resize、scroll、输入框内容校验等操作时，如果这些操作处理函数是较为复杂或页面频繁重渲染等操作时，在这种情况下如果事件触发的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用<strong><em>debounce（防抖）</em></strong>和<strong><em>throttle（节流）</em></strong>的方式来<strong><em>减少触发的频率</em></strong>，同时又不影响实际效果。</p><a id="more"></a>
<h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h2><p>当持续触发事件时，<strong><em>debounce</em></strong> 会合并事件且不会去触发事件，当一定时间内没有触发再这个事件时，才真正去触发事件，只会触发最后一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> timer = <span class="literal">null</span>, context, args;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = debounce(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"触发滚动"</span>, e)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<h3 id="立刻执行"><a href="#立刻执行" class="headerlink" title="立刻执行"></a>立刻执行</h3><p>不希望非要等到事件停止触发后才执行，希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。</p>
<p>加个 immediate 参数判断是否是立刻执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>, context, args;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 判断绑定的函数是否已经执行了 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> didRun = !timer;</span><br><span class="line">            <span class="keyword">if</span> (didRun) &#123;</span><br><span class="line">                <span class="comment">//没有执行过，立刻执行</span></span><br><span class="line">                callback.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>此时注意一点，就是绑定的函数可能是有返回值的，所以我们也要返回函数的执行结果，但是当 <strong><em>immediate</em></strong> 为 false 的时候，因为使用了 <strong><em>setTimeout</em></strong> ，我们将 <strong><em>func.apply(context, args)</em></strong> 的返回值赋给变量，最后再<strong><em>return</em></strong> 的时候，值将会一直是<strong><em>undefined</em></strong>，所以我们只在 <strong><em>immediate</em></strong> 为 <strong><em>true</em></strong> 的时候返回函数的执行结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>, context, args;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 判断绑定的函数是否已经执行了 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> didRun = !timer;</span><br><span class="line">            <span class="keyword">if</span> (didRun) &#123;</span><br><span class="line">                <span class="comment">//没有执行过，立刻执行</span></span><br><span class="line">                result = callback.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p>最后我们再思考一个小需求，我希望能<strong><em>取消 debounce</em></strong> 函数，比如说我 <strong><em>debounce</em></strong> 的时间间隔是 10 秒钟，<strong><em>immediat</em></strong>e 为 <strong><em>true</em></strong>，这样的话，我只有等 10 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行啦。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>, context, args;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 判断绑定的函数是否已经执行了 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> didRun = !timer;</span><br><span class="line">            <span class="keyword">if</span> (didRun) &#123;</span><br><span class="line">                <span class="comment">//没有执行过，立刻执行</span></span><br><span class="line">                result = callback.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消防抖</span></span><br><span class="line">    debounced.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 清除timeout</span></span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="comment">// 重置timeout</span></span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p>
<p>根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。</p>
<p>我们用 <strong><em>leading</em></strong> 代表首次是否执行，<strong><em>trailing</em></strong> 代表结束后是否再执行一次。</p>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<h3 id="使用时间戳"><a href="#使用时间戳" class="headerlink" title="使用时间戳"></a>使用时间戳</h3><p>使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> context, args;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">var</span>  now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; delay) &#123;</span><br><span class="line">            previous = now;</span><br><span class="line">            callback.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h3><p>接下来，我们讲讲第二种实现方式，使用定时器。</p>
<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，重置定时器，这样就可以设置下个定时器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 重置定时器</span></span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                callback.apply(context, args)</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较使用时间戳，使用定时器两个方法：</p>
<p>第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行<br>第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件</p>
<h3 id="双剑合璧"><a href="#双剑合璧" class="headerlink" title="双剑合璧"></a>双剑合璧</h3><p>想要控制第一次是否立刻执行，事件停止触发后是否会再执行一次事件。</p>
<p>那我们设置个 <strong><em>options</em></strong> 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定:</p>
<ul>
<li>leading：false 表示禁用第一次执行</li>
<li>trailing: false 表示禁用停止触发的回调<br>默认会开启第一次立刻执行，事件停止触发后会再执行一次事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果禁用第一次立刻执行 设置previous为0，throttled函数remaining会确保大于0 throttled函数会执行else if条件语句里面的内容，从而达到节流的效果，如果没有禁用第一次立刻执行，需要重置previous为当前时间</span></span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="comment">// 执行完重置timeout</span></span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 执行函数</span></span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="comment">// 触发第一次操作时，默认会第一次立刻执行，第一次执行remaining会小于0，程序会执行 if条件语句的内容，快速执行第二次点击previous = now;remaining会大于0，会执行else if条件语句里面的内容</span></span><br><span class="line">        <span class="comment">// 触发第一次操作时，如果禁用第一次立刻执行，当前previous为0，将previous设置为now，remaining会大于0 程序会执行else if条件语句里面的内容</span></span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="comment">// 获取触发函数剩余的时间</span></span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 绑定arguments</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="comment">// 清除timeout</span></span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置时间</span></span><br><span class="line">            previous = now;</span><br><span class="line">            <span class="comment">// 执行函数</span></span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// 事件停止触发后会再执行一次事件</span></span><br><span class="line">            <span class="comment">// 通过计时器setTimeout，设置remaining时间后执行事件触发，达到节流</span></span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。</li>
<li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>debounce<ul>
<li>search搜索，用户在不断输入值时，用防抖来节约请求资源。</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ul>
</li>
<li>throttle<ul>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/post/5b8de829f265da43623c4261" target="_blank" rel="noopener">https://juejin.im/post/5b8de829f265da43623c4261</a></p>
<p><a href="https://juejin.im/post/5b7b88d46fb9a019e9767405?utm_medium=fe&amp;utm_source=weixinqun" target="_blank" rel="noopener">https://juejin.im/post/5b7b88d46fb9a019e9767405?utm_medium=fe&amp;utm_source=weixinqun</a></p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/22</a></p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/26</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>普通函数和箭头函数的区别</title>
    <url>/2019-10-12/Javascript/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>1.箭头函数没有prototype(原型)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="params">()</span> =&gt;</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">a.__proto__===<span class="built_in">Function</span>.prototype;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>2.箭头函数的this指向它被创建时的上下文</p><a id="more"></a>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    id: <span class="number">22</span>,</span><br><span class="line">    print: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;,</span><br><span class="line">    print2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;,</span><br><span class="line">    print3: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    print4: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.print(); <span class="comment">// undefined</span></span><br><span class="line">obj.print2(); <span class="comment">// 22</span></span><br><span class="line">obj.print3(); <span class="comment">// undefined</span></span><br><span class="line">obj.print4(); <span class="comment">// 22</span></span><br></pre></td></tr></table></figure>

<p>3.在构造函数里使用箭头函数的主要优点是它的 this 只与箭头函数创建时的 this 保持一致，并且不会修改。所以，当用构造函数去创建一个新的对象的时候，箭头函数的 this 总是指向新创建的对象。正常函数的 this 是可以在执行过程中被改变的，而箭头函数的 this 则会一直保持一致。所以在使用箭头函数的时候，你就不需要担心它的上下文被改变了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">firstName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">this</span>.sayName1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.firstName); &#125;;</span><br><span class="line">    <span class="keyword">this</span>.sayName2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.firstName); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> john = <span class="keyword">new</span> Person(<span class="string">'John'</span>);</span><br><span class="line"><span class="keyword">const</span> dave = <span class="keyword">new</span> Person(<span class="string">'Dave'</span>);</span><br><span class="line"></span><br><span class="line">john.sayName1(); <span class="comment">// John</span></span><br><span class="line">john.sayName2(); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数的 this 可以被修改，而箭头函数则不会</span></span><br><span class="line">john.sayName1.call(dave); <span class="comment">// Dave (因为 "this" 现在指向了 dave 对象)</span></span><br><span class="line">john.sayName2.call(dave); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line">john.sayName1.apply(dave); <span class="comment">// Dave (因为 "this" 现在指向了 dave 对象)</span></span><br><span class="line">john.sayName2.apply(dave); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line">john.sayName1.bind(dave)(); <span class="comment">// Dave (因为 "this" 现在指向了 dave 对象)</span></span><br><span class="line">john.sayName2.bind(dave)(); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sayNameFromWindow1 = john.sayName1;</span><br><span class="line">sayNameFromWindow1(); <span class="comment">// undefined (因为 "this" 现在指向了 Window 对象)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sayNameFromWindow2 = john.sayName2;</span><br><span class="line">sayNameFromWindow2(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>4.如果箭头函数外层没有普通函数，严格模式和非严格模式下它的this都会指向window(全局对象)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    print: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> obj.print(); <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>5.更简洁的语法</p>
<p>箭头函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于普通函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.不能使用new</p>
<p>箭头函数作为匿名函数,是不能作为构造函数的,不能使用new</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  value:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(); <span class="comment">//TypeError: B is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>7.不绑定arguments，用rest参数…解决</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*常规函数使用arguments*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);   <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*箭头函数不能使用arguments*/</span></span><br><span class="line"><span class="keyword">const</span> test2 = <span class="function">(<span class="params">a</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>)&#125;  <span class="comment">//ReferenceError: arguments is not defined</span></span><br><span class="line"><span class="comment">/*箭头函数使用reset参数...解决*/</span></span><br><span class="line"><span class="keyword">let</span> test3=<span class="function">(<span class="params">...a</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(a)&#125; <span class="comment">//22</span></span><br><span class="line"></span><br><span class="line">test1(<span class="number">1</span>);</span><br><span class="line">test2(<span class="number">2</span>);</span><br><span class="line">test3(<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>);</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数的注意事项："><a href="#箭头函数的注意事项：" class="headerlink" title="箭头函数的注意事项："></a>箭头函数的注意事项：</h2><p>1.不能简单返回对象字面量</p>
<p>如果要返回对象时需要用小括号包起来，因为大括号被占用解释为代码块了，正确写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;  <span class="comment">// undefined 想返回一个对象，大括号被占用解释为代码块，执行后返回undefined</span></span><br><span class="line"><span class="keyword">var</span> func2 = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);  <span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>2.箭头函数不能当做Generator函数，不能使用yield关键字</p>
<p>3.箭头函数不能换行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = ()</span><br><span class="line">          =&gt;<span class="number">1</span>; <span class="comment">//SyntaxError: Unexpected token =&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>call、apply 及 bind 函数的区别</title>
    <url>/2019-10-12/Javascript/call%E3%80%81apply-%E5%8F%8A-bind-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>call和apply都用于调用函数，第一个参数将用作函数内 this 的值。然而，call接受逗号分隔的参数作为后面的参数，而apply接受一个参数数组作为后面的参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p><code>bind()</code>方法返回一个新的函数, 新函数的<code>this</code>值指向传入的第一个参数，<code>this</code>被绑定了</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>简述JavaScript中的this</title>
    <url>/2019-10-12/Javascript/%E7%AE%80%E8%BF%B0JavaScript%E4%B8%AD%E7%9A%84this/</url>
    <content><![CDATA[<p>粗略地讲，函数的调用方式决定了<code>this</code>的值，谁调用的函数，<code>this</code>就指向谁。<code>this</code>取值符合以下规则：</p><p>1.如果函数作为构造函数用，那么其中的<code>this</code>就代表它即将<code>new</code>出来的对象。</p><p>2.如果<code>appl</code>、<code>call</code>或<code>bind</code>方法用于调用、创建一个函数，this的值就取传入的对象的值。</p><p>3.如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的<code>this</code>指向该对象。比如当<code>obj.method()</code>被调用时，函数内的 <code>this</code> 将绑定到<code>obj</code>对象。</p><a id="more"></a>



<p>4.如果调用函数不符合上述规则，那么<code>this</code>的值指向全局对象<code>（global object）</code>。浏览器环境下<code>this</code>的值指向<code>window</code>对象，但是在严格模式下<code>(&#39;use strict&#39;)</code>，<code>this</code>的值为<code>undefined</code>。</p>
<p>5.如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定<code>this</code>的值。</p>
<p>6.如果该函数是 ES2015 中的<code>箭头函数</code>，将忽略上面的所有规则，<code>this</code>被设置为它被<code>创建时的上下文</code>。</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
