<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Web安全-SQL注入攻击</title>
    <url>/2019-10-19/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/Web%E5%AE%89%E5%85%A8-SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h2><p>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p><a id="more"></a>
<h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><ul>
<li>存储结构化数据</li>
<li>可高效操作大量数据</li>
<li>方便处理数据之间的关联关系</li>
<li>常见的关系型数据库：MySQL，Oracle，SQLServer，PostGreSQL</li>
</ul>
<h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><ul>
<li>结构化查询语言，一种描述性语言，面向语义化</li>
<li>SQL语言的作用：对存储在RDBMS（关系型数据库管理系统）中的数据进行增删改查等操作，有些非关系数据库也支持SQL</li>
</ul>
<h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><p>SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。</p>
<h2 id="SQL注入类型"><a href="#SQL注入类型" class="headerlink" title="SQL注入类型"></a>SQL注入类型</h2><p>根据相关技术原理，SQL注入可以分为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## SQL注入产生原因</span><br><span class="line"></span><br><span class="line">- 不当的类型处理；</span><br><span class="line">- 不安全的数据库配置；</span><br><span class="line">- 不合理的查询集处理；</span><br><span class="line">- 不当的错误处理；</span><br><span class="line">- 转义字符处理不合适；</span><br><span class="line">- 多个提交处理不当。</span><br><span class="line"></span><br><span class="line">## SQL注入示例</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">//查询语句</span><br><span class="line">SELECT * FROM table WHERE id=$&#123;id&#125;</span><br><span class="line">//注入数据</span><br><span class="line">1 or 1=1</span><br><span class="line">//注入后的查询语句</span><br><span class="line">SELECT * FROM table WHERE id=1 or 1=1</span><br><span class="line"></span><br><span class="line">//查询语句</span><br><span class="line">SELECT * FROM user WHERE username=`$&#123;username&#125;` AND password=`$&#123;password&#125;`</span><br><span class="line">//注入数据</span><br><span class="line">1&apos; or &apos;1&apos;=&apos;1</span><br><span class="line">//注入后的查询语句</span><br><span class="line">SELECT * FROM user WHERE username=`123` AND password=1&apos; or &apos;1&apos;=&apos;1&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="SQL注入危害"><a href="#SQL注入危害" class="headerlink" title="SQL注入危害"></a>SQL注入危害</h2><ul>
<li>猜解密码</li>
<li>获取数据</li>
<li>删库删表</li>
<li>拖库</li>
</ul>
<h2 id="SQL注入防御"><a href="#SQL注入防御" class="headerlink" title="SQL注入防御"></a>SQL注入防御</h2><ul>
<li>对数据进行转义，永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等</li>
<li>永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取</li>
<li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li>
<li>不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息</li>
<li>关闭错误输出：应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装，把异常信息存放在独立的表中</li>
<li>使用ORM（对象关系映射）</li>
</ul>
<h2 id="Node-防止SQL注入攻击"><a href="#Node-防止SQL注入攻击" class="headerlink" title="Node 防止SQL注入攻击"></a>Node 防止SQL注入攻击</h2><h3 id="转义查询值"><a href="#转义查询值" class="headerlink" title="转义查询值"></a>转义查询值</h3><p>使用<a href="https://github.com/mysqljs/mysql" target="_blank" rel="noopener">mysql</a>，转义查询值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(&#123;</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    user: <span class="string">'me'</span>,</span><br><span class="line">    password: <span class="string">'secret'</span>,</span><br><span class="line">    database: <span class="string">'my_db'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userId = <span class="string">'some user provided value'</span>;</span><br><span class="line"><span class="keyword">var</span> sql    = <span class="string">'SELECT * FROM users WHERE id = '</span> + connection.escape(userId); <span class="comment">//转义查询值</span></span><br><span class="line">connection.query(sql, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="使用参数化查询"><a href="#使用参数化查询" class="headerlink" title="使用参数化查询"></a>使用参数化查询</h3><p>使用<a href="https://github.com/sidorares/node-mysql2" target="_blank" rel="noopener">node-mysql2</a>进行参数化查询</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get the client</span></span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(&#123;</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    user: <span class="string">'me'</span>,</span><br><span class="line">    password: <span class="string">'secret'</span>,</span><br><span class="line">    database: <span class="string">'my_db'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userId = <span class="string">'some user provided value'</span>;</span><br><span class="line">connection.execute(<span class="string">'SELECT * FROM users WHERE id = ?'</span>,[userId], <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="使用ORM（对象关系映射）"><a href="#使用ORM（对象关系映射）" class="headerlink" title="使用ORM（对象关系映射）"></a>使用ORM（对象关系映射）</h3><p>使用<a href="https://github.com/demopark/sequelize-docs-Zh-CN/tree/master" target="_blank" rel="noopener">Sequelize</a></p>
<h2 id="参数化查询"><a href="#参数化查询" class="headerlink" title="参数化查询"></a>参数化查询</h2><p>参数化查询(Parameterized Query 或 Parameterized Statement)是指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数 (Parameter) 来给值，这个方法目前已被视为最有效可预防SQL注入攻击 (SQL Injection) 的攻击手法的防御方式</p>
<h3 id="参数化查询原理"><a href="#参数化查询原理" class="headerlink" title="参数化查询原理"></a>参数化查询原理</h3><p>在使用参数化查询的情况下，数据库服务器不会将参数的内容视为SQL指令的一部份来处理，而是在数据库完成 SQL 指令的编译后，才套用参数运行，因此就算参数中含有恶意的指令，由于已经编译完成，就不会被数据库所运行。 有部份的开发人员可能会认为使用参数化查询，会让程序更不好维护，或者在实现部份功能上会非常不便，然而，使用参数化查询造成的额外开发成本，通常都远低于因为SQL注入攻击漏洞被发现而遭受攻击，所造成的重大损失</p>
<h3 id="SQL-指令撰写方法"><a href="#SQL-指令撰写方法" class="headerlink" title="SQL 指令撰写方法"></a>SQL 指令撰写方法</h3><p>MySQL 的参数格式是以 “?” 字符加上参数名称而成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">UPDATE myTable SET c1 = ?c1, c2 = ?c2, c3 = ?c3 WHERE c4 = ?c4</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行sql查询</span></span><br><span class="line">query(<span class="string">`SELECT * FROM user WHERE id=?`</span>,[id])</span><br></pre></td></tr></table></figure>

<h2 id="NOSQL注入防御"><a href="#NOSQL注入防御" class="headerlink" title="NOSQL注入防御"></a>NOSQL注入防御</h2><ul>
<li>检测数据类型</li>
<li>类型转换</li>
<li>写完整条件</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>前端Cookie安全性</title>
    <url>/2019-10-19/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/%E5%89%8D%E7%AB%AFCookie%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。（可以叫做浏览器缓存）</p><h2 id="Cookie特性"><a href="#Cookie特性" class="headerlink" title="Cookie特性"></a>Cookie特性</h2><ul>
<li>前端（浏览器）数据存储</li>
<li>后端通过http响应头进行设置</li>
<li>前端请求时，会自动添加cookie，通过http请求头传给后端</li>
<li>前端可读写</li>
<li>遵守同源策略</li>
</ul><a id="more"></a>

<h2 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h2><ul>
<li>domain：域，表示当前cookie属于哪个域或子域下面，可以在哪些域名下使用</li>
<li>Path：表示cookie的所属路径，标识指定了主机下的哪些路径可以接受Cookie，具体可以作用到网站的哪一级，即url层级</li>
<li>Expire time/Max-age：表示了cookie的有效期。expire的值，是一个时间，过了这个时间，该cookie就失效了。或者是用max-age指定当前cookie是在多长时间之后而失效。如果服务器返回的一个cookie，没有指定其expire time，那么表明此cookie有效期只是当前的session，即是session cookie，当前session会话结束后，就过期了。对应的，当关闭（浏览器中）该页面的时候，此cookie就应该被浏览器所删除了。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来，就好像浏览器从来没有关闭一样</li>
<li>secure：表示该cookie只能用https传输。一般用于包含认证信息的cookie，要求传输此cookie的时候，必须用https传输</li>
<li>httponly：表示此cookie必须用于http或https传输。这意味着，浏览器脚本，比如javascript中，是不允许访问操作此cookie的</li>
<li>SameSite：允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）</li>
</ul>
<h2 id="Cookie作用"><a href="#Cookie作用" class="headerlink" title="Cookie作用"></a>Cookie作用</h2><ul>
<li>存储个性化设置</li>
<li>存储未登录时用户唯一标识</li>
<li>存储已登录用户凭证</li>
<li>存储其他业务数据（缓存）</li>
</ul>
<h2 id="Cookie的缺陷"><a href="#Cookie的缺陷" class="headerlink" title="Cookie的缺陷"></a>Cookie的缺陷</h2><ul>
<li>cookie会被附加在每个HTTP请求中，所以无形中增加了流量。</li>
<li>由于在HTTP请求中的cookie是明文传递的，所以安全性成问题。（除非用HTTPS)</li>
<li>cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的</li>
</ul>
<h2 id="Cookie-登录用户凭证"><a href="#Cookie-登录用户凭证" class="headerlink" title="Cookie 登录用户凭证"></a>Cookie 登录用户凭证</h2><ul>
<li>前端提交用户名和密码</li>
<li>后端验证用户名和密码</li>
<li>后端生成用户凭证，设置cookie，通过http响应头传输给前端</li>
<li>后续，继续访问时，http请求头会携带cookie，后端通过用户凭证cookie验证用户信息，处理请求</li>
</ul>
<h2 id="Cookie-生成用户凭证"><a href="#Cookie-生成用户凭证" class="headerlink" title="Cookie 生成用户凭证"></a>Cookie 生成用户凭证</h2><ul>
<li>用户ID：很容易被篡改</li>
<li>用户ID+签名：后台根据用户ID生成签名，将用户ID+签名传给前端，后台处理请求时通过验证用户ID和签名，处理请求。同时通过判断用户ID和签名的一致性，验证用户ID是否被篡改</li>
<li>Session：客户端第一次正常访问服务器，服务器生成一个sessionid来标识用户并保存用户信息（服务器有一个专门的地方来保存所有用户的sessionId），在response headers中作为cookie的一个值返回，客户端收到后把cookie保存在本地，下次再发请求时会在request headers中带上这个sessionId，服务器通过查找这个sessionId就知道用户状态了，并更新sessionId的最后访问时间。sessionId也可以设置失效时间。总言之cookie是保存在客户端，session是存在服务器，session依赖于cookie</li>
</ul>
<h2 id="Cookie和XSS的关系"><a href="#Cookie和XSS的关系" class="headerlink" title="Cookie和XSS的关系"></a>Cookie和XSS的关系</h2><ul>
<li>XSS可能偷取Cookie</li>
<li>设置http-only防止Cookie被盗</li>
</ul>
<h2 id="Cookie和CSRF的关系"><a href="#Cookie和CSRF的关系" class="headerlink" title="Cookie和CSRF的关系"></a>Cookie和CSRF的关系</h2><ul>
<li>CSRF利用了用户的Cookie</li>
<li>攻击站点无法读写Cookie</li>
<li>最好能阻止第三方使用Cookie（SameSite）</li>
</ul>
<h2 id="Cookie的安全策略"><a href="#Cookie的安全策略" class="headerlink" title="Cookie的安全策略"></a>Cookie的安全策略</h2><ul>
<li>签名防止篡改（用户ID+签名）</li>
<li>私有变换（加密）</li>
<li>http-only（防止XSS攻击）</li>
<li>secure：防止HTTP数据传输过程中的窃听，盗取Cookie</li>
<li>SameSite（防止CSRF攻击）</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全-跨站请求伪造攻击CSRF</title>
    <url>/2019-10-19/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/Web%E5%AE%89%E5%85%A8-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BBCSRF/</url>
    <content><![CDATA[<h2 id="跨站请求伪造攻击CSRF"><a href="#跨站请求伪造攻击CSRF" class="headerlink" title="跨站请求伪造攻击CSRF"></a>跨站请求伪造攻击CSRF</h2><p>CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。</p><a id="more"></a>
<h2 id="跨站"><a href="#跨站" class="headerlink" title="跨站"></a>跨站</h2><p>在其他网站，在用户不知情的情况下，对目标网站发出了请求，产生了影响。</p>
<h2 id="CSRF攻击攻击原理及过程"><a href="#CSRF攻击攻击原理及过程" class="headerlink" title="CSRF攻击攻击原理及过程"></a>CSRF攻击攻击原理及过程</h2><ul>
<li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</li>
<li>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li>
<li>用户在同一浏览器中，打开一个TAB页访问了攻击网站B；</li>
<li>攻击网站就能伪装成用户C向A网站发起请求（此时携带了用户的身份信息Cookie）</li>
</ul>
<h2 id="CSRF攻击特征"><a href="#CSRF攻击特征" class="headerlink" title="CSRF攻击特征"></a>CSRF攻击特征</h2><ul>
<li>攻击网站B向A网站发起请求</li>
<li>携带A网站的Cookie</li>
<li>不访问A网站前端</li>
<li>HTTP请求头的refer指向攻击网站B</li>
</ul>
<h2 id="CSRF攻击危害"><a href="#CSRF攻击危害" class="headerlink" title="CSRF攻击危害"></a>CSRF攻击危害</h2><ul>
<li>利用用户登录态</li>
<li>用户不知情</li>
<li>完成业务请求</li>
<li>盗取用户资金（转账，消费）</li>
<li>冒充用户发帖背锅</li>
<li>损坏网站声誉</li>
<li>等等…</li>
</ul>
<h2 id="CSRF攻击防御"><a href="#CSRF攻击防御" class="headerlink" title="CSRF攻击防御"></a>CSRF攻击防御</h2><ul>
<li>通过SameSite Cookie，禁止第三方网站携带Cookie</li>
<li>不访问A网站前端，在A网站前端中加入验证信息，第三方攻击网站无法获取验证信息，后台通过判断验证信息处理请求<ul>
<li>验证码,（图形验证码）缺点是用户体验差<ul>
<li><a href="https://www.npmjs.com/package/svg-captcha" target="_blank" rel="noopener">svg-captcha</a>：Node 图形验证码</li>
</ul>
</li>
<li>Token：Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</li>
</ul>
</li>
<li>验证HTTP请求头的refer 请求来源，如果不是合法的域名直接拒绝请求</li>
<li>防抓包：使用HTTPS(HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。)替换HTTP,对传输的数据进行加密,这样,当请求的信息被抓包工具抓包后,也无法修改提交的数据。</li>
<li>node可以使用 <a href="https://github.com/expressjs/csurf" target="_blank" rel="noopener">CSRF</a> 中间件来防御csrf攻击。</li>
</ul>
<h2 id="SameSite-Cookie"><a href="#SameSite-Cookie" class="headerlink" title="SameSite Cookie"></a>SameSite Cookie</h2><p>服务器端设置Cookie的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#SameSite_cookies" target="_blank" rel="noopener">SameSite</a>，浏览器端在跨站请求时Cookie不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。目前主流浏览器基本上都支持。<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Browser_compatibility" target="_blank" rel="noopener">支持情况</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: key=value; SameSite=Strict</span><br></pre></td></tr></table></figure>

<h2 id="SameSite属性值"><a href="#SameSite属性值" class="headerlink" title="SameSite属性值"></a>SameSite属性值</h2><ul>
<li>Strict：跨域发起的任何请求都不会携带cookie</li>
<li>Lax： Lax相对于Strict模式来说，宽松了一些</li>
</ul>
<table>
<thead>
<tr>
<th>请求类型</th>
<th>例子</th>
<th>非 SameSite</th>
<th>SameSite = Lax</th>
<th>SameSite = Strict</th>
</tr>
</thead>
<tbody><tr>
<td>link</td>
<td><code>&lt;a href=&quot;…&quot;&gt;</code></td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>prerender</td>
<td><code>&lt;link rel=&quot;prerender&quot; href=&quot;…&quot;&gt;</code></td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>form get</td>
<td><code>&lt;form method=&quot;get&quot; action=&quot;…&quot;&gt;</code></td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>form post</td>
<td><code>&lt;form method=&quot;post&quot; action=&quot;…&quot;&gt;</code></td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>iframe</td>
<td><code>&lt;iframe src=&quot;…&quot;&gt;</code></td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>ajax</td>
<td><code>$.get(&#39;…&#39;)</code></td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>image</td>
<td><code>&lt;img src=&quot;…&quot;&gt;</code></td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://coding.imooc.com/class/104.html" target="_blank" rel="noopener">Web前后端漏洞分析与防御</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全-跨站脚本攻击XSS</title>
    <url>/2019-10-19/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%98%B2%E5%BE%A1/Web%E5%AE%89%E5%85%A8-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBXSS/</url>
    <content><![CDATA[<h2 id="跨站脚本攻击XSS"><a href="#跨站脚本攻击XSS" class="headerlink" title="跨站脚本攻击XSS"></a>跨站脚本攻击XSS</h2><p>跨站脚本攻击（XSS），是目前最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p><h2 id="跨站"><a href="#跨站" class="headerlink" title="跨站"></a>跨站</h2><p>简单来说，如果有一个网站，希望网站中所有运行的逻辑都来自本站。如果运行了别的网站的脚本，就产生了跨站脚本攻击。</p><a id="more"></a>

<h2 id="XSS攻击原理"><a href="#XSS攻击原理" class="headerlink" title="XSS攻击原理"></a>XSS攻击原理</h2><p>攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie信息、破坏页面结构、重定向到其它网站等。</p>
<h2 id="XSS能做什么"><a href="#XSS能做什么" class="headerlink" title="XSS能做什么"></a>XSS能做什么</h2><ul>
<li>获取页面数据</li>
<li>获取Cookie信息</li>
<li>截取前端逻辑</li>
<li>发送请求</li>
<li>偷取网站任意数据</li>
<li>偷取用户资料</li>
<li>偷取用户密码和登录态</li>
<li>欺骗用户</li>
<li>等等…</li>
</ul>
<h2 id="XSS攻击类型"><a href="#XSS攻击类型" class="headerlink" title="XSS攻击类型"></a>XSS攻击类型</h2><ul>
<li>反射型：攻击代码直接由url参数注入，页面直接执行了注入的代码<ul>
<li>通过将攻击的url转为短网址，可以屏蔽脚本信息，攻击更加隐蔽</li>
</ul>
</li>
<li>存储型：XSS代码会被保存到网站的数据中，如数据库，在其他用户访问到这条记录时，这条攻击代码会被读取出来，显示在页面上。（危害性更大）</li>
</ul>
<h2 id="XSS攻击注入点"><a href="#XSS攻击注入点" class="headerlink" title="XSS攻击注入点"></a>XSS攻击注入点</h2><ul>
<li>HTML节点内容：节点内容是动态生成，包含用户输入的信息</li>
<li>HTML属性：节点属性如果由用户输入信息组成</li>
<li>Javascript代码：由用户输入信息组成</li>
<li>富文本：由用户输入信息组成</li>
</ul>
<p>基本上页面内容，由用户输入信息动态生成，都可能存在XSS攻击。</p>
<h3 id="HTML节点内容"><a href="#HTML节点内容" class="headerlink" title="HTML节点内容"></a>HTML节点内容</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    #&#123;content&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//XSS攻击</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">       alert(1)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"#&#123;image&#125;"</span>/&gt;</span></span><br><span class="line">//提前关闭src属性 注入攻击代码：1" onerror="alert(1)</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1"</span> <span class="attr">onerror</span>=<span class="string">"alert(1)"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Javascript代码"><a href="#Javascript代码" class="headerlink" title="Javascript代码"></a>Javascript代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">"#&#123;data&#125;"</span>;</span><br><span class="line">    <span class="comment">//提前关闭data变量 注入攻击代码：hello"; alert(1);"</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">"hello"</span>; alert(<span class="number">1</span>);<span class="string">""</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h3><ul>
<li>富文本得保留HTML</li>
<li>HTML有XSS攻击风险</li>
</ul>
<h2 id="浏览器自带防御"><a href="#浏览器自带防御" class="headerlink" title="浏览器自带防御"></a>浏览器自带防御</h2><ul>
<li>X-XSS-Protection：通过设置响应头处理XSS攻击</li>
<li>只能处理反射型攻击类型， url参数出现在HTML节点内容或HTML属性中</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener">Content-Security-Policy</a>：允许站点管理者控制用户代理能够为指定的页面加载哪些资源。这将帮助防止跨站脚本攻击（Cross-Site Script）</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X-XSS-Protection: 0 // 表示关闭浏览器的XSS防护机制</span><br><span class="line">X-XSS-Protection: 1 // 启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）</span><br><span class="line">X-XSS-Protection: 1; mode=block // 启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。</span><br><span class="line">X-XSS-Protection: 1; report=&lt;reporting-uri&gt; // 启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认会拦截XSS攻击</span></span><br><span class="line">The XSS Auditor refused to execute a script <span class="keyword">in</span> <span class="string">'http://localhost/?from=%3Cscript%3Ealert(1)%3C/script%3E'</span> because its source code was found within the request. The auditor was enabled <span class="keyword">as</span> the server did not send an <span class="string">'X-XSS-Protection'</span> header.</span><br></pre></td></tr></table></figure>

<h2 id="HTML节点内容防御方法"><a href="#HTML节点内容防御方法" class="headerlink" title="HTML节点内容防御方法"></a>HTML节点内容防御方法</h2><p>将 &lt; &gt; 尖括号进行转义，替换成<a href="https://www.w3school.com.cn/html/html_entities.asp" target="_blank" rel="noopener">html字符实体</a>。</p>
<ul>
<li>将&lt; 转义为 &amp;lt;</li>
<li>将 &gt; 转义为&amp;gt;</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    #&#123;content&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//XSS攻击</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">       alert(1)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeHtml = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>);<span class="comment">//处理 &lt;</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);<span class="comment">//处理 &gt;</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTML属性防御方法"><a href="#HTML属性防御方法" class="headerlink" title="HTML属性防御方法"></a>HTML属性防御方法</h2><p>由于引号，将属性提前关闭了，所以需要进行转义。</p>
<ul>
<li>将” 转义为&amp;quto;。</li>
<li>将’ 转义为&amp;#39;。</li>
<li>将  转义为&amp;nbsp;：属性没有引号情况下，转义空格。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"#&#123;image&#125;"</span>/&gt;</span></span><br><span class="line">//提前关闭src属性 注入攻击代码：1" onerror="alert(1)</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1"</span> <span class="attr">onerror</span>=<span class="string">"alert(1)"</span>/&gt;</span></span><br><span class="line">//属性没有引号</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeHtmlProperty = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>);<span class="comment">//处理 "</span></span><br><span class="line">    str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>);<span class="comment">//处理 '</span></span><br><span class="line">    str = str.replace(<span class="regexp">/ /g</span>, <span class="string">'&amp;nbsp;'</span>);<span class="comment">//处理空格</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTML节点内容，HTML属性防御方法"><a href="#HTML节点内容，HTML属性防御方法" class="headerlink" title="HTML节点内容，HTML属性防御方法"></a>HTML节点内容，HTML属性防御方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeHtmlAndProperty = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>);<span class="comment">//处理 &amp; 需要放在最前面 一般不需要处理</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>);<span class="comment">//处理 &lt;</span></span><br><span class="line">    str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);<span class="comment">//处理 &gt;</span></span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>);<span class="comment">//处理 "</span></span><br><span class="line">    str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>);<span class="comment">//处理 '</span></span><br><span class="line">    <span class="comment">//处理空格 由于html内容中，多个连续的空格，在渲染时只会产生一个空格，将空格全部转为&amp;nbsp;（html实体）可能显示存在问题，一般情况下，空格不进行转义。基于这种情况，必须确保属性带上引号，否则不能处理属性没有引号情况下的XSS攻击</span></span><br><span class="line">    <span class="comment">// str = str.replace(/ /g, '&amp;nbsp;');</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Javascript代码防御方法"><a href="#Javascript代码防御方法" class="headerlink" title="Javascript代码防御方法"></a>Javascript代码防御方法</h2><ul>
<li>将 “ 转义为 \“</li>
<li>转换成josn（推荐）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">"#&#123;data&#125;"</span>;</span><br><span class="line">    <span class="comment">//提前关闭data变量 注入攻击代码：hello"; alert(1);"</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">"hello"</span>; alert(<span class="number">1</span>);<span class="string">""</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不完善的方法</span></span><br><span class="line"><span class="keyword">var</span> escapeForJs = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    str = str.replace(<span class="regexp">/\\/g</span>, <span class="string">'\\\\'</span>);<span class="comment">//将\ 转义为\\</span></span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>);<span class="comment">//将" 转义为\"</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成josn</span></span><br><span class="line"><span class="keyword">var</span> escapeForJsJson = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="富文本防御方法"><a href="#富文本防御方法" class="headerlink" title="富文本防御方法"></a>富文本防御方法</h2><ul>
<li>使用黑名单过滤，过滤不符合要求的标签和属性。实现相对简单，只需要按照正则表达式过滤。但是html是非常庞大，繁杂的，有太多的标签和属性，容易忽略，产生漏洞</li>
<li>使用白名单，保留部分标签和属性。过滤比较彻底，只允许指定的标签，属性存在。但是实现比较麻烦，需要将html完全解析成树状结构，针对这个dom树，遍历它的元素，保留白名单中的标签和属性，其他的过滤掉。过滤完之后，再组装成html。</li>
</ul>
<h3 id="使用黑名单过滤"><a href="#使用黑名单过滤" class="headerlink" title="使用黑名单过滤"></a>使用黑名单过滤</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//需要过滤javascript</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(1)"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//需要过滤script</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    alert(2);sssss;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过黑名单过滤</span></span><br><span class="line"><span class="keyword">var</span> xssFilter = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!html) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    html = html.replace(<span class="regexp">/&lt;\s*\/?script\s*&gt;/g</span>, <span class="string">''</span>);<span class="comment">//将script转义为空</span></span><br><span class="line">    html = html.replace(<span class="regexp">/javascript[^'"]*/g</span>, <span class="string">''</span>);<span class="comment">//将javascript转义为空</span></span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用白名单过滤"><a href="#使用白名单过滤" class="headerlink" title="使用白名单过滤"></a>使用白名单过滤</h3><ul>
<li>使用<a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">cheerio</a>处理XSS攻击<ul>
<li>解析html，对标签，属性进行过滤，最终返回html，需要自己维护，完善白名单列表</li>
</ul>
</li>
<li>使用<a href="https://github.com/leizongmin/js-xss" target="_blank" rel="noopener">js-xss</a>处理XSS攻击</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用白名单处理富文本</span></span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>)</span><br><span class="line"><span class="keyword">var</span> xssFilter3 = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!html) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">	<span class="keyword">const</span> $ = cheerio.load(html)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义白名单 需要进行维护，完善该名单</span></span><br><span class="line">	<span class="keyword">const</span> whiteList = &#123;</span><br><span class="line">		<span class="string">'img'</span>: [<span class="string">'src'</span>],<span class="comment">//标签名：属性列表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤标签属性</span></span><br><span class="line">	$(<span class="string">'*'</span>).each(<span class="function">(<span class="params">index, elem</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">//标签不存在白名单中 直接移除</span></span><br><span class="line">		<span class="keyword">if</span> (!whiteList[elem.name]) &#123;</span><br><span class="line">			$(elem).remove();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// //标签在白名单中 处理属性</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> elem.attribs)&#123;</span><br><span class="line">			<span class="keyword">if</span>(whiteList[elem.name].indexOf(attr)===<span class="number">-1</span>)&#123;</span><br><span class="line">				<span class="comment">//移除属性</span></span><br><span class="line">				$(elem).attr(attr,<span class="literal">null</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//返回过滤后的标签属性</span></span><br><span class="line">	<span class="keyword">return</span> $.html()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="防御-XSS-攻击"><a href="#防御-XSS-攻击" class="headerlink" title="防御 XSS 攻击"></a>防御 XSS 攻击</h2><ul>
<li>HttpOnly 防止劫取 Cookie</li>
<li>用户的输入检查</li>
<li>服务端的输出检查</li>
<li>使用<a href="https://github.com/leizongmin/js-xss" target="_blank" rel="noopener">js-xss</a>处理XSS攻击</li>
</ul>
<h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>HTTP 响应头<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener">Content-Security-Policy（内容安全策略）</a>允许站点管理者控制用户代理能够为指定的页面加载哪些资源，可以指定哪些内容可以执行。这将帮助防止跨站脚本攻击（Cross-Site Script）（XSS）。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">内容安全策略CSP)</a> 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p>
<h3 id="启用CSP"><a href="#启用CSP" class="headerlink" title="启用CSP"></a>启用CSP</h3><ul>
<li>服务器响应头添加 Content-Security-Policy 来指定规则</li>
<li>HTML 中 &lt;meta&gt; 元素也可以被用来配置该策略</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self'; img-src https://*; child-src 'none';"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="制定策略"><a href="#制定策略" class="headerlink" title="制定策略"></a>制定策略</h3><p>你可以使用  Content-Security-Policy HTTP头部 来指定你的策略，像这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// policy参数是一个包含了各种描述你的CSP策略指令的字符串。</span><br><span class="line">Content-Security-Policy: policy</span><br></pre></td></tr></table></figure>

<h3 id="更多策略指令"><a href="#更多策略指令" class="headerlink" title="更多策略指令"></a>更多策略指令</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener">更多策略指令</a></p>
<h3 id="描述策略"><a href="#描述策略" class="headerlink" title="描述策略"></a>描述策略</h3><p>一个策略由一系列策略指令所组成，每个策略指令都描述了一个针对某个特定类型资源以及生效范围的策略。你的策略应当包含一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src" target="_blank" rel="noopener">default-src</a>策略指令，在其他资源类型没有符合自己的策略时应用该策略。一个策略可以包含 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src" target="_blank" rel="noopener">default-src</a>  或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/script-src" target="_blank" rel="noopener">script-src</a> 指令来防止内联脚本运行, 并杜绝eval()的使用。 一个策略也可包含一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/default-src" target="_blank" rel="noopener">default-src</a> 或  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/style-src" target="_blank" rel="noopener">style-src</a> 指令去限制来自一个 &lt;style&gt; 元素或者style属性的內联样式。</p>
<h3 id="常见用例"><a href="#常见用例" class="headerlink" title="常见用例"></a>常见用例</h3><ul>
<li><p>示例 1：一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 2：一个网站管理者允许内容来自信任的域名及其子域名 (域名不必与CSP设置所在的域名相同)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos; *.trusted.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 3：</p>
<ul>
<li><p>一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码.</p>
</li>
<li><p>在这里，各种内容默认仅允许从文档所在的源获取, 但存在如下例外:</p>
<ul>
<li>图片可以从任何地方加载(注意 “*” 通配符)。</li>
<li>多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)。</li>
<li>可运行脚本仅允许来自于userscripts.example.com。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>示例 4：</p>
<ul>
<li>一个线上银行网站的管理者想要确保网站的所有内容都要通过SSL方式获取，以避免攻击者窃听用户发出的请求。</li>
<li>该服务器仅允许通过HTTPS方式并仅从onlinebanking.jumbobank.com域名来访问文档。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src https://onlinebanking.jumbobank.com</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>示例 5：</p>
<ul>
<li>一个在线邮箱的管理者想要允许在邮件里包含HTML，同样图片允许从任何地方加载，但不允许JavaScript或者其他潜在的危险内容(从任意位置加载)。</li>
<li>注意这个示例并未指定script-src。在此CSP示例中，站点通过 default-src 指令的对其进行配置，这也同样意味着脚本文件仅允许从原始服务器获取。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos; *.mailsite.com; img-src *</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="更多案例说明"><a href="#更多案例说明" class="headerlink" title="更多案例说明"></a>更多案例说明</h3><p><a href="https://infosec.mozilla.org/guidelines/web_security#Examples_5" target="_blank" rel="noopener">更多案例说明</a></p>
<h3 id="对策略进行测试"><a href="#对策略进行测试" class="headerlink" title="对策略进行测试"></a>对策略进行测试</h3><p>为降低部署成本，CSP可以部署为报告(report-only)模式。在此模式下，CSP策略不是强制性的，但是任何违规行为将会报告给一个指定的URI地址。此外，一个报告模式的头部可以用来测试一个修订后的未来将应用的策略而不用实际部署它。</p>
<p>你可以用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only" target="_blank" rel="noopener">Content-Security-Policy-Report-Only</a> HTTP 头部来指定你的策略，像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy-Report-Only: policy</span><br></pre></td></tr></table></figure>

<p>如果Content-Security-Policy-Report-Only 头部和 Content-Security-Policy 同时出现在一个响应中，两个策略均有效。在Content-Security-Policy 头部中指定的策略有强制性 ，而Content-Security-Policy-Report-Only中的策略仅产生报告而不具有强制性。</p>
<p>支持CSP的浏览器将始终对于每个企图违反你所建立的策略都发送违规报告，如果策略里包含一个有效的report-uri 指令。</p>
<h3 id="启用违例报告"><a href="#启用违例报告" class="headerlink" title="启用违例报告"></a>启用违例报告</h3><p>默认情况下，违规报告并不会发送。为启用发送违规报告，你需要指定 report-uri 策略指令，并提供至少一个URI地址去递交报告：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos;; report-uri http://reportcollector.example.com/collector.cgi</span><br></pre></td></tr></table></figure>

<p>然后你需要设置你的服务器能够接收报告，使其能够以你认为恰当的方式存储并处理这些报告。</p>
<h3 id="违例报告的语法"><a href="#违例报告的语法" class="headerlink" title="违例报告的语法"></a>违例报告的语法</h3><p>作为报告的JSON对象报告包含了以下数据：</p>
<ul>
<li>document-uri：发生违规的文档的URI。</li>
<li>referrer：违规发生处的文档引用（地址）。</li>
<li>blocked-uri：被CSP阻止的资源URI。如果被阻止的URI来自不同的源而非文档URI，那么被阻止的资源URI会被删减，仅保留协议，主机和端口号。</li>
<li>violated-directive：违反的策略名称。</li>
<li>original-policy：在 Content-Security-Policy HTTP 头部中指明的原始策略。</li>
</ul>
<h3 id="违例报告样本"><a href="#违例报告样本" class="headerlink" title="违例报告样本"></a>违例报告样本</h3><p>我们假设页面位于 <strong><a href="http://example.com/signup.html" target="_blank" rel="noopener">http://example.com/signup.html</a></strong>。它使用如下策略，该策略禁止任何资源的加载，除了来自cdn.example.com的样式表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;none&apos;; style-src cdn.example.com; report-uri /_/csp-reports</span><br></pre></td></tr></table></figure>

<p>signup.html 的HTML像这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sign Up<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ... Content ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你能看出其中错误吗？样式表仅允许加载自cdn.example.com，然而该页面企图从自己的源 <strong>(<a href="http://example.com" target="_blank" rel="noopener">http://example.com</a>)</strong> 加载。当该文档被访问时，一个兼容CSP的浏览器将以POST请求的形式发送违规报告到 <strong><a href="http://example.com/_/csp-reports" target="_blank" rel="noopener">http://example.com/_/csp-reports</a></strong>，内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"csp-report"</span>: &#123;</span><br><span class="line">    <span class="attr">"document-uri"</span>: <span class="string">"http://example.com/signup.html"</span>,</span><br><span class="line">    <span class="attr">"referrer"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"blocked-uri"</span>: <span class="string">"http://example.com/css/style.css"</span>,</span><br><span class="line">    <span class="attr">"violated-directive"</span>: <span class="string">"style-src cdn.example.com"</span>,</span><br><span class="line">    <span class="attr">"original-policy"</span>: <span class="string">"default-src 'none'; style-src cdn.example.com; report-uri /_/csp-reports"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，该报告在blocked-uri字段中包含了违规资源的完整路径 ，但情况并非总是如此。比如，当signup.html试图从   <strong><a href="http://anothercdn.example.com/stylesheet.css" target="_blank" rel="noopener">http://anothercdn.example.com/stylesheet.css</a></strong> 加载CSS时，浏览器将不会包含完整路径，而只会保留源路径 <strong>(<a href="http://anothercdn.example.com" target="_blank" rel="noopener">http://anothercdn.example.com</a>)</strong>。CSP技术规范对此古怪行为<a href="https://www.w3.org/TR/CSP/#violation-reports" target="_blank" rel="noopener">给出了解释</a>。大体上说，这样是为了防止泄露跨域资源的敏感信息。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">内容安全策略</a></li>
<li><a href="https://coding.imooc.com/class/104.html" target="_blank" rel="noopener">Web前后端漏洞分析与防御</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener">Content-Security-Policy</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化-重绘与回流</title>
    <url>/2019-10-18/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/</url>
    <content><![CDATA[<h2 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><p>当 <strong><em>Render Tree</em></strong> 当中有元素的大小、布局、结构等发生改变时，就会触发回流，每个页面在首次加载的时候都需要进行至少一次回流；</p><p>当 <strong><em>Render Tree</em></strong> 有元素属性需要更新，这些属性只是影响元素的外观、风格，那么则会触发重绘。</p><p>重绘不一定导致回流，回流一定会导致重绘。</p><p>回流比重绘的代价要更高。</p><a id="more"></a>



<h2 id="触发重绘"><a href="#触发重绘" class="headerlink" title="触发重绘"></a>触发重绘</h2><ul>
<li>color、background 相关属性(如：background-color、background-image 等)</li>
<li>outline 相关属性( outline-color、outline-width )、text-decoration</li>
<li>border-radius、visibility、box-shadow</li>
</ul>
<h2 id="触发回流"><a href="#触发回流" class="headerlink" title="触发回流"></a>触发回流</h2><h3 id="触发页面重布局"><a href="#触发页面重布局" class="headerlink" title="触发页面重布局"></a>触发页面重布局</h3><ul>
<li>盒子模型相关属性会触发重布局：width、height、padding、margin、display、border-width、border、min-height </li>
<li>定位属性及浮动会触发重布局：top、bottom、left、right、position、float、clear</li>
<li>改变节点内部文字结构也会触发重布局：text-align、font-weight、font-family、line-height、vertical-align、white-space、font-size、overflow、overflow-y</li>
</ul>
<h3 id="触发回流的操作"><a href="#触发回流的操作" class="headerlink" title="触发回流的操作"></a>触发回流的操作</h3><ul>
<li>页面初次渲染</li>
<li>元素大小发生变化</li>
<li>元素的位置发生变化</li>
<li>浏览器窗口大小变化</li>
<li>添加或者删除 DOM 元素</li>
<li>激活 CSS 伪类</li>
<li>改变字体</li>
<li>获取即时计算的属性：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle、scrollIntoView()、scrollIntoViewIfNeeded()getBoundingClientRect()、scrollTo()</li>
</ul>
<h2 id="Flush-队列"><a href="#Flush-队列" class="headerlink" title="Flush 队列"></a>Flush 队列</h2><p>现代浏览器会对频繁的回流或重绘操作进行优化：</p>
<p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p>
<p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p>
<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>width、height</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
</ul>
<p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p>
<p>基本上都是获取即时计算的属性。</p>
<h2 id="减少重绘与回流"><a href="#减少重绘与回流" class="headerlink" title="减少重绘与回流"></a>减少重绘与回流</h2><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul>
<li>避免使用table布局。</li>
<li>尽可能在DOM树的最末端改变class。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到position属性为absolute或fixed的元素上。</li>
<li>避免使用CSS表达式（例如：calc()）。</li>
</ul>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul>
<li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li>
<li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li>
<li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<h2 id="扩展部分"><a href="#扩展部分" class="headerlink" title="扩展部分"></a>扩展部分</h2><p>更加完整的渲染流程</p>
<p><img src="/images/render4.jpg" alt="更加完整的渲染流程"></p>
<p>上面提到把 position 设置为absolute 或者 fixed，其实就是把 Render Tree 上面的这个元素提升到了 Render Layer，提升到 Render Layer 之后，这个时候就不会影响其他元素也进行回流操作，而只会自己进行回流操作，那么这就是背后真正的原因。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tips:动画除了可以使用 position 设置为 absolute 或 fixed 优化之外，还可以使用启用硬件加速( GPU加速 )来进行优化，比如说一些移动元素的操作我们可以使用 translate3d() 方法来完成，使用这个方法之后，我们就触发了硬件加速，由于硬件加速使用的是 GPU 绘制，所以速度更快，而且不会引起回流和重绘，性能也可以得到较大的提升。</span><br></pre></td></tr></table></figure>

<h2 id="Chrome创建-Render-Layer-图层的条件"><a href="#Chrome创建-Render-Layer-图层的条件" class="headerlink" title="Chrome创建 Render Layer 图层的条件"></a>Chrome创建 Render Layer 图层的条件</h2><ul>
<li>3D和透视变换CSS属性(perspective transform)</li>
<li>使用加速视频解码的 video 标签</li>
<li>3D Webgl的上下文或加速2D上下文的 canvas 节点</li>
<li>混合插件 (如Flash)</li>
<li>css3硬件加速（GPU加速）transform，opacity，filters，Will-change</li>
</ul>
<h3 id="常用方法生成独立图层："><a href="#常用方法生成独立图层：" class="headerlink" title="常用方法生成独立图层："></a>常用方法生成独立图层：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform: translateZ(0);</span><br><span class="line"></span><br><span class="line">will-change: transform;</span><br></pre></td></tr></table></figure>

<p>将频发触发重绘与回流的 Dom 元素，独立到一个独立的图层。但是 Composite Layers 合并图层也会消耗性能，过多的图层可能导致性能更差。</p>
<h2 id="如何查看重绘与回流"><a href="#如何查看重绘与回流" class="headerlink" title="如何查看重绘与回流"></a>如何查看重绘与回流</h2><ul>
<li><p>1.按F12进入开发者工具，打开performance面板。</p>
</li>
<li><p>2.点击最左侧的黑色圆就可以开始一个新的监测记录。</p>
</li>
</ul>
<h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><p>以天猫手机端为例，获取顶部的滚动栏渲染信息。</p>
<p><img src="/images/render5.png" alt="渲染信息"></p>
<p>通过Main图表，Summary面板可以查看重绘与回流相关信息。</p>
<p><img src="/images/render6.png" alt="重绘与回流信息"></p>
<h2 id="如何查看Render-Layer"><a href="#如何查看Render-Layer" class="headerlink" title="如何查看Render Layer"></a>如何查看Render Layer</h2><p>如下图所示：</p>
<p><img src="/images/render7.png" alt="Render Layer"></p>
<p><img src="/images/render8.png" alt="Render Layer2"></p>
<p>Layers 面板可以查看详细的 Render Layer 信息。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/" target="_blank" rel="noopener">回流与重绘：CSS性能让JavaScript变慢？</a></li>
<li><a href="https://juejin.im/post/5a9923e9518825558251c96a" target="_blank" rel="noopener">浏览器的回流与重绘</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化-DOM性能优化</title>
    <url>/2019-10-18/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-DOM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端需要频繁操作 DOM，为了提高网站性能，需要针对 DOM 操作进行相应优化。</p><h2 id="使用DOM的引用"><a href="#使用DOM的引用" class="headerlink" title="使用DOM的引用"></a>使用DOM的引用</h2><p>比如：我们需要对一组 li 标签进行遍历操作，我们可以用一个变量 length 把这组 li 标签的长度保存下来，然后基于length 进行遍历。</p><h2 id="使用事件代理批量处理事件"><a href="#使用事件代理批量处理事件" class="headerlink" title="使用事件代理批量处理事件"></a>使用事件代理批量处理事件</h2><p>比如：给一系列子元素 li 添加绑定事件，可以通过事件代理来进行优化。</p><a id="more"></a>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// container：父元素</span></span><br><span class="line">container.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    target = e.target || e.srcElement;</span><br><span class="line">    <span class="keyword">if</span> (target.tagName.toLowerCase() == <span class="string">'li'</span>) &#123;</span><br><span class="line">        <span class="comment">// 触发click后要做的事情</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h2 id="使用文档碎片"><a href="#使用文档碎片" class="headerlink" title="使用文档碎片"></a>使用文档碎片</h2><p>DocumentFragments 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。</p>
<p>因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。</p>
<p>这个方法真是处理批量标签的一大利器，使用它可以节省下很多时间，提高 DOM 性能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"><span class="keyword">let</span> wrapper = <span class="built_in">document</span>.createDocumentFragment; <span class="comment">// 使用文档碎片</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">    li.innerText = data[i];</span><br><span class="line">&#125;</span><br><span class="line">wrapper.appendChild(li);</span><br><span class="line">container.appendChild(wrapper);</span><br><span class="line">container.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    target = e.target || e.srcElement;</span><br><span class="line">    <span class="keyword">if</span> (target.tagName.toLowerCase() == <span class="string">'li'</span>) &#123;</span><br><span class="line">        <span class="comment">// 触发click后要做的事情</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h2 id="使用innerHTML一次性添加DOM节点"><a href="#使用innerHTML一次性添加DOM节点" class="headerlink" title="使用innerHTML一次性添加DOM节点"></a>使用innerHTML一次性添加DOM节点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"><span class="keyword">var</span> sHtml = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> len = data.length;</span><br><span class="line"><span class="keyword">var</span> i, li;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    sHtml += <span class="string">'&lt;li&gt;'</span> + data[i] + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">container.innerHTMl = sHtml; <span class="comment">// 最后一次性添加到页面中，只出发浏览器一次重排</span></span><br></pre></td></tr></table></figure>

<h2 id="通过className来批量修改元素样式"><a href="#通过className来批量修改元素样式" class="headerlink" title="通过className来批量修改元素样式"></a>通过className来批量修改元素样式</h2><p>经常有这样的场景，我们需要在js中批量的修改元素的样式，比如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ele.style.width = <span class="number">100</span> + <span class="string">'px'</span>;</span><br><span class="line">ele.style.height = <span class="number">100</span> + <span class="string">'px'</span>;</span><br><span class="line">ele.style.backgrounfColor = <span class="string">'red'</span>;</span><br><span class="line">ele.style.border = <span class="string">'solid 1px green'</span>;</span><br></pre></td></tr></table></figure>

<p>以上代码会多次出发浏览器重绘和重排，一种好的方式是将需要修改的样式在样式文件中先写好，通过给元素赋值className的形式批量修改样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.active</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">backgroung-color</span>: red;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给元素赋值className</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ele.className += <span class="string">' active'</span>; <span class="comment">// 注意前面的空格</span></span><br></pre></td></tr></table></figure>

<h2 id="如何渲染几万条数据并不卡住界面"><a href="#如何渲染几万条数据并不卡住界面" class="headerlink" title="如何渲染几万条数据并不卡住界面"></a>如何渲染几万条数据并不卡住界面</h2><p>可以通过 requestAnimationFrame 动画，动态渲染数据。</p>
<p>与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>如何渲染几万条数据并不卡住界面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        控件</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 异步任务 避免阻塞</span></span></span><br><span class="line"><span class="javascript">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 插入十万条数据</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> total = <span class="number">100000</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 一次插入 20 条，如果觉得性能不好就减少</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> once = <span class="number">20</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 渲染数据总共需要几次</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> loopCount = total / once</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 循环渲染次数</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> countOfRender = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>)</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 使用文档碎片 优化性能，插入不会造成回流</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; once; i++) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span></span><br><span class="line"><span class="javascript">                    li.innerText = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total)</span></span><br><span class="line">                    fragment.appendChild(li)</span><br><span class="line">                &#125;</span><br><span class="line">                ul.appendChild(fragment)</span><br><span class="line">                countOfRender += 1</span><br><span class="line">                loop()</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 循环条件判断</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (countOfRender &lt; loopCount) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">window</span>.requestAnimationFrame(add)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            loop()</span><br><span class="line">        &#125;, 0)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://qianlongo.github.io/2016/04/14/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BDOM%E7%AF%87%E7%AB%A0/#more" target="_blank" rel="noopener">前端性能优化之DOM篇章</a></li>
<li><a href="https://juejin.im/post/5c3ca3d76fb9a049a979f429" target="_blank" rel="noopener">你知道的requestAnimationFrame</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染原理与性能优化</title>
    <url>/2019-10-18/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="浏览器的渲染引擎"><a href="#浏览器的渲染引擎" class="headerlink" title="浏览器的渲染引擎"></a>浏览器的渲染引擎</h2><ul>
<li>IE（Trident）</li>
<li>Chrome（Blink）</li>
<li>Firefox（Gecko）</li>
<li>Opera（Blink）</li>
<li>Safari（Webkit）</li>
<li>UC（U3）</li>
<li>QQ浏览器微信（X5/Blink）</li>
</ul><p><strong><em>Blink</em></strong> 渲染引擎占据了半壁江山，<strong><em>Blink</em></strong> 的前身都是由 <strong><em>Webkit</em></strong> 优化改造而来的。浏览器内核决定了浏览器解释网页语法的方式。不同的渲染引擎，从而也导致了浏览器的兼容性问题。</p><a id="more"></a>

<h2 id="浏览器渲染“黑盒”"><a href="#浏览器渲染“黑盒”" class="headerlink" title="浏览器渲染“黑盒”"></a>浏览器渲染“黑盒”</h2><p><img src="/images/render2.png" alt="浏览器渲染“黑盒”"></p>
<p>浏览器呈现网页这个过程，宛如一个黑盒。在这个神秘的黑盒中，有许多功能模块，内核内部的实现正是这些功能模块相互配合协同工作进行的。其中我们最需要关注的，就是 <strong><em>HTML 解释器</em></strong>、<strong><em>CSS 解释器</em></strong>、<strong><em>图层布局计算模块</em></strong>、<strong><em>视图绘制模块</em></strong> 与 <strong><em>JavaScript 引擎</em></strong> 这几大模块：</p>
<ul>
<li><p>HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。</p>
</li>
<li><p>CSS 解释器：解析 CSS 文档, 生成样式规则。</p>
</li>
<li><p>图层布局计算模块：布局计算每个对象的精确位置和大小。</p>
</li>
<li><p>视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。</p>
</li>
<li><p>JavaScript 引擎：编译执行 Javascript 代码。</p>
</li>
</ul>
<h2 id="渲染原理解析"><a href="#渲染原理解析" class="headerlink" title="渲染原理解析"></a>渲染原理解析</h2><p><img src="/images/render1.jpg" alt="渲染原理"></p>
<ul>
<li>解析HTML<br>首先是解析HTML/SVG/XHTML，这个过程主要是把 HTML/SVG/XHTML 文档解析为 DOM 树的过程。<br>如果遇到 <strong>&lt;script&gt;</strong> 标签会停止解析，先执行标签当中 JavaScript；如果是外联方式，也需要等待下载并且执行完对应的 JavaScript 代码，然后才能够继续执行解析 HTML 的工作。HTML解析完成后触发 DOMContentLoaded 事件，这里我们就可以操作 DOM了。<br>在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。</li>
<li>解析CSS<br>解析 HTML 和解析 CSS 是并行处理的。解析 CSS 遇到 <strong>&lt;script&gt;</strong> 标签，会阻塞 CSS 的解析。CSS 解析器将 CSS 解析成 CSSStyleSheet (也被叫做 CSSOM 树)，这里的 CSSOM 树与 DOM 树结构类似。解析对应关系如下：<br><img src="/images/render3.jpg" alt="解析对应关系"></li>
<li>计算样式<br>CSSOM 与 DOM 树 结合，生成生成页面 render 树。</li>
<li>计算图层布局<br>页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。</li>
<li>绘制图层<br>在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。</li>
<li>整合图层，得到页面<br>最后一步浏览器会合并各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。</li>
</ul>
<h3 id="渲染过程概括"><a href="#渲染过程概括" class="headerlink" title="渲染过程概括"></a>渲染过程概括</h3><ul>
<li>当浏览器拿到一个网页后，首先浏览器会先解析HTML，如果遇到了外链的css，会一下载css，一边解析HTML。</li>
<li>当css下载完成后，会继续解析css，生成css Rules tree,不会影响到HTML的解析。</li>
<li>当遇到 <strong>&lt;script&gt;</strong> 标签时，一旦发现有对javascript的引用，就会立即下载脚本，同时阻断文档的解析，等脚本执行完成后，再开始文档的解析。</li>
<li>当DOM树和CSS规则树已经生成完毕后，构造 Rendering Tree。</li>
<li>调用系统渲染页面。</li>
</ul>
<h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><h3 id="CSS-的阻塞"><a href="#CSS-的阻塞" class="headerlink" title="CSS 的阻塞"></a>CSS 的阻塞</h3><p>CSS 解析和HTML解析是同步进行的，那么一个 HTML 文档首先解析的肯定是 HTML，然后才是 CSS，这就导致了 HTML 解析完成后，往往需要等待 CSS 解析。如果 CSS 没有解析完成，我们就需要一直等，这里就是 CSS 阻塞了相关的渲染。</p>
<p>CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</p>
<p>CSS 会阻塞后面内联 JavaScript 的执行。</p>
<p>我们往往把 CSS 样式表全部通过 <strong>&lt;style&gt;</strong> 标签内联到网页当中，或启用 CDN 实现静态资源加载速度的优化</p>
<h3 id="JS-的阻塞"><a href="#JS-的阻塞" class="headerlink" title="JS 的阻塞"></a>JS 的阻塞</h3><p>JS 引擎是独立于渲染引擎存在的。JavaScript 既会阻塞 HTML 解析，也会阻塞 CSS 解析。因此我们可以改变 JavaScript 的加载方式或者加载时机来进行优化：</p>
<ul>
<li>尽量将 JavaScript 文件放在 body 的底部；</li>
<li>body中间尽量不要写 <strong>&lt;script&gt;</strong> 标签；</li>
<li>使用 defer 和 async 来避免不必要的阻塞</li>
</ul>
<h3 id="JS的四种加载方式"><a href="#JS的四种加载方式" class="headerlink" title="JS的四种加载方式"></a>JS的四种加载方式</h3><ul>
<li><p>正常模式：这种情况下 JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执行完毕才能去做其它事情。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"index.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>async 模式：JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。使用 async 模式引入的多个 script 的执行顺序是不确定的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"index.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>defer 模式：JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。使用 defer 模式引入的多个 script 是从上往下顺序执行的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"index.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>动态异步引入<br>使用 document.createElement 创建的 script 默认是异步的，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.createElement(<span class="string">"script"</span>).async); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。defer 一般用于业务代码。如第三方统计代码。</p>
<p>注意 async 与 defer 属性对于 inline-script 都是无效的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://juejin.im/book/5b936540f265da0a9624b04b" target="_blank" rel="noopener">前端性能优化原理与实践</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-文件指纹策略：chunkhash、contenthash和hash</title>
    <url>/2019-10-18/webpack/webpack-%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9%E7%AD%96%E7%95%A5%EF%BC%9Achunkhash%E3%80%81contenthash%E5%92%8Chash/</url>
    <content><![CDATA[<h2 id="什么是文件指纹"><a href="#什么是文件指纹" class="headerlink" title="什么是文件指纹"></a>什么是文件指纹</h2><ul>
<li>打包后输出文件名的后缀</li>
<li>通常用于版本管理</li>
<li>hash一般是结合CDN缓存来使用，通过webpack构建之后，生成对应文件名自动带上对应的MD5值。如果文件内容改变的话，那么对应文件哈希值也会改变，对应的HTML引用的URL地址也会改变，触发CDN服务器从源服务器上拉取对应数据，进而更新本地缓存</li>
</ul><a id="more"></a>
<h2 id="文件指纹如何生成"><a href="#文件指纹如何生成" class="headerlink" title="文件指纹如何生成"></a>文件指纹如何生成</h2><ul>
<li>Hash：和整个项目的构建相关，webpack打包阶段会生成Compiler，Compilation。webpack启动那一次，会生成Compiler（初始化一次）。但是每一次只要项目文件有修改，，Compilation都会发生变化。Compilation变换就会影响Hash的变换，整个项目构建的 hash 值就会更改。如果css/js都是使用hash作为文件指纹的话，那么某一个js或者css发生改变，所有打包出来的css/js指纹都会变化。不利于缓存</li>
<li>Chunkhash：采用hash计算的话，每一次构建后生成的哈希值都不一样，即使文件内容压根没有改变。这样子是没办法实现缓存效果，我们需要换另一种哈希值计算方式，即chunkhash,chunkhash和hash不一样，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响</li>
<li>Contenthash：根据文件内容来定义 hash ，文件内容不变，则 contenthash 不变。某个页面既有js资源，又有css资源。如果css资源也使用Chunkhash。如果修改了js。由于css资源使用了Chunkhash，就会导致css内容没有变化，发布上线的文件却发生了变化。因此，通常对css资源使用Contenthash。这个时候可以使用mini-css-extract-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建</li>
</ul>
<h2 id="JS-的文件指纹设置"><a href="#JS-的文件指纹设置" class="headerlink" title="JS 的文件指纹设置"></a>JS 的文件指纹设置</h2><ul>
<li>设置 output 的 filename，使用 [chunkhash]，或[contenthash]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">        search: <span class="string">'./src/search.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name][chunkhash:8].js'</span>,</span><br><span class="line">        path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="CSS-的文件指纹设置"><a href="#CSS-的文件指纹设置" class="headerlink" title="CSS 的文件指纹设置"></a>CSS 的文件指纹设置</h2><ul>
<li>设置 MiniCssExtractPlugin 的 filename，使用 [contenthash]<ul>
<li>MiniCssExtractPlugin：将css资源提取到一个独立的文件。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">        search: <span class="string">'./src/search.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name][chunkhash:8].js'</span>,</span><br><span class="line">        path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">`[name][contenthash:8].css`</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="图片，字体文件的文件指纹设置"><a href="#图片，字体文件的文件指纹设置" class="headerlink" title="图片，字体文件的文件指纹设置"></a>图片，字体文件的文件指纹设置</h2><ul>
<li>设置 file-loader（或url-loader） 的 name，使用 [hash]</li>
</ul>
<table>
<thead>
<tr>
<th>占位符名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>[ext]</td>
<td>资源后缀名</td>
</tr>
<tr>
<td>[name]</td>
<td>文件名称</td>
</tr>
<tr>
<td>[path]</td>
<td>文件的相对路径</td>
</tr>
<tr>
<td>[floder]</td>
<td>文件所在文件夹</td>
</tr>
<tr>
<td>[contenthash]</td>
<td>文件的内容hash，默认是md5生成</td>
</tr>
<tr>
<td>[hash]</td>
<td>文件内容hash，默认是md5生成。图片的hash和css/js资源的hash概念不一样，图片的hash是由图片内容决定的</td>
</tr>
<tr>
<td>[emoji]</td>
<td>一个随机的指代文件内容的emoji</td>
</tr>
</tbody></table>
<p>注意：图片，字体文件的hash和css/js资源的hash概念不一样，图片，字体文件的hash是由内容决定的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        name: <span class="string">'img/[name][hash:8].[ext] '</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Webpack-具体配置信息"><a href="#Webpack-具体配置信息" class="headerlink" title="Webpack 具体配置信息"></a>Webpack 具体配置信息</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./test/test.js'</span>,</span><br><span class="line">        about: <span class="string">'./test/about.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        <span class="comment">//打包文件名称  chunkhash:8设置js资源的文件指纹</span></span><br><span class="line">        filename: <span class="string">'[name].[chunkhash:8].js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [&#123; <span class="attr">loader</span>: MiniCssExtractPlugin.loader &#125;, <span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">                loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                query: &#123;</span><br><span class="line">                    <span class="comment">// 设置图片资源的文件指纹 使用hash</span></span><br><span class="line">                    name: <span class="string">'[name].[ext]?[hash]'</span>,</span><br><span class="line">                    outputPath: <span class="string">'static/img/'</span>,</span><br><span class="line">                    publicPath: <span class="string">'/dist/static/img/'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,<span class="comment">//解析字体</span></span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            name: <span class="string">'[name]_[hash:8].[ext]'</span>,<span class="comment">//设置字体资源的文件指纹 使用hash</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            <span class="comment">// 将css资源提取到一个独立的文件</span></span><br><span class="line">            <span class="comment">// 设置css资源的文件指纹 用contenthash</span></span><br><span class="line">            filename: <span class="string">'[name].[contenthash:8].css'</span>,</span><br><span class="line">            chunkFilename: <span class="string">'[id].css'</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通常的文件缓存策略"><a href="#通常的文件缓存策略" class="headerlink" title="通常的文件缓存策略"></a>通常的文件缓存策略</h2><ul>
<li>html: header 头的 cache-control 会设置成 no-cache。也就是 html 文件不会走缓存</li>
<li>css/js/img 等静态资源：header头的 cache-control 设置成强缓存，缓存时间通常是1年的样子。通过文件指纹控制缓存是否失效，文件指纹一变，请求就不会走旧文件了</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化-浏览器缓存</title>
    <url>/2019-10-17/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：</p><ul>
<li>Memory Cache</li>
<li>Service Worker Cache</li>
<li>HTTP Cache</li>
<li>Push Cache</li>
</ul><p><img src="/images/cache3.jpg" alt="浏览器缓存"></p><p>其中，“from memory cache”对标到 Memory Cache 类型，“from ServiceWorker”对标到 Service Worker Cache 类型。至于 Push Cache，这个比较特殊，是 HTTP2 的新特性。</p><a id="more"></a>



<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>它需要服务端和客户端配合才能完成，常见的服务器软件如：Apache、Nginx都可以为资源设置不同的HTTP缓存策略。HTTP缓存策略又细分为 <strong><em>强制缓存</em></strong> 和 <strong><em>协商缓存</em></strong> 。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。</p>
<h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>强缓存是利用 http 头中的 <strong><em>Expires</em></strong> 和 <strong><em>Cache-Control</em></strong> 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。</p>
<p>命中强缓存的情况下，返回的 HTTP 状态码为 200 （如下图）:</p>
<p><img src="/images/cache4.png" alt="HTTP 状态码 200"></p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>expires是强制缓存策略的关键字段，expires是HTTP1.0的字段，是一个绝对时间值。当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段。像这样：</p>
<p><img src="/images/cache5.jpg" alt="Expires"></p>
<p>expires 是一个时间戳，当再次向服务器请求资源，浏览器本地时间和 expires 的时间戳会进行对比，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。</p>
<p>expires 最大的问题在于对“本地时间”的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达到我们的预期。可以通过 Cache-Control 解决这个问题。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>HTTP1.1 新增了 Cache-Control 字段来完成 expires 的任务。Cache-Control 可以视作是 expires 的完全替代方案。Cache-Control设置的是一个相对时间，可以更加精准地控制资源缓存。</p>
<p><img src="/images/cache6.jpg" alt="Cache-Control"></p>
<h4 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h4><ul>
<li>public<br>设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用<strong>max-age=</strong>来精确控制；</li>
<li>private<br>设置了该字段值的资源只能被用户浏览器缓存，不能作为共享缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；</li>
<li>no-cache<br>设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；</li>
<li>no-store<br>设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；</li>
</ul>
<h3 id="到期时间"><a href="#到期时间" class="headerlink" title="到期时间"></a>到期时间</h3><ul>
<li>max-age=<br>设置缓存的最大有效期，单位为秒；</li>
<li>s-maxage=：<br>优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；</li>
<li>max-stale[=]：<br>设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</li>
</ul>
<p>实际开发当中expires和Cache-Control一般都要进行设置，这是为了兼容不支持HTTP1.1的环境。两者同时存在，Cache-Control的优先级要高于expires。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了</p>
<h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h3><p><strong><em>Last-Modified</em></strong> 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Last-Modified: Fri, 27 Oct 2019 06:35:57 GMT</span><br></pre></td></tr></table></figure>

<p>随后我们每次请求时，会带上一个叫 <strong><em>If-Modified-Since</em></strong> 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If-Modified-Since: Fri, 27 Oct 2019 06:35:57 GMT</span><br></pre></td></tr></table></figure>

<p>服务器接收到这个时间戳后，根据 <strong><em>If-Modified-Since</em></strong> 的字段值和服务端资源最后的修改时间是否一致来判断资源是否有修改。如果没有修改，则返回的状态码为304；如果有修改，则返回新的资源，状态码为200。</p>
<h3 id="Last-Modified-弊端"><a href="#Last-Modified-弊端" class="headerlink" title="Last-Modified 弊端"></a>Last-Modified 弊端</h3><ul>
<li>服务端对Last-Modified标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内被修改多次的话，这个时候服务端无法准确标注文件的修改时间。</li>
<li>服务端文件进行了编辑，但文件的内容没有改变，这个资源在再次被请求时，会被当做新资源，导致文件无法使用缓存。</li>
</ul>
<h3 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h3><p><strong><em>Etag</em></strong> 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 <strong><em>Etag</em></strong> 就是不同的，反之亦然。因此 <strong><em>Etag</em></strong> 能够精准地感知文件的变化。</p>
<p><strong><em>Etag</em></strong> 和 <strong><em>Last-Modified</em></strong> 类似，当首次请求时，服务器响应头里返回一个最初的标识符字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETag: W/&quot;2a3b-1602480f459&quot;</span><br></pre></td></tr></table></figure>

<p>随后我们每次请求时，会带上一个叫 <strong><em>if-None-Match</em></strong> 的字符串，它的值正是上一次 response 返回给它的 <strong><em>Etag</em></strong> 值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If-None-Match: W/&quot;2a3b-1602480f459&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Etag-弊端"><a href="#Etag-弊端" class="headerlink" title="Etag 弊端"></a>Etag 弊端</h3><p>Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。</p>
<h3 id="HTTP-缓存决策指南"><a href="#HTTP-缓存决策指南" class="headerlink" title="HTTP 缓存决策指南"></a>HTTP 缓存决策指南</h3><p><img src="/images/cache7.png" alt="HTTP 缓存决策指南"></p>
<p>当资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。</p>
<h2 id="缓存字段的配置"><a href="#缓存字段的配置" class="headerlink" title="缓存字段的配置"></a>缓存字段的配置</h2><h3 id="expires和cache-control"><a href="#expires和cache-control" class="headerlink" title="expires和cache-control"></a>expires和cache-control</h3><p>如果使用的是 <strong><em>Nginx</em></strong>，那么打开Nginx的配置文件 <strong><em>nginx.conf</em></strong>，具体配置方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// expires:给图片设置过期时间30天，这里也可以设置其它类型文件</span></span><br><span class="line">location ~ \.(gif|jpg|jpeg|png)$ &#123;</span><br><span class="line">        root /<span class="keyword">var</span>/www/img/;</span><br><span class="line">        expires <span class="number">30</span>d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cache-control:给图片设置过期时间36秒，这里也可以设置其它类型文件</span></span><br><span class="line">location ~ \.(gif|jpg|jpeg|png)$ &#123;</span><br><span class="line">        root /<span class="keyword">var</span>/www/img/;</span><br><span class="line">        add_header    Cache-Control  max-age=<span class="number">3600</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用的是 <strong><em>Apache</em></strong>，那么打开Apache的配置文件 <strong><em>http.conf</em></strong>，具体的配置方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// expires</span><br><span class="line">&lt;IfModule expires_module&gt;</span><br><span class="line">      #打开缓存</span><br><span class="line">      ExpiresActive on </span><br><span class="line">      # 给图片设置过期时间30天，这里也可以设置其它类型文件</span><br><span class="line">      ExpiresByType image/gif access plus 30 days</span><br><span class="line">      ExpiresByType image/jpg access plus 30 days</span><br><span class="line">      ExpiresByType image/jpeg access plus 30 days</span><br><span class="line">      ExpiresByType image/png access plus 30 days</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">// cache-control</span><br><span class="line">&lt;FilesMatch &quot;\.(gif/jpg/jpeg/png)$&quot;&gt;</span><br><span class="line">　  	 Header set Cache-Control &quot;max-age=604800, public&quot;</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Last-Modified和Etag"><a href="#Last-Modified和Etag" class="headerlink" title="Last-Modified和Etag"></a>Last-Modified和Etag</h3><p>Last-Modified在Nginx和Apache当中都是默认启用的。</p>
<p>如果我们使用的是 <strong><em>Apache</em></strong>，那么只需要在 <strong><em>.htaccess</em></strong> 文件当中添加如下配置，即可开启Etag：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FileETag MTime Size</span><br></pre></td></tr></table></figure>

<p>如果我们使用的是 <strong><em>Nginx</em></strong>，需要先安装 <strong><em>Etag</em></strong> 模块；安装成功之后，仍然打开 <strong><em>nginx.conf</em></strong> 文件，确保当中没有出现 <strong><em>etgoff</em></strong>，然后添加如下配置，即可开启Etag：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ .*\.(gif|jpg|jpeg|png)$ &#123;</span><br><span class="line">   FileETag on;</span><br><span class="line">   etag_format &quot;%X%X%X&quot;; //这里格式化规则可以修改</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Service-Worker-Cache"><a href="#Service-Worker-Cache" class="headerlink" title="Service Worker Cache"></a>Service Worker Cache</h2><p>Service Worker是运行在浏览器背后的独立线程。可能大家在看到Service Worker这个概念的时候发现它经常和PWA一起出现。可以这么说，PWA应用在开发的时候必会用到Service Worker，这得益于Service强大的缓存能力。使用Service Worker前提必须是HTTPS协议，因为Service Worker涉及到了HTTP的拦截，所以必须使用HTTPS协议来保证安全。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="noopener">使用 Service Workers</a></p>
<h2 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h2><p>Memory Cache指得是内存中的缓存，大家都知道内存的读取是非常快的，但是空间确有限，而且持续性很短，一旦我们关闭当前tab页面，Memory Cache也就随着消失了。Memory Cache缓存的大部分是preloader指令下的静态资源。我们发现，Base64 格式的图片，几乎永远可以被塞进 memory cache。</p>
<h2 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h2><p>Disk Cache是存储在硬盘上的缓存，我们为静态资源设置的缓存一般都是缓存到Disk Cache当中，所以我们平时接触到最多的缓存就是Disk Cache。</p>
<h2 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h2><ul>
<li>Push Cache是推送缓存，它是HTTP2.0新增加的内容，目前实际的应用还偏少。</li>
<li>Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。</li>
<li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。</li>
<li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。</li>
<li><a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/" target="_blank" rel="noopener">了解更多</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://juejin.im/book/5b936540f265da0a9624b04b" target="_blank" rel="noopener">前端性能优化原理与实践</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化-本地存储</title>
    <url>/2019-10-17/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><ul>
<li>HTTP1.0中协议是无状态的，但在WEB应用中，在多个请求之间共享会话是非常必要的，所以出现了Cookie</li>
<li>cookie是为了辩别用户身份，进行会话跟踪而存储在客户端上的数据</li>
</ul><h3 id="Cookie原理"><a href="#Cookie原理" class="headerlink" title="Cookie原理"></a>Cookie原理</h3><p><img src="/images/cookie1.jpg" alt="Cookie原理"></p><p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会将cookie放入到响应请求中，在浏览器第二次发请求的时候，会把cookie带过去，服务端会辨别用户身份，当然服务器也可以修改cookie内容。</p><a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 服务器设置Cookie</span><br><span class="line">Set-Cookie:name=1111; Path=/</span><br></pre></td></tr></table></figure>

<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>Cookie一旦创建成功，那么名字无法进行修改；</li>
<li>Cookie不支持跨域，这是由Cookie隐私安全性所决定的，这样能够阻止非法获取其它网站的Cookie；</li>
<li>每个单独的域名下面的Cookie数量不能超过20个。</li>
<li>同一个域名下的所有请求，都会携带 Cookie。</li>
<li>Cookie 是有体积上限的，它最大只能有 4KB。当 Cookie 超过 4KB 时，将被裁切。</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取cookie 返回字符串</span></span><br><span class="line"><span class="keyword">const</span> allCookies = <span class="built_in">document</span>.cookie;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加cookie  newCookie是一个键值对形式的字符串。需要注意的是，用这个方法一次只能对一个cookie进行设置或更新。</span></span><br><span class="line"><span class="built_in">document</span>.cookie = newCookie;</span><br></pre></td></tr></table></figure>

<p>以下可选的cookie属性值可以跟在键值对后，用来具体化对cookie的设定/更新，使用分号以作分隔：</p>
<ul>
<li>path: 表示 cookie 影响到的路由，如 path=/。如果路径不能匹配时，浏览器则不发送这个Cookie</li>
<li>httpOnly: 如果在Cookie中设置了HttpOnly属性值true，那么通过JavaScript脚本将无法读取到cookie信息，保证Cookie不会被泄露，这样能有效的防止XSS攻击；</li>
<li>name: Cookie的名称，Cookie一旦创建，名称便不可更改；一个域名下绑定的cookie，name不能相同，相同的name的值会被覆盖掉。</li>
<li>value: Cookie的值。如果值为Unicode字符，需要为字符编码；如果值为二进制数据，则需要使用BASE64编码；</li>
<li>expires: 是一个绝对的过期时间，如果没有指定或为0表示当前会话有效；</li>
<li>maxAge: 是以秒为单位的，是一个相对时间。正常情况下，max-age的优先级高于expires。Max-Age为正数时，cookie会在Max-Age秒之后，被删除，当Max-Age为负数时，表示的是临时储存，不会生出cookie文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭，cookie就会消失，当Max-Age为0时，又会发生什么呢，删除cookie，因为cookie机制本身没有设置删除cookie，失效的cookie会被浏览器自动从内存中删除，所以，它实现的就是让cookie失效。</li>
<li>domain: 可以访问该Cookie的域名，如果设置为“.immoc.com”，则所有以“immoc.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”；</li>
<li>comment: Cookie的用处说明，浏览器显示Cookie信息的时候显示该说明。</li>
<li>secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>Cookie和Session结合使用是最常见的使用场景。我们把session_id存储在Cookie当中，然后每次请求的时候携带这个session_id，这样我们就知道是谁发起的请求，从而返回对应的信息；</li>
<li>统计页面的点击次数。</li>
</ul>
<h3 id="cookie使用注意事项"><a href="#cookie使用注意事项" class="headerlink" title="cookie使用注意事项"></a>cookie使用注意事项</h3><ul>
<li>可能被客户端篡改，使用前验证合法性</li>
<li>不要存储敏感数据，比如用户密码，账户余额</li>
<li>使用httpOnly保证安全</li>
<li>尽量减少cookie的体积</li>
<li>设置正确的domain和path，减少数据传输</li>
</ul>
<h2 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>大小方面相比，LocalStorage突破了4KB大小体积限制，一般是5MB;</li>
<li>LocalStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；</li>
<li>仅位于浏览器端，不与服务端发生通信。，不会像Cookie那样，每次的HTTP请求都会携带。</li>
</ul>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul>
<li>浏览器兼容性问题，IE只有在IE8以上的版本才会支持；</li>
<li>如果浏览器设置为隐私模式，那么我们无法读取LocalStorage；</li>
<li>LocalStorage受同源策略的限制，即协议、端口、主机地址有任何一个不同，则无法访问。</li>
</ul>
<h3 id="Local-Storage-应用场景"><a href="#Local-Storage-应用场景" class="headerlink" title="Local Storage 应用场景"></a>Local Storage 应用场景</h3><p>可以存储一些全局状态，数据。比如：个人昵称、不常改动的图片信息等。对于换肤这个需求，我们完全可以把换肤的信息存储在LocalStorage当中，操作LocalStorage即可。</p>
<h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p>Session Storage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p>
<h3 id="SessionStorage-应用场景"><a href="#SessionStorage-应用场景" class="headerlink" title="SessionStorage 应用场景"></a>SessionStorage 应用场景</h3><p>由于SessionStorage具有时效性，常用的业务场景比如网站常见的游客登录，就可以存储在SessionStorage当中，还有网站的一些临时浏览记录都可以使用SessionStorage来进行记录。</p>
<h2 id="Local-Storage-与-Session-Storage"><a href="#Local-Storage-与-Session-Storage" class="headerlink" title="Local Storage 与 Session Storage"></a>Local Storage 与 Session Storage</h2><ul>
<li>SessionStorage和LocalStorage一样都是在本地进行数据存储；</li>
<li>Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享。</li>
<li>LocalStorage和SessionStorage都不能被爬虫爬取；</li>
<li>LocalStorage和SessionStorage的API用法是非常相似的，具体的API使用方法如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存数据，以键值对的方式储存信息；</span></span><br><span class="line">setItem (key, value)</span><br><span class="line"><span class="comment">// 获取数据，将键值传入，即可获取到对应的value值；</span></span><br><span class="line">getItem (key)</span><br><span class="line"><span class="comment">// 删除单个数据，根据键值移除对应的信息</span></span><br><span class="line">removeItem (key)</span><br><span class="line"><span class="comment">// 删除所有的数据</span></span><br><span class="line">clear ()</span><br><span class="line"><span class="comment">// 获取某个索引的key</span></span><br><span class="line">key (index)</span><br></pre></td></tr></table></figure>

<h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexDB 是一个运行在浏览器上的非关系型数据库。理论上来说，IndexDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。。<a href="https://www.zhangxinxu.com/wordpress/2017/07/html5-indexeddb-js-example/" target="_blank" rel="noopener">了解更多</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化-CDN 缓存</title>
    <url>/2019-10-17/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-CDN-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h2><p><strong><em>CDN</em></strong> 的全称是 <strong><em>Content Delivery Network</em></strong>，即内容分发网络。CDN服务商将源站的资源缓存到遍布全国的高性能加速节点上，当用户访问相应的业务资源时，用户会被调度至最接近的节点最近的节点ip返回给用户，使内容能够传输的更快，更加稳定。可以提升首次请求的响应能力。</p><h2 id="CDN缓存-基本原理"><a href="#CDN缓存-基本原理" class="headerlink" title="CDN缓存 基本原理"></a>CDN缓存 基本原理</h2><a id="more"></a>
<p><strong><em>CDN</em></strong> 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<p><strong><em>CDN</em></strong> 的基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<h2 id="CDN的核心功能"><a href="#CDN的核心功能" class="headerlink" title="CDN的核心功能"></a>CDN的核心功能</h2><p>CDN 的核心点有两个，一个是缓存，一个是回源。</p>
<p>这两个概念都非常好理解。对标到上面描述的过程，“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。</p>
<h2 id="CDN缓存应用场景"><a href="#CDN缓存应用场景" class="headerlink" title="CDN缓存应用场景"></a>CDN缓存应用场景</h2><ul>
<li><p>使用第三方的CDN服务：前端开源项目的CDN加速服务，<a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">第三方的CDN服务</a></p>
</li>
<li><p>CDN 往往被用来存放静态资源：所谓“静态资源”，就是像 JS、CSS、图片等不需要业务服务器进行计算即得的资源。而“动态资源”，顾名思义是需要后端实时动态生成的资源，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。而且我们可以写脚本结合Webpack将对应的静态资源直接放到CDN，完成一键自动部署整个项目。</p>
</li>
<li><p>把静态资源和业务服务器置于不同的域名下：静态服务器最好启用一个全新域名，避免每次请求都携带Cookie。</p>
</li>
<li><p>直播传送：直播本质上是使用流媒体进行传送，那么CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化-缓存</title>
    <url>/2019-10-17/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手段。对于这个操作的必要性，Chrome 官方给出的解释似乎更有说服力一些：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="缓存的优点"><a href="#缓存的优点" class="headerlink" title="缓存的优点"></a>缓存的优点</h2><ul>
<li>获得更快的读写能力：相比数据库I/O操作磁盘，缓存I/O操作内存速度更快。</li>
<li>降低数据库压力：把常用的数据放在缓存中，请求直接读取缓存，可以减轻数据库的负担。</li>
<li>减少冗余数据传输：很多的静态资源，基本上很少有改动，有了缓存之后，我们只用在有文件改动的时候，再重新从服务器拉取新的资源即可。</li>
<li>节省流量：有了缓存，对于那些非常大的静态资源，我们无需每次进行请求，可以节省大量的流量，流量就是钱，对应的我们可以利用缓存为我们服务的公司节省一笔不小的开支。</li>
<li>降低时延：对于已经缓存好的数据，我们就无需再发请求给服务器，这样就节省下很多HTTP请求的时间，降低时延。</li>
</ul>
<h2 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类"></a>缓存的分类</h2><h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><p>CDN是通过在多个节点部署来减少请求时间的，这样我们不需要每次都回源到源站服务器进行请求。CDN对于常见的HTTP请求都是支持的，但是并不是对所有请求方式都会进行缓存，进行缓存的只有GET请求，对于其它请求均不作缓存，仅仅起到转发作用，相当于proxy。</p>
<p><img src="/images/cache1.jpg" alt="CDN缓存"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tips:关于CDN站点部署最好使用动静分离的形式，将动态请求和静态请求的内容独立成两个站点，而 CDN 仅仅加速静态站点中的资源，现在的CDN服务商大多数也都支持这个功能。</span><br></pre></td></tr></table></figure>

<h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><p>数据库属于 I/O 操作密集型的应用，主要负责数据的管理及存储。数据库缓存是一类特殊的缓存，是数据库自身的缓存机制。大多数据库不需要配置就可以快速运行，但并没有为特定的需求进行优化。在数据库调优的时候，缓存优化是一项很重要的工作。</p>
<p>数据库缓存就是我们把一些经常会被访问到资源直接放到内存当中，当数据没有变化我们并不会去让直接读写数据库，只有数据发生变化的时候我们才会去操作数据库。</p>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。</p>
<p>浏览器缓存是根据一套与服务端约定好的规则来进行工作的。</p>
<h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>本地存储主要有以下几种：LocalStorage、SessionStorage和Cookie、WebSql(废弃)和IndexDB，其中IndexDB主要用在前端有大容量存储需求的页面上，例如在线编辑或者网页邮箱。</p>
<h3 id="接口缓存"><a href="#接口缓存" class="headerlink" title="接口缓存"></a>接口缓存</h3><p>通过 AOP 面向切片编程，集合装饰器的使用，我们可以将一个接口请求的返回结果直接缓存起来。这样在调用这个接口的入参相同时，可以直接从缓存中读取数据，减少了请求，提高了相应速度。在此基础上，还可以对这个装饰器做进一步的优化，比如对存储对 key 做序列化并求 hash、给装饰器加锁防止并行操作等等。</p>
<h3 id="Web应用层缓存"><a href="#Web应用层缓存" class="headerlink" title="Web应用层缓存"></a>Web应用层缓存</h3><p>当平台级缓存不能满足系统性能要求的时候，就要考虑使用应用级缓存了。应用级缓存，需要开发者通过代码来实现缓存机制，这里主要使用NoSQL型数据库来进行相关实现。不管是Redis 还是MongoDB，以及Memcached 都可以作为应用级缓存的重要技术。一种典型的方式是每分钟或一段时间后统一生成某类页面存储在缓存中，或者可以在热数据变化时更新缓存。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree Shaking的使用和原理分析</title>
    <url>/2019-10-17/webpack/Tree-Shaking%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="tree-shaking-摇树优化"><a href="#tree-shaking-摇树优化" class="headerlink" title="tree shaking(摇树优化)"></a>tree shaking(摇树优化)</h2><ul>
<li>概念：1 个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到bundle 里面去，tree shaking 就是只把用到的方法打入 bundle ，没用到的方法会在uglify 阶段被擦除掉</li>
<li>使用：<ul>
<li>webpack 默认支持，在 .babelrc 里设置 modules: false 即可</li>
<li>production mode的情况下默认开启</li>
</ul>
</li>
<li>要求：<ul>
<li>必须是 ES6 的语法，CJS 的方式不支持</li>
<li>需要tree shaking的模块代码是没有副作用的，否则tree shaking会失效</li>
</ul>
</li>
</ul><a id="more"></a>
<h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><ul>
<li>副作用这个概念来源于函数式编程(FP)，纯函数是没有副作用的，也不依赖外界环境或者改变外界环境。纯函数的概念是：接受相同的输入，任何情况下输出都是一样的。</li>
<li>非纯函数存在副作用，副作用就是：相同的输入，输出不一定相同。或者这个函数会影响到外部变量、外部环境。</li>
<li>函数如果调用了全局对象或者改变函数外部变量，则说明这个函数有副作用</li>
</ul>
<h2 id="DCE-Dead-code-elimination"><a href="#DCE-Dead-code-elimination" class="headerlink" title="DCE (Dead code elimination)"></a>DCE (Dead code elimination)</h2><ul>
<li><p>没有导入和使用</p>
</li>
<li><p>代码不会被执⾏，不可到达</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'false'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码执行的结果不会被用到</p>
<ul>
<li>执行函数返回结果，结果没有赋值给变量。</li>
<li>执行函数返回结果，结果赋值给变量。但是变量没有被使用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;func2&#125; <span class="keyword">from</span> <span class="string">'./functions'</span>;</span><br><span class="line">func2();</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码只会影响死变量（只写不读）</p>
<ul>
<li>定义了一个变量，修改了它的值，但是并没有使用。</li>
</ul>
</li>
</ul>
<h2 id="Tree-shaking-原理"><a href="#Tree-shaking-原理" class="headerlink" title="Tree-shaking 原理"></a>Tree-shaking 原理</h2><ul>
<li>利用 ES6 模块的特点:<ul>
<li>只能作为模块顶层的语句出现</li>
<li>import 的模块名只能是字符串常量，不能动态引入模块</li>
<li>import binding 是 immutable的，引入的模块不能再进行修改</li>
</ul>
</li>
<li>代码擦除： uglify 阶段删除无用代码</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用动态Polyfill服务</title>
    <url>/2019-10-17/webpack/%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81Polyfill%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="构建体积优化：动态-Polyfill"><a href="#构建体积优化：动态-Polyfill" class="headerlink" title="构建体积优化：动态 Polyfill"></a>构建体积优化：动态 Polyfill</h2><p><img src="/images/25.png" alt="构建体积优化：动态 Polyfill"></p><h2 id="Polyfill-Service原理"><a href="#Polyfill-Service原理" class="headerlink" title="Polyfill Service原理"></a>Polyfill Service原理</h2><ul>
<li><p>每次打开页面，浏览器都会向Polyfill Service发送请求，Polyfill Service识别 User Agent，下发不同的 Polyfill，做到按需加载Polyfill的效果。</p>
<p><img src="/images/28.png" alt="Polyfill Service原理"></p>
</li>
</ul><h2 id="构建体积优化：如何使用动态-Polyfill-service"><a href="#构建体积优化：如何使用动态-Polyfill-service" class="headerlink" title="构建体积优化：如何使用动态 Polyfill service"></a>构建体积优化：如何使用动态 Polyfill service</h2><a id="more"></a>

<ul>
<li><p><a href="https://polyfill.io/v3/" target="_blank" rel="noopener">polyfill.io</a> 官方提供的服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//访问url，根据User Agent 直接返回浏览器所需的 polyfills</span><br><span class="line">https://polyfill.io/v3/polyfill.min.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于官方自建 polyfill 服务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//huayang.qq.com/polyfill_service/v2/polyfill.min.js?unknown=polyfill&amp;features=Promise,Map,Set</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><a href="https://c7sky.com/polyfill-io.html" target="_blank" rel="noopener">其他</a></li>
</ul>
<h2 id="体积优化策略总结"><a href="#体积优化策略总结" class="headerlink" title="体积优化策略总结"></a>体积优化策略总结</h2><ul>
<li>Scope Hoisting</li>
<li>Tree-shaking</li>
<li>公共资源分离</li>
<li>图片压缩</li>
<li>动态 Polyfill</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用webpack进行图片压缩</title>
    <url>/2019-10-17/webpack/%E4%BD%BF%E7%94%A8webpack%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h2 id="使用webpack进行图片压缩"><a href="#使用webpack进行图片压缩" class="headerlink" title="使用webpack进行图片压缩"></a>使用webpack进行图片压缩</h2><ul>
<li>要求：基于 Node 库的 imagemin 或者 tinypng API</li>
<li>使用：配置 image-webpack-loader</li>
</ul><h2 id="Imagemin的优点分析"><a href="#Imagemin的优点分析" class="headerlink" title="Imagemin的优点分析"></a>Imagemin的优点分析</h2><ul>
<li>有很多定制选项</li>
<li>可以引入更多第三方优化插件，例如pngquant</li>
<li>可以处理多种图片格式</li>
</ul><h2 id="Imagemin的压缩原理"><a href="#Imagemin的压缩原理" class="headerlink" title="Imagemin的压缩原理"></a>Imagemin的压缩原理</h2><a id="more"></a>

<ul>
<li>pngquant: 是一款PNG压缩器，通过将图像转换为具有alpha通道（通常比24/32位PNG文件小60-80％）的更高效的8位PNG格式，可显著减小文件大小</li>
<li>pngcrush：其主要目的是通过尝试不同的压缩级别和PNG过滤方法来降低PNG IDAT数据流的大小。</li>
<li>optipng：其设计灵感来自于pngcrush。optipng可将图像文件重新压缩为更小尺寸，而不会丢失任何信息。</li>
<li>tinypng：也是将24位png文件转化为更小有索引的8位图片，同时所有非必要的metadata也会被剥离掉</li>
</ul>
<h2 id="image-webpack-loader"><a href="#image-webpack-loader" class="headerlink" title="image-webpack-loader"></a>image-webpack-loader</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在你的webpack.config.js中，在file-loader之后使用image-webpack-loader</span></span><br><span class="line"><span class="comment">//对于要配置的每个优化程序，请在选项中指定相应的键</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.(gif|png|jpe?g|svg)$/i</span>,</span><br><span class="line">            use: [</span><br><span class="line">                <span class="string">'file-loader'</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        mozjpeg: &#123;</span><br><span class="line">                            progressive: <span class="literal">true</span>,</span><br><span class="line">                            quality: <span class="number">65</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">// optipng.enabled: false will disable optipng</span></span><br><span class="line">                        optipng: &#123;</span><br><span class="line">                            enabled: <span class="literal">false</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        pngquant: &#123;</span><br><span class="line">                            quality: [<span class="number">0.65</span>, <span class="number">0.90</span>],</span><br><span class="line">                            speed: <span class="number">4</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        gifsicle: &#123;</span><br><span class="line">                            interlaced: <span class="literal">false</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">// the webp option will enable WEBP</span></span><br><span class="line">                        webp: &#123;</span><br><span class="line">                            quality: <span class="number">75</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Tree Shaking擦除无用的JavaScript和CSS</title>
    <url>/2019-10-17/webpack/%E4%BD%BF%E7%94%A8Tree-Shaking%E6%93%A6%E9%99%A4%E6%97%A0%E7%94%A8%E7%9A%84JavaScript%E5%92%8CCSS/</url>
    <content><![CDATA[<h2 id="tree-shaking-摇树优化"><a href="#tree-shaking-摇树优化" class="headerlink" title="tree shaking(摇树优化)"></a>tree shaking(摇树优化)</h2><ul>
<li>概念：1 个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到bundle 里面去，tree shaking 就是只把用到的方法打入 bundle ，没用到的方法会在uglify 阶段被擦除掉</li>
<li>使用：<ul>
<li>webpack 默认支持，在 .babelrc 里设置 modules: false 即可</li>
<li>production mode的情况下默认开启</li>
</ul>
</li>
<li>要求：<ul>
<li>必须是 ES6 的语法，CJS 的方式不支持</li>
<li>需要tree shaking的模块代码是没有副作用的，否则tree shaking会失效</li>
</ul>
</li>
<li><a href="/2019-10-17/webpack/Tree-Shaking的使用和原理分析">Tree Shaking的使用和原理分析</a></li>
</ul><a id="more"></a>
<h2 id="无用的-CSS-如何删除掉？"><a href="#无用的-CSS-如何删除掉？" class="headerlink" title="无用的 CSS 如何删除掉？"></a>无用的 CSS 如何删除掉？</h2><ul>
<li>PurifyCSS: 遍历代码，识别已经用到的 CSS class，没有用到的已经识别的就会做一个标记。</li>
<li>uncss: HTML 需要通过 jsdom 加载，所有的样式通过PostCSS解析，通过document.querySelector 来识别在 html 文件里面不存在的选择器</li>
</ul>
<h2 id="在-webpack-中如何使用-PurifyCSS"><a href="#在-webpack-中如何使用-PurifyCSS" class="headerlink" title="在 webpack 中如何使用 PurifyCSS?"></a>在 webpack 中如何使用 PurifyCSS?</h2><ul>
<li><p>purifycss-webpack以停止维护，建议使用purgecss-webpack-plugin</p>
</li>
<li><p>使用 <a href="https://github.com/FullHuman/purgecss-webpack-plugin" target="_blank" rel="noopener">purgecss-webpack-plugin</a>和 mini-css-extract-plugin 配合使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> PurgecssPlugin = <span class="built_in">require</span>(<span class="string">'purgecss-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要进行解析的文件目录 绝对路径</span></span><br><span class="line"><span class="keyword">const</span> PATHS = &#123;</span><br><span class="line">    src: path.join(__dirname, <span class="string">'src'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.join(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                styles: &#123;</span><br><span class="line">                    name: <span class="string">'styles'</span>,</span><br><span class="line">                    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                    chunks: <span class="string">'all'</span>,</span><br><span class="line">                    enforce: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    <span class="string">"css-loader"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">"[name].css"</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> PurgecssPlugin(&#123;</span><br><span class="line">            <span class="comment">//path：您可以使用文件数组指定purgecss应分析的内容。它可以是html，pug，blade，...文件。您可以使用glob或glob-all之类的模块轻松获取文件列表</span></span><br><span class="line">            paths: glob.sync(<span class="string">`<span class="subst">$&#123;PATHS.src&#125;</span>/**/*`</span>, &#123; <span class="attr">nodir</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>缩小构建目标</title>
    <url>/2019-10-17/webpack/%E7%BC%A9%E5%B0%8F%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h2 id="缩小构建目标"><a href="#缩小构建目标" class="headerlink" title="缩小构建目标"></a>缩小构建目标</h2><ul>
<li><p>目的：尽可能的少构建模块</p>
</li>
<li><p>比如 exclude 不解析相应的模块，目录。include 只解析解析相应的模块，目录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="comment">//?cacheDirectory=true 开启缓存</span></span><br><span class="line">            use: <span class="string">'babel-loader?cacheDirectory=true'</span>,<span class="comment">//使用babel-loader解析ES6  </span></span><br><span class="line">            exclude: <span class="string">'node_modules'</span>,</span><br><span class="line">            include: <span class="string">'src'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul><a id="more"></a>
<h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>resolve配置，设置模块如何被解析。通过resolve的配置，可以帮助Webpack快速查找依赖，也可以替换对应的依赖。<a href="https://webpack.js.org/configuration/resolve/" target="_blank" rel="noopener">了解更多</a></p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```json</span><br><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [&quot;.js&quot;,&quot;.jsx&quot;,&quot;.json&quot;,&quot;.css&quot;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 每当引入bootstrap模块的时候，它会直接引入bootstrap,而不需要从node_modules文件夹中按模块的查找规则查找</span><br><span class="line"></span><br><span class="line">  ```javascript</span><br><span class="line">  const bootstrap = path.resolve(__dirname, &apos;node_modules/_bootstrap@3.3.7@bootstrap/dist/css/bootstrap.css&apos;);</span><br><span class="line">  resolve: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">          &quot;bootstrap&quot;: bootstrap</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>resolve.modules：告诉 webpack 解析模块时应该搜索的目录</p>
</li>
<li><p>resolve.mainFields：当从 npm 包中导入模块时（例如，import * as D3 from ‘d3’），此选项将决定在 package.json 中使用哪个字段导入模块。根据 webpack 配置中指定的 target 不同，默认值也会有所不同</p>
</li>
<li><p>resolve.mainFiles：解析目录时要使用的文件名，默认是index</p>
</li>
</ul>
<h2 id="减少文件搜索范围"><a href="#减少文件搜索范围" class="headerlink" title="减少文件搜索范围"></a>减少文件搜索范围</h2><ul>
<li><p>优化 resolve.modules 配置（减少模块搜索层级）</p>
</li>
<li><p>优化 resolve.mainFields 配置（优化入口文件分析，搜索过程）</p>
</li>
<li><p>优化 resolve.extensions 配置（缩小扩展名查找范围）</p>
</li>
<li><p>合理使用 alias</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">        <span class="string">'react'</span>: path.resolve(__dirname, <span class="string">'./node_modules/react/umd/react.production.min.js'</span>),</span><br><span class="line">        <span class="string">'react-dom'</span>: path.resolve(__dirname, <span class="string">'./node_modules/react-dom/umd/react-dom.production.min.js'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="string">'.js'</span>],</span><br><span class="line">    mainFields: [<span class="string">'main'</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>充分利用缓存提升二次构建速度</title>
    <url>/2019-10-17/webpack/%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E7%BC%93%E5%AD%98%E6%8F%90%E5%8D%87%E4%BA%8C%E6%AC%A1%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li>目的：提升二次构建速度</li>
<li>缓存思路：<ul>
<li><a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">babel-loader</a> 开启缓存：提升二次解析速度</li>
<li><a href="https://github.com/webpack-contrib/terser-webpack-plugin" target="_blank" rel="noopener">terser-webpack-plugin</a> 开启缓存：提升二次压缩速度</li>
<li>使用 <a href="https://github.com/webpack-contrib/cache-loader" target="_blank" rel="noopener">cache-loader</a> 或者 <a href="https://github.com/mzgoddard/hard-source-webpack-plugin" target="_blank" rel="noopener">hard-source-webpack-plugin</a>：用于缓存 webpack 内部模块处理的中间结果，提升二次模块转换速度</li>
</ul>
</li>
</ul><a id="more"></a>
<p>如果开启了缓存，<strong><em>node_modules</em></strong> 文件加下，会有一个 <strong><em>.cache</em></strong> 文件夹目录。</p>
<h2 id="babel-loader-开启缓存"><a href="#babel-loader-开启缓存" class="headerlink" title="babel-loader 开启缓存"></a>babel-loader 开启缓存</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            <span class="comment">//?cacheDirectory=true 开启缓存</span></span><br><span class="line">            use: <span class="string">'babel-loader?cacheDirectory=true'</span><span class="comment">//使用babel-loader解析ES6  </span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="terser-webpack-plugin"><a href="#terser-webpack-plugin" class="headerlink" title="terser-webpack-plugin"></a>terser-webpack-plugin</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">        <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">            parallel: <span class="literal">true</span>,<span class="comment">//开启多进程并行压缩代码</span></span><br><span class="line">            cache: <span class="literal">true</span>,<span class="comment">//开启缓存</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="使用-cache-loader-或者-hard-source-webpack-plugin"><a href="#使用-cache-loader-或者-hard-source-webpack-plugin" class="headerlink" title="使用 cache-loader 或者 hard-source-webpack-plugin"></a>使用 cache-loader 或者 hard-source-webpack-plugin</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hard-source-webpack-plugin 开启缓存</span></span><br><span class="line"><span class="keyword">const</span> HardSourceWebpackPlugin = <span class="built_in">require</span>(<span class="string">'hard-source-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HardSourceWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>进一步分包：预编译资源模块 使用 DLLPlugin 进行分包</title>
    <url>/2019-10-17/webpack/%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%88%86%E5%8C%85%EF%BC%9A%E9%A2%84%E7%BC%96%E8%AF%91%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9D%97-%E4%BD%BF%E7%94%A8-DLLPlugin-%E8%BF%9B%E8%A1%8C%E5%88%86%E5%8C%85/</url>
    <content><![CDATA[<h2 id="分包：设置-Externals"><a href="#分包：设置-Externals" class="headerlink" title="分包：设置 Externals"></a>分包：设置 Externals</h2><ul>
<li>思路：将 react、react-dom 基础包通过 cdn 引入，不打入 bundle 中</li>
<li>方法：使用 html-webpack-externals-plugin</li>
</ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在配置文件中添加HtmlWebpackExternalsPlugin插件</span></span><br><span class="line"><span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">    externals: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">            entry: <span class="string">'https://cdn.bootcss.com/react/15.6.1/react.js'</span>,</span><br><span class="line">            global: <span class="string">'React'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">            entry: <span class="string">'https://cdn.bootcss.com/react/15.6.1/react-dom.js'</span>,</span><br><span class="line">            global: <span class="string">'ReactDOM'</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a>


<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>基础库分离 需要在html中引入基础库<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/react/15.6.1/react.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/react/15.6.1/react-dom.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="预编译资源模块-更好的分包策略"><a href="#预编译资源模块-更好的分包策略" class="headerlink" title="预编译资源模块 更好的分包策略"></a>预编译资源模块 更好的分包策略</h2><ul>
<li>思路：<ul>
<li>使用 <strong><em>webpack.dll..js</em></strong> 把所有的第三方库依赖，react、react-dom、redux、react-redux基础包和业务基础包打包到一个bundle的dll文件里面。</li>
<li>同时也会生成manifest.json文件。manifest.json文件是对分离出来的包的描述。该manifest.json的作用是用来让 DllReferencePlugin 映射到相关的依赖上去。</li>
</ul>
</li>
<li>方法：使用 DLLPlugin 进行分包，DllReferencePlugin引用 manifest.json 包。引用后，就会自动关联DLLPlugin中的包。</li>
<li>说明：<ul>
<li>DllPlugin 通常用于基础包（框架包、业务包）的分离。</li>
<li>SplitChunks 虽然也可以做 DllPlugin 的事情，但是更加推荐使用 SplitChunks 去提取页面间的公共 js 文件。因为使用 SplitChunks 每次去提取基础包还是需要耗费构建时间的，如果是 DllPlugin 只需要预编译一次，后面的基础包时间都可以省略掉。</li>
</ul>
</li>
<li><a href="https://www.webpackjs.com/plugins/dll-plugin/" target="_blank" rel="noopener">DLLPlugin详情</a></li>
</ul>
<h2 id="使用-DLLPlugin-进行分包"><a href="#使用-DLLPlugin-进行分包" class="headerlink" title="使用 DLLPlugin 进行分包"></a>使用 DLLPlugin 进行分包</h2><ul>
<li><p>在一个额外的独立的 webpack.dll.js 配置中，使用 DLLPlugin 进行分包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        <span class="comment">//指定需要进行分离的基础包 library：当前动态链接库的名称 [name] 代表当前动态链接库的名称</span></span><br><span class="line">        library: [</span><br><span class="line">            <span class="string">'react'</span>,</span><br><span class="line">            <span class="string">'react-dom'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].dll.js'</span>,<span class="comment">//输出的动态链接库(dll)的文件名称，[name] 代表当前动态链接库的名称</span></span><br><span class="line">        path: path.join(__dirname, <span class="string">'build/library'</span>),<span class="comment">// 输出的文件目录</span></span><br><span class="line">        library: <span class="string">'[name]'</span><span class="comment">//存放动态链接库的全局变量名称</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            name: <span class="string">'_dll_[name]'</span>,<span class="comment">//该字段的值也就是输出的 manifest.json 文件 中 name 字段的值 例如 library.manifest.json 中就有 "name": "_dll_library"</span></span><br><span class="line">            path: path.join(__dirname, <span class="string">'build/library/[name].manifest.json'</span>)<span class="comment">//</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用-DllReferencePlugin-引用-manifest-json"><a href="#使用-DllReferencePlugin-引用-manifest-json" class="headerlink" title="使用  DllReferencePlugin 引用 manifest.json"></a>使用  DllReferencePlugin 引用 manifest.json</h2><ul>
<li><p>在 webpack.config.js 引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DllReferencePlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/DllReferencePlugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">          context: path.join(__dirname, <span class="string">'build/library'</span>),<span class="comment">//(绝对路径) manifest (或者是内容属性)中请求的上下文 不设置会报错</span></span><br><span class="line">          manifest: <span class="built_in">require</span>(<span class="string">'./build/library/library.manifest.json'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程并行压缩代码</title>
    <url>/2019-10-17/webpack/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="多进程-多实例：并行压缩"><a href="#多进程-多实例：并行压缩" class="headerlink" title="多进程/多实例：并行压缩"></a>多进程/多实例：并行压缩</h2><ul>
<li>使用 <a href="https://github.com/gdborton/webpack-parallel-uglify-plugin" target="_blank" rel="noopener">parallel-uglify-plugin</a> 插件</li>
<li><a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">uglifyjs-webpack-plugin</a> 开启 parallel 参数</li>
<li><a href="https://github.com/webpack-contrib/terser-webpack-plugin" target="_blank" rel="noopener">terser-webpack-plugin</a> 开启 parallel 参数：<strong><em>推荐使用</em></strong></li>
</ul><h2 id="使用-parallel-uglify-plugin-插件"><a href="#使用-parallel-uglify-plugin-插件" class="headerlink" title="使用 parallel-uglify-plugin 插件"></a>使用 parallel-uglify-plugin 插件</h2><a id="more"></a>
<ul>
<li>在通过 new ParallelUglifyPlugin() 实列化时，支持以下参数配置：<ul>
<li>test: 使用正则去匹配哪些文件需要被 ParallelUglifyPlugin 压缩，默认是 /.js$/.</li>
<li>include: 使用正则去包含被 ParallelUglifyPlugin 压缩的文件，默认为 [].</li>
<li>exclude: 使用正则去不包含被 ParallelUglifyPlugin 压缩的文件，默认为 [].</li>
<li>cacheDir: 缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回，cacheDir 用于配置缓存存放的目录路径。默认不会缓存，想开启缓存请设置一个目录路径。</li>
<li>workerCount：开启几个子进程去并发的执行压缩。默认是当前运行电脑的 CPU 核数减去1。</li>
<li>sourceMap：是否为压缩后的代码生成对应的Source Map, 默认不生成，开启后耗时会大大增加，一般不会将压缩后的代码的</li>
<li>sourceMap发送给网站用户的浏览器。</li>
<li>uglifyJS：用于压缩 ES5 代码时的配置，Object 类型，直接透传给 UglifyJS 的参数。</li>
<li>uglifyES：用于压缩 ES6 代码时的配置，Object 类型，直接透传给 UglifyES 的参数。</li>
</ul>
</li>
</ul>
<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 ParallelUglifyPlugin 插件</span></span><br><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">'webpack-parallel-uglify-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 使用 ParallelUglifyPlugin 并行压缩输出JS代码</span></span><br><span class="line">        <span class="keyword">new</span> ParallelUglifyPlugin(&#123;</span><br><span class="line">            <span class="comment">// 传递给 UglifyJS的参数如下：</span></span><br><span class="line">            uglifyJS: &#123;</span><br><span class="line">                output: &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     是否输出可读性较强的代码，即会保留空格和制表符，默认为输出，为了达到更好的压缩效果，</span></span><br><span class="line"><span class="comment">                     可以设置为false</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    beautify: <span class="literal">false</span>,</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     是否保留代码中的注释，默认为保留，为了达到更好的压缩效果，可以设置为false</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    comments: <span class="literal">false</span></span><br><span class="line">                &#125;,</span><br><span class="line">                compress: &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     是否在UglifyJS删除没有用到的代码时输出警告信息，默认为输出，可以设置为false关闭这些作用</span></span><br><span class="line"><span class="comment">                     不大的警告</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    warnings: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     是否删除代码中所有的console语句，默认为不删除，开启后，会删除所有的console语句</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    drop_console: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     是否内嵌虽然已经定义了，但是只用到一次的变量，比如将 var x = 1; y = x, 转换成 y = 5, 默认为不</span></span><br><span class="line"><span class="comment">                     转换，为了达到更好的压缩效果，可以设置为false</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    collapse_vars: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     是否提取出现了多次但是没有定义成变量去引用的静态值，比如将 x = 'xxx'; y = 'xxx'  转换成</span></span><br><span class="line"><span class="comment">                     var a = 'xxxx'; x = a; y = a; 默认为不转换，为了达到更好的压缩效果，可以设置为false</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    reduce_vars: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="uglifyjs-webpack-plugin-开启-parallel-参数"><a href="#uglifyjs-webpack-plugin-开启-parallel-参数" class="headerlink" title="uglifyjs-webpack-plugin 开启 parallel 参数"></a>uglifyjs-webpack-plugin 开启 parallel 参数</h2><ul>
<li><p>不支持ES6语法</p>
</li>
<li><p>代码演示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">                parallel: <span class="literal">true</span>,<span class="comment">//开启多进程</span></span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="terser-webpack-plugin-开启-parallel-参数"><a href="#terser-webpack-plugin-开启-parallel-参数" class="headerlink" title="terser-webpack-plugin 开启 parallel 参数"></a>terser-webpack-plugin 开启 parallel 参数</h2><ul>
<li><p>代码演示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">                parallel: <span class="literal">true</span>,</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程/多实例构建</title>
    <url>/2019-10-17/webpack/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="资源并行解析可选方案"><a href="#资源并行解析可选方案" class="headerlink" title="资源并行解析可选方案"></a>资源并行解析可选方案</h2><ul>
<li><a href="https://github.com/amireh/happypack" target="_blank" rel="noopener">HappyPack</a></li>
<li><a href="https://github.com/webpack-contrib/thread-loader" target="_blank" rel="noopener">thread-loader</a>：推荐使用</li>
<li><a href="https://github.com/trivago/parallel-webpack" target="_blank" rel="noopener">parallel-webpack</a></li>
</ul><h2 id="多进程-多实例：使用-HappyPack-解析资源"><a href="#多进程-多实例：使用-HappyPack-解析资源" class="headerlink" title="多进程/多实例：使用 HappyPack 解析资源"></a>多进程/多实例：使用 HappyPack 解析资源</h2><ul>
<li><p>原理：</p>
<ul>
<li>每次 webapck 解析一个模块，HappyPack 会将它及它的依赖分配给 worker 线程中</li>
</ul>
</li>
<li><p>代码演示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.plugins = [</span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'jsx'</span>,</span><br><span class="line">    threads: <span class="number">4</span>,</span><br><span class="line">    loaders: [ <span class="string">'babel-loader'</span> ]</span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'styles'</span>,</span><br><span class="line">    threads: <span class="number">2</span>,</span><br><span class="line">    loaders: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span> ]</span><br><span class="line">  &#125;)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">exports.module.rules = [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use: <span class="string">'happypack/loader?id=jsx'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: <span class="string">'happypack/loader?id=styles'</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>工作流程：webpack compiler run方法执行后，到达HappyPack。HappyPack会做一些初始化，初始化工作之后，会创建一个线程池。线程池可能包括多个线程。线程池会将构建任务里面的模块进行分配。线程池里面的线程会去各自处理模块以及相关依赖，处理完成之后，会有一个通信的过程。会将处理好的资源传输给HappyPack的主进程。完成整个构建的过程。</p>
<p><img src="/images/26.png" alt="工作流程"></p>
</li>
<li><p><a href="https://github.com/amireh/happypack" target="_blank" rel="noopener">了解更多</a></p>
</li>
</ul><a id="more"></a>

<h2 id="多进程-多实例：使用-thread-loader-解析资源"><a href="#多进程-多实例：使用-thread-loader-解析资源" class="headerlink" title="多进程/多实例：使用 thread-loader 解析资源"></a>多进程/多实例：使用 thread-loader 解析资源</h2><ul>
<li><p>原理：</p>
<ul>
<li>每次 webpack 解析一个模块，thread-loader 会将它及它的依赖分配给 worker 线程中</li>
<li>把这个 loader 放置在其他 loader 之前， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行</li>
</ul>
</li>
<li><p>在 worker 池(worker pool)中运行的 loader 是受到限制的。例如：</p>
<ul>
<li>这些 loader 不能产生新的文件。</li>
<li>这些 loader 不能使用定制的 loader API（也就是说，通过插件）。</li>
<li>这些 loader 无法获取 webpack 的选项设置。</li>
</ul>
</li>
<li><p>每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。</p>
</li>
<li><p>请仅在耗时的 loader 上使用</p>
</li>
<li><p>代码演示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        include: path.resolve(<span class="string">"src"</span>),</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">"thread-loader"</span>,</span><br><span class="line">          <span class="comment">// your expensive loader (e.g babel-loader)</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.webpackjs.com/loaders/thread-loader/" target="_blank" rel="noopener">了解更多</a></p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用高版本的webpack和Node.js</title>
    <url>/2019-10-17/webpack/%E4%BD%BF%E7%94%A8%E9%AB%98%E7%89%88%E6%9C%AC%E7%9A%84webpack%E5%92%8CNode-js/</url>
    <content><![CDATA[<h2 id="使用高版本的webpack和Node-js"><a href="#使用高版本的webpack和Node-js" class="headerlink" title="使用高版本的webpack和Node.js"></a>使用高版本的webpack和Node.js</h2><ul>
<li>V8 带来的优化（for of 替代 forEach、Map 和 Set 替代 Object、includes 替代 indexOf）</li>
<li>默认使用更快的 md4 hash 算法，替代md5 hash</li>
<li>webpacks AST 可以直接从 loader 传递给 AST，减少解析时间</li>
<li>使用字符串方法替代正则表达式</li>
<li>可以从webpack<a href="https://github.com/webpack/webpack/releases" target="_blank" rel="noopener">版本日志</a>，了解做了哪些性能优化</li>
</ul><a id="more"></a>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>体积分析：使用webpack-bundle-analyzer</title>
    <url>/2019-10-17/webpack/%E4%BD%93%E7%A7%AF%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%BF%E7%94%A8webpack-bundle-analyzer/</url>
    <content><![CDATA[<h2 id="体积分析：使用webpack-bundle-analyzer"><a href="#体积分析：使用webpack-bundle-analyzer" class="headerlink" title="体积分析：使用webpack-bundle-analyzer"></a>体积分析：使用webpack-bundle-analyzer</h2><ul>
<li><p>代码示例：构建完成后会在 8888 端口展示大小</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">了解更多</a></p>
</li>
</ul><a id="more"></a>
<h2 id="可以分析哪些问题？"><a href="#可以分析哪些问题？" class="headerlink" title="可以分析哪些问题？"></a>可以分析哪些问题？</h2><ul>
<li>依赖的第三方模块文件大小</li>
<li>业务里面的组件代码大小</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>速度分析：使用speed-measure-webpack-plugin</title>
    <url>/2019-10-17/webpack/%E9%80%9F%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%BF%E7%94%A8speed-measure-webpack-plugin/</url>
    <content><![CDATA[<h2 id="速度分析：使用speed-measure-webpack-plugin"><a href="#速度分析：使用speed-measure-webpack-plugin" class="headerlink" title="速度分析：使用speed-measure-webpack-plugin"></a>速度分析：使用speed-measure-webpack-plugin</h2><ul>
<li><p>使用：将默认配置文件包裹起来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SpeedMeasurePlugin = <span class="built_in">require</span>(<span class="string">"speed-measure-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasurePlugin();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将默认的webpack配置文件包裹起来</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MyPlugin(),</span><br><span class="line">    <span class="keyword">new</span> MyOtherPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://github.com/stephencookdev/speed-measure-webpack-plugin" target="_blank" rel="noopener">了解更多</a></p>
</li>
</ul><a id="more"></a>
<h2 id="速度分析插件作用"><a href="#速度分析插件作用" class="headerlink" title="速度分析插件作用"></a>速度分析插件作用</h2><ul>
<li>分析整个打包总耗时</li>
<li>每个插件和loader的耗时情况</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>初级分析：使用webpack内置的stats</title>
    <url>/2019-10-17/webpack/%E5%88%9D%E7%BA%A7%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%BF%E7%94%A8webpack%E5%86%85%E7%BD%AE%E7%9A%84stats/</url>
    <content><![CDATA[<h2 id="使用webpack内置的stats"><a href="#使用webpack内置的stats" class="headerlink" title="使用webpack内置的stats"></a>使用webpack内置的stats</h2><ul>
<li>stats: 构建的统计信息</li>
</ul><h2 id="package-json-中使用-stats"><a href="#package-json-中使用-stats" class="headerlink" title="package.json 中使用 stats"></a>package.json 中使用 stats</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build:stats&quot;: &quot;webpack --config webpack.prod.js --json &gt; stats.json&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><a id="more"></a>
  

<h2 id="Node-js-中使用"><a href="#Node-js-中使用" class="headerlink" title="Node.js 中使用"></a>Node.js 中使用</h2><p><img src="/images/23.png" alt="Node.js 中使用"></p>
<h2 id="上面的方法存在的问题"><a href="#上面的方法存在的问题" class="headerlink" title="上面的方法存在的问题"></a>上面的方法存在的问题</h2><p><img src="/images/24.png" alt="存在的问题"></p>
<ul>
<li>颗粒度太粗, 看不出问题所在</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://time.geekbang.org/course/intro/190" target="_blank" rel="noopener">玩转webpack-全方位掌握webpack核心技能和优化策略</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 性能优化</title>
    <url>/2019-10-17/webpack/Webpack-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="webpack-的性能瓶颈"><a href="#webpack-的性能瓶颈" class="headerlink" title="webpack 的性能瓶颈"></a>webpack 的性能瓶颈</h2><p>webpack 的优化瓶颈，主要是两个方面：</p>
<ul>
<li>webpack 的构建过程太花时间</li>
<li>webpack 打包的结果体积太大</li>
</ul>
<h2 id="webpack构建速度和体积优化策略"><a href="#webpack构建速度和体积优化策略" class="headerlink" title="webpack构建速度和体积优化策略"></a>webpack构建速度和体积优化策略</h2><ul>
<li><a href="/2019-10-17/webpack/初级分析：使用webpack内置的stats">01 | 初级分析：使用webpack内置的stats</a></li>
<li><a href="/2019-10-17/webpack/速度分析：使用speed-measure-webpack-plugin">02 | 速度分析：使用speed-measure-webpack-plugin</a></li>
<li><a href="/2019-10-17/webpack/体积分析：使用webpack-bundle-analyzer">03 | 体积分析：使用webpack-bundle-analyzer</a></li>
<li><a href="/2019-10-17/webpack/使用高版本的webpack和Node-js">04 | 使用高版本的webpack和Node.js</a></li>
<li><a href="/2019-10-17/webpack/多进程-多实例构建">05 | 多进程/多实例构建</a></li>
<li><a href="/2019-10-17/webpack/多进程并行压缩代码">06 | 多进程并行压缩代码</a></li>
<li><a href="/2019-10-17/webpack/进一步分包：预编译资源模块-使用-DLLPlugin-进行分包">07 | 进一步分包：预编译资源模块 使用 DLLPlugin 进行分包</a></li>
<li><a href="/2019-10-17/webpack/充分利用缓存提升二次构建速度">08 | 充分利用缓存提升二次构建速度</a></li>
<li><a href="/2019-10-17/webpack/缩小构建目标">09 | 缩小构建目标</a></li>
<li><a href="/2019-10-17/webpack/使用Tree-Shaking擦除无用的JavaScript和CSS">10 | 使用Tree Shaking擦除无用的JavaScript和CSS</a></li>
<li><a href="/2019-10-17/webpack/使用webpack进行图片压缩">11 | 使用webpack进行图片压缩</a></li>
<li><a href="/2019-10-17/webpack/使用动态Polyfill服务">12 | 使用动态Polyfill服务</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Webpack</category>
        <category>webpack构建速度和体积优化策略</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS Prefetch</title>
    <url>/2019-10-17/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/DNS-Prefetch/</url>
    <content><![CDATA[<p><strong><em>DNS(Domain Name System)</em></strong>，翻译为域名解析系统，是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p><p>围绕DNS可做的性能优化非常的多，比如大家所熟知的全局负载均衡(GSLB)，用户可以访问到离自己最近服务器，从而获得最优的访问体验，这项优化更多需要服务端去完成。前端主要关注 <strong><em>DNS Prefetch</em></strong>。</p><a id="more"></a>

<h2 id="DNS-Prefetch原理"><a href="#DNS-Prefetch原理" class="headerlink" title="DNS Prefetch原理"></a>DNS Prefetch原理</h2><p>当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址。</p>
<p>DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度。</p>
<p>如果页面之前访问了，我们可以从浏览器的DNS缓存当中直接读取。减少了解析时间，以及请求次数。</p>
<p>打开DNS Prefetch之后，浏览器会在空闲时间提前将这些域名转化为对应的IP地址，这里为了防止DNS Prefetch阻塞页面渲染影响用户体验，Chrome浏览器的引擎并没有使用它的网络堆栈去进行预解析，而是单独开了8个完全异步的Worker线程专门负责DNS Prefetch。所以很多人认为的DNS Prefetch会影响首屏加载其实是错误的，两者并没有任何关系，所以我们可以大胆放心的使用DNS Prefetch。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="浏览器自动解析"><a href="#浏览器自动解析" class="headerlink" title="浏览器自动解析"></a>浏览器自动解析</h3><p>浏览器引擎在解析HTML页面的时候，会自动获取当前页面所有的a标签herf属性当中的域名，然后进行 <strong><em>DNS Prefetch</em></strong>。这个解析过程是与用户浏览网页并行处理的。但是为了确保安全性，在HTTPS页面中没有开启 <strong><em>DNS Prefetch</em></strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 开启DNS Prefetch</span><br><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</span><br><span class="line"></span><br><span class="line">// 关闭DNS Prefetch</span><br><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="手动解析"><a href="#手动解析" class="headerlink" title="手动解析"></a>手动解析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//jkfhto.github.io&quot;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DNS Prefetch解析后的域名对应关系会缓存到本地，一般本地缓存的数量为50~200个</span><br></pre></td></tr></table></figure>

<h2 id="正确的使用姿势"><a href="#正确的使用姿势" class="headerlink" title="正确的使用姿势"></a>正确的使用姿势</h2><ul>
<li>在整个站点的入口声明DNS预解析。通过在站点入口声明了后续其他子页面和子站点可能会访问的域名，浏览器提前进行了DNS预解析。这样用户在访问其他子站点的时候将会间接受益于入口的预解析，降低了DNS lookup所消耗的时间。</li>
<li>根据实际情况配置当前页面的DNS预解析。声明后续操作可能会用到的域名，如发送的异步请求、动态加载图片等等。</li>
<li>并不是DNS prefetch设置的越多越好，虽然是异步线程，实际上还是占用设备的带宽，造成资源竞争。</li>
<li>借助开发者工具，对静态资源域名做手动dns prefetching。</li>
<li>如果是HTTPS网页，考虑是否需要对超链接自动解析，如果需要，添加对应的meta标签。</li>
<li>检查js中发起的跳转至其他域名的情况，对于这些域名，做手动dns prefetching。</li>
<li>对重定向跳转的新域名做手动dns prefetching。比如：页面上有个A域名的链接，但访问A会重定向到B域名的链接，这么在当前页对B域名做手动dns prefetching是有意义的。</li>
</ul>
<h2 id="解决的问题及收益"><a href="#解决的问题及收益" class="headerlink" title="解决的问题及收益"></a>解决的问题及收益</h2><p>DNS Prefetch有效缩短了DNS的解析时间。</p>
<p>如果浏览器最近将一个域名解析为IP地址，所属的操作系统将会缓存，下一次DNS解析时间可以低至0-1ms。 如果结果不在系统本地缓存，则需要读取路由器的缓存，则解析时间的最小值大约为15ms。如果路由器缓存也不存在，则需要读取ISP（运营商）DNS缓存，一般像taobao.com、baidu.com这些常见的域名，读取ISP（运营商）DNS缓存需要的时间在80-120ms，如果是不常见的域名，平均需要200-300ms。一般的网站在运营商这里都能查询的到，所以普遍来说DNS Prefetch可以给一个域名的DNS解析过程带来15-300ms的提升，尤其是一些大量引用很多其他域名资源的网站，提升效果就更加明显了。<br>Chromium对底层缓存进行了建模，当Chrome浏览器启动的时候，就会自动的快速解析浏览器最近一次启动时记录的前10个域名。所以你经常访问的网址就没有DNS解析的延迟，打开速度更快。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://github.com/barretlee/performance-column/issues/3" target="_blank" rel="noopener">性能优化之 DNS Prefetch</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化工具-LightHouse</title>
    <url>/2019-10-17/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7-LightHouse/</url>
    <content><![CDATA[<p>Performance可以给我们提供非常多的信息，但Performance不够直观，需要开发者透过表面的这些参数去分析背后的性能问题。有了这个诉求之后，另一个性能优化工具就出现了，它就是LightHouse。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LightHouse 是 Google 开源的一个自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 当为 Lighthouse 提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。可以参考失败的测试，看看可以采取哪些措施来改进应用。</p><a id="more"></a>

<h2 id="三种使用方式"><a href="#三种使用方式" class="headerlink" title="三种使用方式"></a>三种使用方式</h2><p>可以到谷歌应用商店安装LightHouse，点击添加至Chrome即可。</p>
<p>如果浏览器版本较新的话，可以直接打开 Chrome 开发者工具 (F12)，然后打开 Audits 面板即可。Audits面板集成了 LightHouse 功能，我们可以根据自己的需要，选择对应的限制条件，运行 Run audits，如下图：</p>
<p><img src="/images/LightHouse1.png" alt="LightHouse1"></p>
<p>作为命令行工具运行，命令行工具允许您将 <a href="https://github.com/GoogleChrome/lighthouse" target="_blank" rel="noopener">Lighthouse</a> 集成到持续集成系统。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局安装 lighthouse</span></span><br><span class="line">npm install -g lighthouse</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后输入你的页面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行支持导出HTML格式和JSON格式，我们使用如下命令分别导出：</span></span><br><span class="line"><span class="comment">//导出JSON格式</span></span><br><span class="line">lighthouse https:<span class="comment">//www.imooc.com/  --output json  </span></span><br><span class="line"><span class="comment">//导出HTML格式</span></span><br><span class="line">lighthouse https:<span class="comment">//www.imooc.com/  --output html</span></span><br></pre></td></tr></table></figure>

<h2 id="自动化部分"><a href="#自动化部分" class="headerlink" title="自动化部分"></a>自动化部分</h2><p>可以利用 TravisCI 来自动分析修改后的代码的页面性能。</p>
<p>你只需要在 .travis.yml 里面加入以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">script:</span><br><span class="line">  - npm run lint</span><br><span class="line">  - npm run build</span><br><span class="line">after_success:</span><br><span class="line">  - .<span class="string">"./travis/deploy_pr_gae.sh"</span></span><br><span class="line">  - <span class="keyword">export</span> LH_MIN_PASS_SCORE=<span class="number">96</span></span><br><span class="line">  - <span class="keyword">export</span> LH_TEST_URL=https:<span class="comment">//your.staging.server.com/</span></span><br><span class="line">  - node travis/runlighthouse.js $LH_TEST_URL $LH_MIN_PASS_SCORE</span><br></pre></td></tr></table></figure>

<p>更多详情: <a href="https://github.com/GoogleChromeLabs/lighthousebot" target="_blank" rel="noopener">ebidel/lighthouse-ci</a></p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>以本站为例，使用 <strong><em>chrome lighthouse</em></strong>生成性能优化测试的报告，直接点击Generate report，然后LightHouse就会自动帮我们生成性能优化报告，如下图：</p>
<p><img src="/images/LightHouse2.png" alt="LightHouse2"></p>
<p>性能优化测试的报告主要包括，Performance(页面性能)、Accessibility(可访性)、Best Practise(最佳实践)、SEO(搜索引擎优化)、Progressive Web App(渐进式应用)。我们点击其中的每一项都可以看到给出的具体优化建议，这里我们以Performance为例，如下图：</p>
<p><img src="/images/LightHouse3.png" alt="LightHouse3"></p>
<p>以第一项为例，点击展开可看到更加详细的信息，如下图：</p>
<p><img src="/images/LightHouse4.png" alt="LightHouse4"></p>
<p>这里推荐我们使用下一代图片格式化的技术，原因是JPEG 2000、JPEG XR和WebP等图像格式通常比PNG或JPEG提供更好的压缩，这意味着更快的下载速度和更少的数据消耗。下面还展示了需要替换的图片资源。点击 <strong><em>Learn more</em></strong>，可以跳转到指定的帮助文档。</p>
<h2 id="相关的性能优化工具"><a href="#相关的性能优化工具" class="headerlink" title="相关的性能优化工具"></a>相关的性能优化工具</h2><ul>
<li><strong><a href="https://github.com/treosh/exthouse" target="_blank" rel="noopener">Exthouse</a></strong> - Analyze the impact of a browser extension on web performance.</li>
<li><strong><a href="https://github.com/boyney123/garie" target="_blank" rel="noopener">Garie</a></strong> - An open source tool for monitoring performance using Lighthouse,  PageSpeed Insights, <a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a>, <a href="https://grafana.com/" target="_blank" rel="noopener">Grafana</a> and <a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a>.</li>
<li><strong><a href="https://labs.moduscreate.com/gimbal-web-performance-audit-budgeting" target="_blank" rel="noopener">Gimbal</a></strong> - An <a href="https://github.com/ModusCreateOrg/gimbal" target="_blank" rel="noopener">open source (MIT licensed)</a> tool used to measure, analyze, and budget aspects of a web application. Gimbal also integrates reports with GitHub pull requests.</li>
<li><strong><a href="https://github.com/Cognifide/gradle-lighthouse-plugin" target="_blank" rel="noopener">Gradle Lighthouse Plugin</a></strong> - An open source Gradle plugin that runs Lighthouse tests on multiple URLs and asserts category score thresholds (useful in continuous integration).</li>
<li><strong><a href="https://github.com/github/lightcrawler" target="_blank" rel="noopener">lightcrawler</a></strong> - Crawl a website and run each page found through Lighthouse.</li>
<li><strong><a href="https://github.com/emazzotta/lighthouse-badges" target="_blank" rel="noopener">lighthouse-badges</a></strong> - Generate gh-badges (shields.io) based on Lighthouse performance.</li>
<li><strong><a href="https://www.npmjs.com/package/lighthouse-batch" target="_blank" rel="noopener">lighthouse-batch</a></strong> - Run Lighthouse over a number of sites and generate a summary of their metrics/scores.</li>
<li><strong><a href="https://github.com/foo-software/lighthouse-check-action" target="_blank" rel="noopener">lighthouse-check-action</a></strong> - A Github Action to run Lighthouse in a workflow, featuring Slack notifications and report upload to S3.</li>
<li><strong><a href="https://circleci.com/orbs/registry/orb/foo-software/lighthouse-check" target="_blank" rel="noopener">lighthouse-check-orb</a></strong> - A CircleCI Orb to run Lighthouse in a workflow, featuring Slack notifications and report upload to S3.</li>
<li><strong><a href="https://github.com/andreasonny83/lighthouse-ci" target="_blank" rel="noopener">lighthouse-ci</a></strong> - Run Lighthouse and assert scores satisfy your custom thresholds.</li>
<li><strong><a href="https://github.com/treosh/lighthouse-ci-action" target="_blank" rel="noopener">lighthouse-ci-action</a></strong> - A Github Action that makes it easy to run Lighthouse in CI and keep your pages small using performance budgets.</li>
<li><strong><a href="https://github.com/thearegee/lighthouse-cron" target="_blank" rel="noopener">lighthouse-cron</a></strong> - Cron multiple batch Lighthouse audits and emit results for sending to remote server.</li>
<li><strong><a href="https://github.com/carlesnunez/lighthouse-gh-reporter" target="_blank" rel="noopener">lighthouse-gh-reporter</a></strong> - Run Lighthouse in CI and report back in a comment on your pull requests</li>
<li><strong><a href="https://github.com/ebidel/lighthouse-hue" target="_blank" rel="noopener">lighthouse-hue</a></strong> - Set the color of Philips Hue lights based on a Lighthouse score</li>
<li><strong><a href="https://github.com/justinribeiro/lighthouse-jest-example" target="_blank" rel="noopener">lighthouse-jest-example</a></strong> - Gather performance metrics via Lighthouse and assert results with Jest; uses Puppeteer to start Chrome with network emulation settings defined by WebPageTest.</li>
<li><strong><a href="https://github.com/joytocode/lighthouse-lambda" target="_blank" rel="noopener">lighthouse-lambda</a></strong> - Run Lighthouse on AWS Lambda with prebuilt stable desktop Headless Chrome.</li>
<li><strong><a href="https://github.com/manekinekko/lighthouse-magic-light" target="_blank" rel="noopener">lighthouse-magic-light</a></strong> - Set the color of the MagicLight Bluetooth Smart Light Bulb based on Lighthouse score</li>
<li><strong><a href="https://github.com/rishichawda/lighthouse-mocha-example" target="_blank" rel="noopener">lighthouse-mocha-example</a></strong> - Run Lighthouse performance tests with Mocha and chrome-launcher.</li>
<li><strong><a href="https://github.com/verivox/lighthouse-monitor" target="_blank" rel="noopener">lighthouse-monitor</a></strong> - Run Lighthouse against all your URLs. Send metrics to any backend you want, save all reports with automatic data retention, and compare any two results in a web UI.</li>
<li><strong><a href="https://github.com/foo-software/lighthouse-persist" target="_blank" rel="noopener">lighthouse-persist</a></strong> - Run Lighthouse and upload HTML reports to an AWS S3 bucket.</li>
<li><strong><a href="https://github.com/godaddy/lighthouse4u" target="_blank" rel="noopener">lighthouse4u</a></strong> - LH4U provides Google Lighthouse as a service, surfaced by both a friendly UI+API, and backed by Elastic Search for easy querying and visualization.</li>
<li><strong><a href="https://performance-budgets.netlify.com/" target="_blank" rel="noopener">performance-budgets</a></strong> - Easily assert Lighthouse budgets with Docker.</li>
<li><strong><a href="https://github.com/paulirish/pwmetrics/" target="_blank" rel="noopener">pwmetrics</a></strong> - Gather performance metrics</li>
<li><strong><a href="https://www.npmjs.com/package/react-lighthouse-viewer" target="_blank" rel="noopener">react-lighthouse-viewer</a></strong> - Render a Lighthouse JSON report in a React Component.</li>
<li><strong><a href="https://github.com/addyosmani/webpack-lighthouse-plugin" target="_blank" rel="noopener">webpack-lighthouse-plugin</a></strong> - Run Lighthouse from a Webpack build.</li>
</ul>
<p><a href="https://github.com/GoogleChrome/lighthouse" target="_blank" rel="noopener">了解更多</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://juejin.im/post/5ba73d1de51d450e551a0d08" target="_blank" rel="noopener">网站性能调优开发工具: Lighthouse, Puppeteer 以及进阶部分丨 Google 开发者大会 2018</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化工具-浏览器performance面板</title>
    <url>/2019-10-16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7-%E6%B5%8F%E8%A7%88%E5%99%A8performance%E9%9D%A2%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.首先我们需要打开新的无痕窗口，进入隐身模式，可以保证Chrome在一个相对干净的环境下运行。这里是为了避免相关的浏览器插件带来的干扰，这些插件可能会影响我们分析性能表现。使用快捷键 <strong><em>ctrl + shift + N</em></strong> 即可打开chrome新的无痕窗口</p><p><img src="/images/performance%E9%9D%A2%E6%9D%BF1.jpg" alt="performance面板1"></p><p>2.按F12进入开发者工具，打开performance面板。</p><a id="more"></a>


<p>3.点击最左侧的黑色圆就可以开始一个新的监测记录，也可以点击刷新按钮记录整个刷新过程中的监测记录。然后右侧我们如果勾选了Screenshots，就可以记录整个监测过程中每一帧的截图。如果勾选了Memory，我们就可以看到内存的详细使用情况以及垃圾回收的周期，也可以观察到内存有无泄漏的情况。</p>
<p>4.点击最右侧的小齿轮，可以看到一些配置项，打开CPU的节流开关，可以模拟移动端项目。打开Network的节流开关，我们模拟弱网(2g/3g)条件下网站的一些表现情况，然后根据弱网的具体表现进行相关优化。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>我们打开performance面板之后，然后点击刷新按钮，就可以看到页面加载过程中的性能表现：</p>
<p><img src="/images/performance%E9%9D%A2%E6%9D%BF2.png" alt="performance面板2"></p>
<p>其从上到下是：</p>
<ul>
<li>工具栏</li>
<li>FPS图表</li>
<li>CPU图表</li>
<li>NET图表</li>
<li>HEAP图标</li>
<li>Network图表</li>
<li>Frames图表</li>
<li>Timings</li>
<li>Main图表</li>
<li>Raster图表</li>
<li>GPU图表</li>
<li>Summary面板</li>
<li>等…</li>
</ul>
<h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p>开始记录，停止记录和配置记录期间捕获的信息。</p>
<p><img src="/images/performance%E9%9D%A2%E6%9D%BF4.png" alt="performance面板4"></p>
<h3 id="FPS，CPU，NET，HEAP"><a href="#FPS，CPU，NET，HEAP" class="headerlink" title="FPS，CPU，NET，HEAP"></a>FPS，CPU，NET，HEAP</h3><p><img src="/images/performance%E9%9D%A2%E6%9D%BF3.png" alt="performance面板3"></p>
<ul>
<li><p>FPS：这个指标是衡量动画是否流畅的一个重要指标。图中的绿色柱状图很高，这就代表FPS帧率很高，体验也就越流畅，如果FPS帧率较低，那么图中则会是红色的横条，表明帧率较低，影响用户体验。当帧率不影响使用的时候横条是不会出现的。</p>
</li>
<li><p>CPU：CPU自然就是展示CPU的使用情况。这个指标和下面的Sumarry指标是一一对应，而且这里它们的颜色所代表含义也是相同的，每个颜色代表各个过程所耗费的时间。从图中我们可以看到，整个加载过程中，白色部分(ldle)占比是最大的，这里代表的是空闲性能，第二大占比的橙色对应的是脚本加载时间，我们可以试着从加快脚本加载速度方面去优化页面。</p>
</li>
<li><p>NET：这个是展示各个请求所花费的具体时间，这里看不太清，我们可以直接去 Network 面板当中去具体观察各个请求所花费的时间，然后针对具体的请求具体分析。</p>
</li>
<li><p>HEAP：这里展示的是请求过程中内存的使用情况，这个指标对性能优化帮助不大。</p>
<p>左右移动鼠标，就可以看到各个时间点的截图，这在分析动画执行的各个阶段，以及了loading的各个阶段的时候尤其有用.</p>
</li>
</ul>
<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><p><img src="/images/performance%E9%9D%A2%E6%9D%BF5.png" alt="performance面板5"></p>
<p>代表主线程， 一段横条代表执行一个事件(函数)，长度越长，花费的时间越多; 竖向代表调用栈。在栈里，上面的事件调用了下面的事件。如果在这些横条中右上角是红色的，就表示在该段代码执行过程中可能存在性能问题。</p>
<p>图中各种颜色的矩形代表加载过程中做的所有工作。调用堆栈就像是浏览器当中的解释器，我们可以利用它追踪函数的执行流。当浏览器中调用了多个函数，通过这种机制可以追踪到哪个函数正在执行，具体函数体中又调用了哪个函数。这里我们点击一个右上角是红色的矩形，如下图：</p>
<p><img src="/images/performance%E9%9D%A2%E6%9D%BF6.jpg" alt="performance面板6"></p>
<p>点击之后我们看到了这个事件下对应的一些具体信息，这里我们还可以点击Range右侧链接，点击之后会直接跳到sources面板对应的代码位置，这个功能可以说大大方便了我们定位具体的代码，根据定位到的代码段，阅读代码我们可以分析，优化性能。如下图：</p>
<p><img src="/images/performance%E9%9D%A2%E6%9D%BF7.jpg" alt="performance面板7"></p>
<h3 id="Summary面板"><a href="#Summary面板" class="headerlink" title="Summary面板"></a>Summary面板</h3><p>HTML 文件为蓝色。<br>脚本为黄色。<br>样式表为紫色。<br>媒体文件为绿色。<br>其他资源为灰色。</p>
<h3 id="Bottom-Up"><a href="#Bottom-Up" class="headerlink" title="Bottom-Up"></a>Bottom-Up</h3><p>代表调用堆栈的前后调用关系，展示浏览器执行的各个操作所占用的时间</p>
<ul>
<li>self-time 指除去子操作这个操作本身消耗的时间</li>
<li>total-time 这个操作从开始到结束消耗的时间（包含子事件）</li>
</ul>
<h3 id="Call-Tree"><a href="#Call-Tree" class="headerlink" title="Call Tree"></a>Call Tree</h3><p>调用树。Call Tree与Main中的事件一一对应。可以看到整个事件的调用栈（从最顶层到最底层）</p>
<h3 id="Event-Log"><a href="#Event-Log" class="headerlink" title="Event Log"></a>Event Log</h3><p>事件日志</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" target="_blank" rel="noopener">Get Started With Analyzing Runtime Performance</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化衡量指标</title>
    <url>/2019-10-16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h2 id="Performance-API"><a href="#Performance-API" class="headerlink" title="Performance API"></a>Performance API</h2><p>这个 API 是 HTML5 新增的特性。过去我们要统计脚本的运行时间，会使用 Date.getTime() 去获取对应的时间；如果要获取白屏时间是在 head 末尾插入一段获取时间戳的代码，然后用这个时间戳减去开始接收数据的那个时间戳，得出的结果为白屏时间。这样的方法无疑是笨重的，而且获取的时间无法更精确(只能到ms级别)，而且一些后台比较关注的时间根本无法获取。W3C 为了解决这个问题，在 HTML5 推出的时候，新增了这个 API 。</p><a id="more"></a>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">Performance</a> 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API" target="_blank" rel="noopener">Navigation Timing API</a>、 <a href="https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API" target="_blank" rel="noopener">User Timing API</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API" target="_blank" rel="noopener">Resource Timing API</a>。该类型的对象可以通过调用只读属性 Window.performance 来获得。</p>
<p>在控制台输入window.performance，能够获取到相关信息，如下图：</p>
<p><img src="/images/Performance1.png" alt="Performance1"></p>
<p><strong><em>performance</em></strong> 包括了五个属性，其中 <strong><em>timing</em></strong> 是我们需要重点关注的，<strong><em>timing</em></strong> 是一个对象，其中key值是性能优化指标，value值是对应的时间戳。其中这些时间戳与页面整个加载过程中的关键节点是有着一一对应的关系。</p>
<p><img src="/images/Performance2.jpg" alt="Performance2"></p>
<p>从图中可以看到很多指标都是成对出现，这里我们直接求差值，就可以求出对应页面加载过程中关键节点的耗时，这里我们介绍几个比较常用的，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timingInfo = <span class="built_in">window</span>.performance.timing;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DNS解析，DNS查询耗时</span></span><br><span class="line">timingInfo.domainLookupEnd - timingInfo.domainLookupStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TCP连接耗时</span></span><br><span class="line">timingInfo.connectEnd - timingInfo.connectStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得首字节耗费时间，也叫TTFB</span></span><br><span class="line">timingInfo.responseStart - timingInfo.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// domReady时间(与DomContentLoad事件对应)</span></span><br><span class="line">timingInfo.domContentLoadedEventStart - timingInfo.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM资源下载</span></span><br><span class="line">timingInfo.responseEnd - timingInfo.responseStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备新页面时间耗时</span></span><br><span class="line">timingInfo.fetchStart - timingInfo.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向耗时</span></span><br><span class="line">timingInfo.redirectEnd - timingInfo.redirectStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Appcache 耗时</span></span><br><span class="line">timingInfo.domainLookupStart - timingInfo.fetchStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unload 前文档耗时</span></span><br><span class="line">timingInfo.unloadEventEnd - timingInfo.unloadEventStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request请求耗时</span></span><br><span class="line">timingInfo.responseEnd - timingInfo.requestStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求完毕至DOM加载</span></span><br><span class="line">timingInfo.domInteractive - timingInfo.responseEnd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释dom树耗时</span></span><br><span class="line">timingInfo.domComplete - timingInfo.domInteractive;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从开始至load总耗时</span></span><br><span class="line">timingInfo.loadEventEnd - timingInfo.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 白屏时间</span></span><br><span class="line">timingInfo.responseStart - timingInfo.fetchStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首屏时间</span></span><br><span class="line">timingInfo.domComplete - timingInfo.fetchStart;</span><br></pre></td></tr></table></figure>

<h2 id="感官性能优化指标"><a href="#感官性能优化指标" class="headerlink" title="感官性能优化指标"></a>感官性能优化指标</h2><p>普通用户感官体验联系更加紧密的一些指标：</p>
<ul>
<li>First Paint(简称FP)：表示文档中任一元素首次渲染时间。用于标记导航之后浏览器在屏幕上渲染像素的时间点。这个不难理解，就是浏览器开始请求网页到网页首帧绘制的时间点。这个指标表明了网页请求是否成功。</li>
<li>First Contentful Paint(简称FCP)：当浏览器首次渲染任何文本，图像（包括背景图像），非白色画布或SVG时。这个指标就是我们日常说的白屏时间。</li>
<li>First Meaningful Paint(简称FMP)：首次有意义的绘制，这个指标反映的是主要内容出现在页面上所需要的时间，如果FMP时间过长的话，这里就要考虑是不是静态文件阻塞了主线程。这是一个很主观的指标。根据业务的不同，每一个网站的有效内容都是不相同的，有效内容就是网页中”主角元素”。</li>
<li>Time To Interactive(TTI):可交互时间，等到服务器通过HTTP协议将响应全部返回之后，便开始DOM Tree 的构建，完成之后，网页变成可交互状态，到此为止便是网页的可交互时间。用户可以进行正常的事件输入交互操作，这个指标是最重要的用户体验指标，用户最关心的就是什么时候可以进行交互，所以通常这个指标是我们优化的重点。</li>
</ul>
<p><img src="/images/Performance3.jpg" alt="感官性能优化指标"></p>
<ul>
<li>我们可以在控制台输入 <strong><em>window.performance.getEntriesByType(‘paint’)</em></strong> 获取，<strong><em>First Paint(简称FP)</em></strong>，<strong><em>First Contentful Paint(简称FCP)</em></strong>。</li>
<li>另外2个指标我们可以通过性能优化工具 <a href="https://github.com/GoogleChrome/lighthouse" target="_blank" rel="noopener">Lighthouse</a> 实时测量进行获取。</li>
</ul>
<p><img src="/images/Performance4.png" alt="感官性能优化指标2"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.imooc.com/read/41#catalog" target="_blank" rel="noopener">你不知道的前端性能优化技巧</a></li>
<li><a href="https://github.com/ChenChenJoke/JokerWebFont/tree/master/Performance" target="_blank" rel="noopener">Web性能优化：Performance，数据搜集方法</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化</title>
    <url>/2019-10-16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="什么是前端性能优化"><a href="#什么是前端性能优化" class="headerlink" title="什么是前端性能优化"></a>什么是前端性能优化</h2><p>从用户访问资源到资源完整的展现在用户面前的过程中，通过技术手段和优化策略，缩短每个步骤的处理时间从而提升整个资源的访问和呈现速度。</p><h2 id="为什么要做前端性能优化"><a href="#为什么要做前端性能优化" class="headerlink" title="为什么要做前端性能优化"></a>为什么要做前端性能优化</h2><p>在构建web站点的过程中，任何一个细节都有可能影响网站的访问速度，如果不了解性能优化知识，很多不利网站访问速度的因素会形成累加，从而严重影响网站的性能，导致网站访问速度变慢，用户体验低下，最终导致用户流失。</p><a id="more"></a>

<h2 id="从浏览器发起请求到页面能正常浏览都有哪些阶段"><a href="#从浏览器发起请求到页面能正常浏览都有哪些阶段" class="headerlink" title="从浏览器发起请求到页面能正常浏览都有哪些阶段"></a>从浏览器发起请求到页面能正常浏览都有哪些阶段</h2><ul>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>HTTP 请求抛出</li>
<li>服务端处理请求，HTTP 响应返回</li>
<li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户</li>
</ul>
<p>针对这五个过程进行分解，我们可以将前端性能优化划分为<strong><em>网络层面</em></strong>和<strong><em>渲染层面</em></strong>两个大的维度，并以此来进行扩展，学习。</p>
<h2 id="性能优化的具体方法"><a href="#性能优化的具体方法" class="headerlink" title="性能优化的具体方法"></a>性能优化的具体方法</h2><h3 id="内容层面"><a href="#内容层面" class="headerlink" title="内容层面"></a>内容层面</h3><ul>
<li>1、DNS解析优化（DNS缓存、减少DNS查找、keep-alive、适当的主机域名）</li>
<li>2、避免重定向（/还是需要的）</li>
<li>3、切分到多个域名</li>
<li>4、杜绝404</li>
</ul>
<h3 id="网络传输阶段"><a href="#网络传输阶段" class="headerlink" title="网络传输阶段"></a>网络传输阶段</h3><ul>
<li>1、减少传输过程中实体的大小<ul>
<li>缓存</li>
<li>cookie优化</li>
<li>文件压缩（Accept-Encoding：g-zip）</li>
</ul>
</li>
<li>2、减少请求的次数<ul>
<li>文件适当的合并</li>
<li>雪碧图</li>
</ul>
</li>
<li>3、异步加载（并发）</li>
<li>4、预加载、延后加载、按需加载</li>
</ul>
<h3 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h3><ul>
<li>1、js放底部，css放顶部</li>
<li>2、减少重绘和回流</li>
<li>3、合理使用Viewport 等meta头部</li>
<li>4、减少dom节点</li>
</ul>
<h3 id="脚本执行阶段"><a href="#脚本执行阶段" class="headerlink" title="脚本执行阶段"></a>脚本执行阶段</h3><ul>
<li>1、缓存节点，尽量减少节点的查找</li>
<li>2、减少节点的操作（innerHTML）</li>
<li>3、避免无谓的循环，break、continue、return的适当使用</li>
<li>4、事件委托</li>
</ul>
<h3 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h3><p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//jkfhto.github.io&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>通过长连接、预连接、接入 SPDY 协议。优化TCP连接。</p>
<h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><ul>
<li>减少 HTTP请求数</li>
<li>减小请求体积</li>
</ul>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/grandPang/article/details/51329289" target="_blank" rel="noopener">前端性能优化归纳总结篇</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入 URL 到页面加载完成，发生了什么？</title>
    <url>/2019-10-16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>从前端的角度出发，主要包括以下几个方面：</p><ul>
<li>浏览器的地址栏输入URL并按下回车。</li>
<li>浏览器查找当前URL是否存在缓存，并比较缓存是否过期。</li>
<li>通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址。</li>
<li>然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接（三次握手）。</li>
<li>随后我们向服务端抛出我们的 HTTP 请求。</li>
<li>服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端。</li>
<li>拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作。</li>
<li>关闭TCP连接（四次挥手）。</li>
</ul><a id="more"></a>

<h3 id="三次握手简单说明"><a href="#三次握手简单说明" class="headerlink" title="三次握手简单说明"></a>三次握手简单说明</h3><p> 所谓三次握手（Three-Way Handshake）即建立TCP连接，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。</p>
<ul>
<li>1.客户端–发送带有SYN标志的数据包–一次握手–服务端（客户端：我要连接你了，可以吗？）</li>
<li>2.服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端（服务端：嗯，我准备好了，连接我吧。）</li>
<li>3.客户端–发送带有带有ACK标志的数据包–三次握手–服务端（客户端：那我连接你咯。）</li>
</ul>
<h3 id="四次挥手简单说明"><a href="#四次挥手简单说明" class="headerlink" title="四次挥手简单说明"></a>四次挥手简单说明</h3><ul>
<li>客户端-发送一个FIN，用来关闭客户端到服务器的数据传送（客户端向服务器发送一个断开连接的请求）</li>
<li>服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号（服务器接到请求后发送确认收到请求的信号）</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端（服务器向主机发送断开通知）</li>
<li>客户端-发回ACK报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.iteye.com/blog/uule-2213562" target="_blank" rel="noopener">TCP协议的三次握手和四次挥手</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>前端性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Event Loop 运行机制</title>
    <url>/2019-10-14/Javascript/Event-Loop-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。</p><h2 id="进程和线程基本概念"><a href="#进程和线程基本概念" class="headerlink" title="进程和线程基本概念"></a>进程和线程基本概念</h2><p>拿出在教科书里的概念：</p><ul>
<li>1、调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li>
<li>2、并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</li>
<li>3、拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源；</li>
<li>4、系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。进程和线程的关系：</li>
</ul><a id="more"></a>


<p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p>
<p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p>
<p>处理机分给线程，即真正在处理机上运行的是线程；</p>
<p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体。</p>
<p>基本总结，一个进程可以有多个线程，线程之间可以相互通信。</p>
<p>进程是 CPU资源分配的最小单位；线程是 CPU调度的最小单位。</p>
<h3 id="图示解析"><a href="#图示解析" class="headerlink" title="图示解析"></a>图示解析</h3><p><img src="/images/EventLoop3.jpg" alt="进程和线程"></p>
<ul>
<li>进程好比图中的工厂，有单独的专属自己的工厂资源。</li>
<li>线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n的关系。也就是说一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>
<li>工厂的空间是工人们共享的，这象征一个进程的内存空间是共享的，每个线程都可用这些共享内存。</li>
<li>多个工厂之间独立存在。</li>
</ul>
<h3 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h3><ul>
<li>多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</li>
<li>多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li>
</ul>
<p>以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p>
<p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p>
<ul>
<li>GUI 渲染线程</li>
<li>JavaScript引擎线程</li>
<li>定时触发器线程</li>
<li>事件触发线程</li>
<li>异步http请求线程</li>
</ul>
<h3 id="1-GUI渲染线程"><a href="#1-GUI渲染线程" class="headerlink" title="1.GUI渲染线程"></a>1.GUI渲染线程</h3><p>主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。<br>当界面需要重绘或者由于某种操作引发回流时，将执行该线程。<br>该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。</p>
<h3 id="2-JS引擎线程"><a href="#2-JS引擎线程" class="headerlink" title="2.JS引擎线程"></a>2.JS引擎线程</h3><p>该线程当然是主要负责处理 JavaScript脚本，执行代码。<br>也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。<br>当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。</p>
<h3 id="3-定时器触发线程"><a href="#3-定时器触发线程" class="headerlink" title="3.定时器触发线程"></a>3.定时器触发线程</h3><p>负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。<br>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。</p>
<h3 id="4-事件触发线程"><a href="#4-事件触发线程" class="headerlink" title="4.事件触发线程"></a>4.事件触发线程</h3><p>主要负责将准备好的事件交给 JS引擎线程执行。</p>
<p>比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。</p>
<h3 id="5-异步http请求线程"><a href="#5-异步http请求线程" class="headerlink" title="5.异步http请求线程"></a>5.异步http请求线程</h3><p>负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。</p>
<p>主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。</p>
<h2 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h2><p>JS 执行是单线程的，意味着 JS 在执行代码的时候一次只能处理一个任务，必须按队列顺序逐个执行。JS 的主要功效是处理前端交互，其中就包括操作 DOM 节点。试想若 JS 是多线程，在处理网页交互时，一个线程需要删除 DOM 节点，另一个线程却是要操作同一个 DOM 节点，这样该如何判断先执行哪个线程？但若队列中存在多个任务，上一个任务的执行会阻塞下一个任务，导致代码执行效率低下。就像 AJAX 请求线程，发出请求后需要等待响应结果，期间 CPU 却是空闲的。对此，JS的事件循环机制（Event Loop）很好地解决了问题。</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里所谓的单线程指的是主线程是单线程的,所以在Node中主线程依旧是单线程的。</span><br></pre></td></tr></table></figure>

<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>JavaScript 将任务分为两种：同步任务和异步任务。</p>
<ul>
<li>同步任务：执行完后能立即得出结果的任务。同步任务在主线程中执行，上一个任务的执行会阻塞下一个任务，在执行过程中产生堆栈。堆中存储复杂数据类型（Object），栈中存储基本数据类型（String、Number、Boolean、Null、Undefined、Symbol）。</li>
<li>异步任务：执行后无法立即得出结果，需要等待一段时间获得相应的任务。其中又分为宏任务（Macrotask）和微任务（Microtask）。<ul>
<li>宏任务：script（整体代码）、setTimeout、setInterval、setImmediate、I/O操作（mouse click、keypress、network event）、UI渲染、requestAnimationTrame等。</li>
<li>微任务：Promise.then、MutationObserver、process.nextTick()等。</li>
</ul>
</li>
</ul>
<h2 id="浏览器-Event-Loop-过程解析"><a href="#浏览器-Event-Loop-过程解析" class="headerlink" title="浏览器 Event Loop 过程解析"></a>浏览器 Event Loop 过程解析</h2><p>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>
<p>JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p>
<p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p>
<ul>
<li><p>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</p>
</li>
<li><p>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</p>
</li>
<li><p>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的（如下图所示）。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</p>
</li>
<li><p>执行渲染操作，更新界面（敲黑板划重点）。</p>
</li>
<li><p>检查是否存在 Web worker 任务，如果有，则对其进行处理 。</p>
</li>
<li><p>上述过程循环往复，直到两个队列都清空</p>
</li>
</ul>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<p>执行过程分析：</p>
<p>全局上下文 <strong><em>（script 标签）</em></strong> 被推入调用栈，同步代码执行。打印 <strong><em>script start</em></strong>，遇到 <strong><em>setTimeout</em></strong>，推入到<strong><em>macro 队列</em></strong>。遇到<strong><em>Promise.resolve().then</em></strong>推入到<strong><em>micro 队列</em></strong>，遇到同步代码。打印 <strong><em>script end</em></strong>。</p>
<p><strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>promise1</em></strong>，遇到 <strong><em>then</em></strong>，推入到<strong><em>macro 队列</em></strong>。<strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>promise2</em></strong>。<strong><em>micro 队列</em></strong> 清空。</p>
<p><strong><em>macro 队列</em></strong> 执行出队列操作，打印 <strong><em>setTimeout</em></strong>，<strong><em>macro 队列</em></strong> 清空。</p>
<h3 id="更复杂的例子"><a href="#更复杂的例子" class="headerlink" title="更复杂的例子"></a>更复杂的例子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="comment">// async2().then(function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log('async1 end')</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise3'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2 end</span></span><br><span class="line"><span class="comment">// Promise1</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// promise3</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<p>执行过程分析：</p>
<p>全局上下文 <strong><em>（script 标签）</em></strong> 被推入调用栈，同步代码执行。打印 <strong><em>script start</em></strong>，遇到 <strong><em>setTimeout</em></strong>，推入到<strong><em>macro 队列</em></strong>。执行 <strong><em>async1</em></strong> ，打印 <strong><em>async1 start</em></strong> 。执行 <strong><em>await async2()</em></strong>，相当于先执行 <strong><em>async2</em></strong> 这个 <strong><em>Promise</em></strong> 函数，打印 <strong><em>async2 end</em></strong>，然后执行 <strong><em>then</em></strong>，<strong><em>micro</em></strong> 任务 <strong><em>console.log(‘async1 end’)</em></strong> 入队列。遇到 <strong><em>new Promise</em></strong>，同步任务，打印 <strong><em>Promise1</em></strong>，执行 <strong><em>resolve()</em></strong>，<strong><em>micro</em></strong> 任务 <strong><em>console.log(‘promise2’)</em></strong> 入队列。遇到同步任务，打印 <strong><em>script end</em></strong>；</p>
<p><strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>async1 end</em></strong>，然后打印 <strong><em>promise2</em></strong>，遇到 <strong><em>then</em></strong>，<strong><em>console.log(‘promise3’)</em></strong>，推入到<strong><em>macro 队列</em></strong>。<strong><em>micro 队列</em></strong> 执行出队列操作，打印 <strong><em>promise3</em></strong>。<strong><em>micro 队列</em></strong> 清空。</p>
<p><strong><em>macro 队列</em></strong> 执行出队列操作，打印 <strong><em>setTimeout</em></strong>，<strong><em>macro 队列</em></strong> 清空。</p>
<h2 id="NodeJS-Event-Loop-过程解析"><a href="#NodeJS-Event-Loop-过程解析" class="headerlink" title="NodeJS Event Loop 过程解析"></a>NodeJS Event Loop 过程解析</h2><p><img src="/images/EventLoop.jpg" alt="Event Loop"></p>
<p>Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。</p>
<p><img src="/images/EventLoop2.jpg" alt="Event Loop2"></p>
<h3 id="Node-js的运行机制如下"><a href="#Node-js的运行机制如下" class="headerlink" title="Node.js的运行机制如下:"></a>Node.js的运行机制如下:</h3><ul>
<li>V8引擎解析JavaScript脚本。</li>
<li>解析后的代码，调用Node API。</li>
<li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li>V8引擎再将结果返回给用户。</li>
</ul>
<p>Node的Event loop一共分为6个阶段，每个细节具体如下：</p>
<ul>
<li>timers: 执行setTimeout和setInterval中到期的callback。</li>
<li>pending callback: 执行延迟到下一个循环迭代的 I/O 回调。</li>
<li>idle, prepare: 仅在内部使用。</li>
<li>poll: 最重要的阶段，执行pending callback，检索新的 I/O 事件;执行与 I/O 相关的回调，在适当的情况下回阻塞在这个阶段。</li>
<li>check: 执行setImmediate() 设定的callbacks。</li>
<li>close callbacks: 执行close事件的callback，例如socket.on(‘close’[,fn])或者http.server.on(‘close, fn)。</li>
</ul>
<h3 id="timers"><a href="#timers" class="headerlink" title="timers"></a>timers</h3><p>执行 <strong><em>setTimeout</em></strong> 和 <strong><em>setInterval</em></strong> 中到期的 <strong><em>callback</em></strong>，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行<strong><em>callback</em></strong> 回调，但是由于 <strong><em>system的调度</em></strong> 可能会延时，达不到预期时间。</p>
<h3 id="pending-callbacks"><a href="#pending-callbacks" class="headerlink" title="pending callbacks"></a>pending callbacks</h3><p>此阶段执行某些系统操作的回调，例如TCP错误的类型。 例如，如果TCP套接字在尝试连接时收到ECONNREFUSED，则某些* nix系统希望等待报告错误。 这将在pending callbacks阶段执行。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 阶段有两个重要的功能：</p>
<ul>
<li>执行与 I/O 相关的回调</li>
<li>然后，处理 poll 队列里的事件</li>
</ul>
<p>当事件循环进入 <strong><em>poll</em></strong> 阶段并且在 <strong><em>timers</em></strong> 队列中没有可以执行定时器时，将发生以下两种情况之一</p>
<ul>
<li>如果 <strong><em>poll</em></strong> 队列不为空，事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制。遇到 <strong><em>setImmediate</em></strong> 将其回调放入 <strong><em>setImmediate</em></strong> 队列。</li>
<li>如果poll队列为空，则会发生以下情况：<ul>
<li>如果有 <strong><em>setImmediate()</em></strong> 回调，则会立即停止执行 <strong><em>poll</em></strong> 阶段并进入执行 <strong><em>check</em></strong> 阶段以执行 <strong><em>setImmediate</em></strong> 回调，清空 <strong><em>check</em></strong>队列。执行完<strong><em>setImmediate</em></strong> ，事件循环将绕回 timers 阶段</li>
<li>如果没有 <strong><em>setImmediate()</em></strong> 回调，一方面将等待 <strong><em>I/O</em></strong> 相关的回调被添加到 <strong><em>poll</em></strong> 队列中，然后立即执行。另一方面如果一个或多个计时器回调已准备就绪，则事件循环将绕回 <strong><em>timers</em></strong> 阶段以执行这些计时器的回调。简言之就是，<strong><em>I/O</em></strong> 相关的回调和 <strong><em>timers</em></strong> 相关的回调谁先有结果就先执行谁。</li>
</ul>
</li>
</ul>
<h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p>此阶段允许人员在 <strong><em>poll</em></strong> 阶段完成后立即执行回调。如果 <strong><em>poll</em></strong> 阶段变为空闲状态，并且脚本已排队使用 setImmediate()，则事件循环继续到 <strong><em>check</em></strong> 阶段而不是等待。</p>
<p><strong><em>setImmediate()</em></strong> 实际上是一个在事件循环的单独阶段运行的特殊计时器。它使用一个 <strong><em>libuv API</em></strong> 来安排回调在 <strong><em>poll</em></strong> 阶段完成后执行。</p>
<p>通常，在执行代码时，事件循环最终将达到 <strong><em>poll</em></strong> 阶段，等待传入连接、请求等。如果已经调度了回调setImmediate()，并且轮询阶段变为空闲，则它将结束并且到达check阶段，而不是等待poll事件。</p>
<h3 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h3><p>如果 <strong><em>socket</em></strong> 或 <strong><em>handle</em></strong> 处理函数突然关闭（例如 socket.destroy()），则’close’ 事件将在这个阶段发出。否则它将通过 process.nextTick() 发出。</p>
<h3 id="setImmediate-的setTimeout-的区别"><a href="#setImmediate-的setTimeout-的区别" class="headerlink" title="setImmediate() 的setTimeout()的区别"></a>setImmediate() 的setTimeout()的区别</h3><p>setImmediate() 和 setTimeout() 很类似，但何时调用行为完全不同。</p>
<ul>
<li>setImmediate()：设计用于在当前poll阶段完成后check阶段执行脚本 。</li>
<li>setTimeout()：安排在经过最小（ms）后运行的脚本，在timers阶段执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码的执行结果，受到进程性能的限制。其结果也不一致。</p>
<p>如果在I / O周期内移动两个调用，则始终首先执行 <strong><em>setImmediate</em></strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>主要原因是在 <strong><em>I/O</em></strong> 阶段读取文件后，事件循环会先进入 <strong><em>poll</em></strong> 阶段，发现有 <strong><em>setImmediate</em></strong> 需要执行，会立即进入check阶段执行<strong><em>setImmediate</em></strong> 的回调。</p>
<p>然后再进入 <strong><em>timers</em></strong> 阶段，执行 <strong><em>setTimeout</em></strong>，打印 <strong><em>timeout</em></strong>。</p>
<h3 id="Process-nextTick"><a href="#Process-nextTick" class="headerlink" title="Process.nextTick()"></a>Process.nextTick()</h3><p>当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p>
<h3 id="一个完整的-NodeJS-Event-Loop-过程"><a href="#一个完整的-NodeJS-Event-Loop-过程" class="headerlink" title="一个完整的 NodeJS Event Loop 过程"></a>一个完整的 <strong><em>NodeJS Event Loop</em></strong> 过程</h3><p>一个完整的 <strong><em>NodeJS Event Loop</em></strong> 过程，可以概括为以下阶段：</p>
<ul>
<li>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li>
<li>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</li>
<li>上一步我们出队的是一个 <strong><em>macro-task</em></strong>，这一步我们处理的是 <strong><em>micro-task</em></strong>。会逐个执行队列中的任务并把它出队，直到队列被清空。同时请注意， <strong><em>Process.nextTick</em></strong> 的优先级高于 <strong><em>Promise.then</em></strong></li>
<li>进入 <strong><em>timers</em></strong> 阶段，执行 <strong><em>setTimeout</em></strong> 和 <strong><em>setInterval</em></strong> 中到期的 <strong><em>callback</em></strong>。</li>
<li>如果 <strong><em>timers</em></strong> 阶段，没有 <strong><em>setTimeout</em></strong> 和 <strong><em>setInterval</em></strong> 到期的回调，会进入 <strong><em>poll</em></strong> 阶段。当事件循环进入poll阶段并且在timers中没有可以执行定时器时，将发生以下两种情况之一。<ul>
<li>如果 <strong><em>poll</em></strong> 队列不为空，事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制。遇到 <strong><em>setImmediate</em></strong> 将其回调放入 <strong><em>setImmediate</em></strong> 队列。</li>
<li>如果poll队列为空，则会发生以下情况：<ul>
<li>如果有 <strong><em>setImmediate()</em></strong> 回调，则会立即停止执行 <strong><em>poll</em></strong> 阶段并进入执行 <strong><em>check</em></strong> 阶段以执行 <strong><em>setImmediate</em></strong> 回调，清空 <strong><em>check</em></strong>队列。执行完<strong><em>setImmediate</em></strong> ，事件循环将绕回 timers 阶段</li>
<li>如果没有 <strong><em>setImmediate()</em></strong> 回调，一方面将等待 <strong><em>I/O</em></strong> 相关的回调被添加到 <strong><em>poll</em></strong> 队列中，然后立即执行。另一方面如果一个或多个计时器回调已准备就绪，则事件循环将绕回 <strong><em>timers</em></strong> 阶段以执行这些计时器的回调。简言之就是，<strong><em>I/O</em></strong> 相关的回调和 <strong><em>timers</em></strong> 相关的回调谁先有结果就先执行谁。</li>
</ul>
</li>
</ul>
</li>
<li>注意，<strong><em>pending callback</em></strong>，<strong><em>idle, prepare</em></strong> 这两个阶段我们通常不用考虑。</li>
<li>同时请注意，如果node版本为v11.x，会执行一个 <strong><em>macro-task</em></strong>，然后处理 <strong><em>micro-task</em></strong>。会逐个执行 <strong><em>micro-task</em></strong> 队列中的任务并把它出队，直到队列被清空，与浏览器效果类似。如果node版本为v11.x以下版本，会执行完所有的 <strong><em>macro-task</em></strong>，清空 <strong><em>macro-task</em></strong> 队列。然后，执行 <strong><em>macro-task</em></strong>，清空 <strong><em>micro-task</em></strong> 队列。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> endTime = +<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"timeout用时共计："</span> + (endTime - beginTime) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">fs.readFile(path.resolve(__dirname, <span class="string">'./test copy.js'</span>), () =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> endTime = +<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"readFile1用时共计："</span> + (endTime - beginTime) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'aaaa'</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> beginTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">fs.readFile(path.resolve(__dirname, <span class="string">'./test copy.js'</span>), () =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> endTime = +<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"readFile2用时共计："</span> + (endTime - beginTime) + <span class="string">"ms"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bbb'</span>)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate2'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况1</span></span><br><span class="line"><span class="comment">// readFile1用时共计：3ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// timeout用时共计：14ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// readFile2用时共计：15ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况2</span></span><br><span class="line"><span class="comment">// timeout用时共计：3ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// readFile1用时共计：12ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// readFile2用时共计：13ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况3</span></span><br><span class="line"><span class="comment">// readFile2用时共计：2ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"><span class="comment">// timeout用时共计：12ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="comment">// readFile1用时共计：12ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行情况4</span></span><br><span class="line"><span class="comment">// readFile1用时共计：2ms</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// readFile2用时共计：9ms</span></span><br><span class="line"><span class="comment">// bbb</span></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// immediate2</span></span><br><span class="line"><span class="comment">// timeout用时共计：10ms</span></span><br><span class="line"><span class="comment">// timeout</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.zhufengpeixun.cn/main/course/index.html" target="_blank" rel="noopener">珠峰前端架构师</a></li>
<li><a href="https://juejin.im/post/5c3d8956e51d4511dc72c200" target="_blank" rel="noopener">一次弄懂Event Loop（彻底解决此类面试问题）</a></li>
<li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">The Node.js Event Loop, Timers, and process.nextTick()</a></li>
<li><a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218" target="_blank" rel="noopener">浏览器与Node的事件循环(Event Loop)有何区别?</a></li>
</ul>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP 面向切片编程</title>
    <url>/2019-10-14/Javascript/AOP-%E9%9D%A2%E5%90%91%E5%88%87%E7%89%87%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="AOP-面向切片编程"><a href="#AOP-面向切片编程" class="headerlink" title="AOP 面向切片编程"></a>AOP 面向切片编程</h2><p><strong><em>AOP（面向切面编程）</em></strong> 的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括<strong><em>日志统计</em></strong>、<strong><em>安全控制</em></strong>、<strong><em>异常处理</em></strong> 等。把这些功能抽离出来之后，再通过 <strong><em>动态植入</em></strong> 的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的 <strong><em>纯净</em></strong> 和 <strong><em>高内聚性</em></strong> ，其次是可以很方便地复用日志统计等功能模块。</p><a id="more"></a>
<p>在 JavaScript中实现 <strong><em>AOP</em></strong>，都是指把一个函数<strong><em>动态植入</em></strong>到另外一个函数之中，通常是基于<strong><em>高阶函数</em></strong>实现的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高阶函数，返回一个新的函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforefn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __self = <span class="keyword">this</span>; <span class="comment">// 保存原函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回包含了原函数和新函数的"代理"函数</span></span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行新函数，修正 this</span></span><br><span class="line">        <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行原函数 并返回原函数执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数，返回一个新的函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterfn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行原函数</span></span><br><span class="line">        afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行新函数，修正 this</span></span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">// 返回原函数执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">func = func.before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line">func();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="数据统计上报"><a href="#数据统计上报" class="headerlink" title="数据统计上报"></a>数据统计上报</h2><p><strong><em>分离业务代码和数据统计</em></strong> 代码，无论在什么语言中，都是 <strong><em>AOP</em></strong> 的经典应用之一。在项目开发的结尾阶段难免要加上很多统计数据的代码，这些过程可能让我们被迫改动早已封装好的函数。</p>
<p>比如页面中有一个登录 button，点击这个 button会弹出登录浮层，与此同时要进行数据上报，来统计有多少用户点击了这个登录 button：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">tag</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>点击打开登录浮层<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</span></span><br><span class="line"><span class="javascript">        log( <span class="keyword">this</span>.getAttribute( <span class="string">'tag'</span> ) );</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"> tag </span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'上报标签为: '</span> + tag);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// (new Image).src = 'http:// xxx.com/report?tag=' + tag; // 真正的上报代码略</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById( <span class="string">'button'</span> ).onclick = showLogin;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>showLogin</em></strong> 函数里，既要负责打开登录浮层，又要负责数据上报，这是两个层面的功能，在此处却被耦合在一个函数里。使用 <strong><em>AOP</em></strong> 分离之后，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">tag</span>=<span class="string">"login"</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>点击打开登录浮层<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterfn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">            afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> ret;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'上报标签为: '</span> + <span class="keyword">this</span>.getAttribute(<span class="string">'tag'</span>));</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    showLogin = showLogin.after(log); <span class="comment">// 打开登录浮层之后上报数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).onclick = showLogin;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="用AOP动态改变函数的参数"><a href="#用AOP动态改变函数的参数" class="headerlink" title="用AOP动态改变函数的参数"></a>用AOP动态改变函数的参数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span> (<span class="params">type, url, param</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(param); <span class="comment">// 发送 ajax 请求的代码略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getToken = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Token'</span>;</span><br><span class="line">&#125;</span><br><span class="line">ajax = ajax.before(<span class="function"><span class="keyword">function</span> (<span class="params">type, url, param</span>) </span>&#123;</span><br><span class="line">    param.Token = getToken();</span><br><span class="line">&#125;);</span><br><span class="line">ajax(<span class="string">'get'</span>, <span class="string">'http:// xxx.com/userinfo'</span>, &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;);</span><br><span class="line"><span class="comment">// 从 ajax 函数打印的 log可以看到， Token 参数已经被附加到了 ajax 请求的参数中：</span></span><br><span class="line"><span class="comment">// &#123; name: "sven", Token: "Token" &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>beforefn</em></strong> 和原函数 <strong><em>__self</em></strong>  共用一组参数列表<strong><em>arguments</em></strong> ，当我们在 <strong><em>beforefn</em></strong> 的函数体内改变 <strong><em>arguments</em></strong> 的时候，原函数 <strong><em>__self</em></strong> 接收的参数列表自然也会变化。</p>
<p>明显可以看到，用 <strong><em>AOP</em></strong> 的方式给 <strong><em>ajax</em></strong> 函数动态装饰上 <strong><em>Token</em></strong> 参数，保证了 <strong><em>ajax</em></strong> 函数是一个相对纯净的函数，提高了 <strong><em>ajax</em></strong> 函数的可复用性，它在被迁往其他项目的时候，不需要做任何修改。</p>
<h2 id="插件式的表单验证"><a href="#插件式的表单验证" class="headerlink" title="插件式的表单验证"></a>插件式的表单验证</h2><p>在表单数据提交给后台之前，常常要做一些校验，比如登录的时候需要验证用户名和密码是否为空，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line">    密码： <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"submitBtn"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>),</span></span><br><span class="line"><span class="javascript">        password = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>),</span></span><br><span class="line"><span class="javascript">        submitBtn = <span class="built_in">document</span>.getElementById(<span class="string">'submitBtn'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforefn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) === <span class="literal">false</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// beforefn 返回 false 的情况直接 return，不再执行后面的原函数</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 可以做相关提示操作</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> validata = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (username.value === <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'用户名不能为空'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (password.value === <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'密码不能为空'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> formSubmit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> param = &#123;</span></span><br><span class="line">            username: username.value,</span><br><span class="line">            password: password.value</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        ajax(<span class="string">'http:// xxx.com/login'</span>, param);</span></span><br><span class="line">    &#125;</span><br><span class="line">    formSubmit = formSubmit.before(validata);</span><br><span class="line"><span class="javascript">    submitBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        formSubmit();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>校验输入和提交表单的代码完全分离开来，它们不再有任何耦合关系。</p>
<p>值得注意的是，因为函数通过 <strong><em>Function.prototype.before</em></strong> 或者 <strong><em>Function.prototype.after</em></strong> 被装饰之后，返回的实际上是一个新的函数，如果在原函数上保存了一些属性，那么这些属性会丢失。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">func.a = <span class="string">'a'</span>;</span><br><span class="line">func = func.after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(func.a); <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure>

<p>另外，这种装饰方式也叠加了<strong><em>函数的作用域</em></strong>，如果装饰的链条过长，性能上也会受到一些影响。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">javascript 设计模式与开发实践</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-深拷贝浅析</title>
    <url>/2019-10-14/Javascript/JavaScript-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(object))</span><br></pre></td></tr></table></figure><p>该方法有以下几个问题：</p><ul>
<li>会忽略 undefined</li>
<li>会忽略 symbol</li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
<li>不能正确处理new Date()</li>
<li>不能处理正则</li>
</ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'111'</span>,</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    b: <span class="built_in">Symbol</span>(<span class="string">'111'</span>),</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;name: "111"&#125;</span></span><br></pre></td></tr></table></figure><a id="more"></a>





<h2 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj,hash = new WeakMap(</span>))</span>&#123;</span><br><span class="line">    <span class="comment">//避免引用循环 比较对象与对象属性是否相等</span></span><br><span class="line">    <span class="comment">// if (obj === parent) return parent;</span></span><br><span class="line">    <span class="comment">//处理null undefined</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">//处理string boolean number</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">    <span class="keyword">if</span>(hash.has(obj))&#123;</span><br><span class="line">        <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理 array object</span></span><br><span class="line">    <span class="keyword">let</span> instance = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">    hash.set(obj, instance)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="comment">//递归实现深拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key))&#123;</span><br><span class="line">            instance[key] = deepClone(obj[key], hash);</span><br><span class="line">            <span class="comment">// instance[key] = deepClone(obj[key], obj);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line">obj.b = obj;</span><br><span class="line"><span class="keyword">var</span> cloneObj = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(cloneObj === obj, cloneObj)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-高阶函数浅析</title>
    <url>/2019-10-13/Javascript/JavaScript-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数英文叫 Higher-order function，它的定义很简单，就是至少满足下列一个条件的函数：</p><ul>
<li>函数作为返回值</li>
<li>函数作为参数传递</li>
</ul><p>也就是说高阶函数是对其他函数进行操作的函数，可以将它们作为参数传递，或者是返回函数。 </p><h2 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h2><p>JavaScript 语言中内置了一些高阶函数，比如 Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce，它们接受一个函数作为参数，并使用这个函数作用到列表的每一个元素</p><a id="more"></a>



<h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map"></a>Array.prototype.map</h3><p><strong><em>map()</em></strong> 函数返回一个新的数组，新数组中的元素是<strong><em>回调函数（callback）</em></strong>作用于指定数组中的元素后返回的结果。</p>
<ul>
<li>不会改变原始数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), <span class="title">thisValue</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>function(currentValue, index,arr)：必须。函数，数组中的每个元素都会执行这个函数<ul>
<li>currentValue：必须。当前元素的值</li>
<li>可选。当前元素的索引值</li>
<li>arr：可选。当前元素属于的数组对象</li>
</ul>
</li>
<li>thisValue：可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined”</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( arr2 );</span><br><span class="line"><span class="comment">// [2, 6, 12, 18]</span></span><br><span class="line"><span class="built_in">console</span>.log( arr1 );</span><br><span class="line"><span class="comment">// [1, 3, 6, 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter"></a>Array.prototype.filter</h3><p><strong><em>filter()</em></strong> 方法返回一个新数组, 新数组中的元素是通过检查指定数组中符合条件的所有元素。</p>
<ul>
<li>不会对空数组进行检测</li>
<li>不会改变原始数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), <span class="title">thisValue</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>function(currentValue, index,arr)：必须。函数，数组中的每个元素都会执行这个函数<ul>
<li>currentValue：必须。当前元素的值</li>
<li>可选。当前元素的索引值</li>
<li>arr：可选。当前元素属于的数组对象</li>
</ul>
</li>
<li>thisValue：可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined”</li>
</ul>
<p>数组去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1.filter( <span class="function">(<span class="params">element, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf( element ) === index;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( arr2 );</span><br><span class="line"><span class="comment">// [1, 2, 3, 5, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log( arr1 );</span><br><span class="line"><span class="comment">// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce"></a>Array.prototype.reduce</h3><p><strong><em>reduce()</em></strong> 方法对数组中的每个元素执行一个由您提供的<strong><em>reducer</em></strong>函数(升序执行)，回调函数<strong><em>（callback）</em></strong>，将其结果汇总为单个返回值。除了 <strong><em>callback</em></strong> 之外还可以接受初始值 <strong><em>initialValue</em></strong> 值（可选）</p>
<ul>
<li><p>如果没有提供 initialValue，那么第一次调用 callback 函数时，accumulator 使用原数组中的第一个元素，currentValue 即是数组中的第二个元素。 在没有初始值的空数组上调用 reduce 将报错。</p>
</li>
<li><p>如果提供了 initialValue，那么将作为第一次调用 callback 函数时的第一个参数的值，即 accumulator，currentValue 使用原数组中的第一个元素。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>)</span>&#123;&#125;, initialValue)</span><br></pre></td></tr></table></figure>

<ul>
<li>function(accumulator, currentValue, currentIndex, array)：必须。函数<ul>
<li>Accumulator (acc)：累计器</li>
<li>Current Value (cur)：当前值</li>
<li>Current Index (idx)：当前索引 可选</li>
<li>Source Array (src)：源数组 可选</li>
</ul>
</li>
<li>initialValue：initialValue</li>
</ul>
<p>数组求和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> sum = arr.reduce(<span class="function">(<span class="params">accumulator, currentValue, currentIndex, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( sum );</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log( arr );</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h2><h3 id="isType-函数"><a href="#isType-函数" class="headerlink" title="isType 函数"></a>isType 函数</h3><p>通过 <strong><em>Object.prototype.toString.call</em></strong>判断类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isType = <span class="function"><span class="params">type</span> =&gt;</span> <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object '</span> + type + <span class="string">']'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isType(<span class="string">'String'</span>)(<span class="string">'123'</span>) <span class="comment">// true</span></span><br><span class="line">isType(<span class="string">'Array'</span>)([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// true</span></span><br><span class="line">isType(<span class="string">'Number'</span>)(<span class="number">123</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="add-函数"><a href="#add-函数" class="headerlink" title="add 函数"></a>add 函数</h3><p>一个常见的面试题，用 JS 实现一个无限累加的函数 add，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)； <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)； <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>都是将函数作为返回值输出，然后接收新的参数并进行计算。</p>
<p>我们知道打印函数时会自动调用 toString()方法，函数 add(a) 返回一个闭包 sum(b)，函数 sum() 中累加计算 a = a + b，只需要重写sum.toString()方法返回结果值 a 就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        a = a + b; <span class="comment">// 求和</span></span><br><span class="line">        <span class="keyword">return</span> sum; <span class="comment">// 返回求和函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写toString()方法</span></span><br><span class="line">    sum.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">// 返回求和函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://muyiy.cn/blog/6/6.1.html" target="_blank" rel="noopener">https://muyiy.cn/blog/6/6.1.html</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript深入之继承的多种方式和优缺点</title>
    <url>/2019-10-12/Javascript/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'kevin'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()) <span class="comment">// kevin</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p>核心： 将父类的实例作为子类的原型</p>
<p>特点：实例可继承的属性有：Child实例的构造函数的属性，父类构造函数属性，父类原型的属性。</p>
<p>缺点：</p>
<ul>
<li>1.父类引用类型的属性被所有实例共享。</li>
<li>2.在创建 Child 的实例时，不能向Parent传参。</li>
</ul>
<h2 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2.借用构造函数"></a>2.借用构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.names = [<span class="string">'kevin'</span>, <span class="string">'daisy'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">'yayu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["kevin", "daisy", "yayu"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["kevin", "daisy"]</span></span><br></pre></td></tr></table></figure>

<p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类。</p>
<p>特点：</p>
<ul>
<li>解决了原型链继承中，子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承（call多个父类对象）</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能继承父类构造函数的属性和方法，不能继承原型上的属性/方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，浪费内存，影响性能</li>
</ul>
<h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line">child1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors); <span class="comment">// ["red", "blue", "green", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'daisy'</span>, <span class="string">'20'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors); <span class="comment">// ["red", "blue", "green"]</span></span><br></pre></td></tr></table></figure>

<p>核心：原型链继承和经典继承双剑合璧。</p>
<p>优点：可以继承父类原型上的属性，可以传参，可复用。融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p>
<p>缺点：调用了两次父类构造函数（耗内存）。</p>
<h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// o一般指向父类原型</span></span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="comment">// 实例化空函数，可以继承父类原型上的方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是 ES5 <strong><em>Object.create</em></strong> 的模拟实现，将传入的对象作为创建的对象的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'kevin'</span>,</span><br><span class="line">    friends: [<span class="string">'daisy'</span>, <span class="string">'kelly'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">var</span> person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'person1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.firends.push(<span class="string">'taylor'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["daisy", "kelly", "taylor"]</span></span><br></pre></td></tr></table></figure>

<p>注意：修改<strong><em>person1.name</em></strong>的值，<strong><em>person2.name</em></strong>的值并未发生改变，并不是因为<strong><em>person1</em></strong>和<strong><em>person2</em></strong>有独立的 <strong>*name *</strong>值，而是因为<strong><em>person1.name = ‘person1’</em></strong>，给<strong><em>person1</em></strong>添加了 <strong><em>name</em></strong> 值，并非修改了原型上的 <strong><em>name</em></strong> 值，<strong><em>person2.name</em></strong>获取的是原型上的值。</p>
<p>核心：使用一个空函数作为过渡对象，让空函数的prototype 指向需要继承的对象，返回实例化的空函数。</p>
<p>优点：空函数作为过渡对象，构造函数无内容，可以较少开销。</p>
<p>缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>
<h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = createObj(o);</span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心：寄生式继承就是对原型式继承的第二次封装，在第二次封装过程中对继承的对象进行了扩展，这样新创建的对象不仅可以继承父类中的属性和方法而且还添加了新的属性和方法。</p>
<h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// o一般指向父类原型</span></span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="comment">// 实例化空函数，可以继承父类原型上的方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过原型式继承，继承父类原型上的属性和方法</span></span><br><span class="line">    <span class="keyword">var</span> prototype = createObj(parent.prototype);</span><br><span class="line">    <span class="comment">// 添加新的属性，修复子类的构造函数</span></span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    <span class="comment">// 修改子类的原型，保留子类的构造函数，继承父类原型上的属性和方法</span></span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  借用构造函数</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">prototype(Child, Parent);</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>

<p>核心：寄生式继承和借用构造函数的经典组合。</p>
<p>借用构造函数，继承了构造函数中的属性和方法。通过原型继承可以继承父类原型的属性和方法，由于原型继承中，使用空函数作为过渡对象，构造函数无内容，可以较少开销。直接通过原型继承存在一个问题，子类的构造函数将会丢失。所以通过，寄生式继承对原型继承的结果进行扩展，修复其构造函数指向的不正确问题。最后将子类原型指向这个结果。</p>
<p>寄生组合式继承是引用类型最理想的继承范式。</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>==和===的区别是什么？</title>
    <url>/2019-10-12/Javascript/%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>==</strong>是抽象相等运算符，而<strong>===</strong>是严格相等运算符。<br><strong>==</strong>运算符是在进行必要的类型转换后，再比较。<br><strong>===</strong>运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回false。<br>使用<strong>==</strong>时，可能发生一些特别的事情，例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">'1'</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == [<span class="number">1</span>]; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">''</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">'0'</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p>除了方便与null或undefined比较时，最好不使用==运算符</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript深入之new的模拟实现</title>
    <url>/2019-10-12/Javascript/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8Bnew%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="new实例化"><a href="#new实例化" class="headerlink" title="new实例化"></a>new实例化</h2><ul>
<li>返回一个新的对象</li>
<li>新对象可以访问构造函数里的属性和方法</li>
<li>新对象可以访问 prototype 上的属性和方法</li>
</ul><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><p>因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 mockNew，来模拟 new 的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 需要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 获取需要实例化的构造函数</span></span><br><span class="line">    <span class="comment">// shift 会返回构造函数，修改原数组，所以 arguments 会被去除第一个参数</span></span><br><span class="line">    <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 继承原型上的属性和方法</span></span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="comment">//继承构造函数的属性和方法</span></span><br><span class="line">    Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<h2 id="兼容返回值类型"><a href="#兼容返回值类型" class="headerlink" title="兼容返回值类型"></a>兼容返回值类型</h2><p>我们还需要判断构造函数的返回值，如果构造函数的返回值是一个引用类型的对象，我们就返回构造函数的返回值，如果不是，我们该返回什么就返回什么。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 需要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 获取需要实例化的构造函数</span></span><br><span class="line">    <span class="comment">// shift 会返回构造函数，修改原数组，所以 arguments 会被去除第一个参数</span></span><br><span class="line">    <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 继承原型上的属性和方法</span></span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="comment">// 继承构造函数的属性和方法</span></span><br><span class="line">    <span class="keyword">var</span> result = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 兼容返回值类型 </span></span><br><span class="line">    <span class="comment">// 如果构造函数的返回值是一个引用类型的对象，我们就返回构造函数的返回值，否则返回obj</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/13</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>bind的模拟实现</title>
    <url>/2019-10-12/Javascript/bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="bind的作用"><a href="#bind的作用" class="headerlink" title="bind的作用"></a>bind的作用</h2><ul>
<li>bind()方法返回一个新的函数,</li>
<li>新函数的this值指向传入的第一个参数，this被绑定了</li>
<li>bind 的时候可以传递参数，进行绑定</li>
<li>bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效</li>
</ul><h2 id="返回函数的模拟实现"><a href="#返回函数的模拟实现" class="headerlink" title="返回函数的模拟实现"></a>返回函数的模拟实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="兼容参数处理"><a href="#兼容参数处理" class="headerlink" title="兼容参数处理"></a>兼容参数处理</h2><p>bind 的时候可以传递参数，进行绑定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//绑定参数</span></span><br><span class="line">    <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 指向函数 返回结果</span></span><br><span class="line">        <span class="comment">// 最终执行结果的参数，需要将bindArgs，args使用concat合并</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(context, bindArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="兼容构造函数"><a href="#兼容构造函数" class="headerlink" title="兼容构造函数"></a>兼容构造函数</h2><p>bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 指向函数 返回结果</span></span><br><span class="line">        <span class="comment">// 最终执行结果的参数，需要将bindArgs，args使用concat合并</span></span><br><span class="line">        <span class="comment">// bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，this指向fBound，但传入的参数依然生效</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : context, bindArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="兼容绑定函数原型上的属性"><a href="#兼容绑定函数原型上的属性" class="headerlink" title="兼容绑定函数原型上的属性"></a>兼容绑定函数原型上的属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 指向函数 返回结果</span></span><br><span class="line">        <span class="comment">// 最终执行结果的参数，需要将bindArgs，args使用concat合并</span></span><br><span class="line">        <span class="comment">// bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，this指向fBound，但传入的参数依然生效</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : context, bindArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span></span><br><span class="line">    <span class="comment">// 直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype</span></span><br><span class="line">    <span class="comment">// fBound.prototype = this.prototype;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过一个空函数来进行中转</span></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="兼容调用-bind-的不是函数"><a href="#兼容调用-bind-的不是函数" class="headerlink" title="兼容调用 bind 的不是函数"></a>兼容调用 bind 的不是函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用bind的不是函数，直接报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 指向函数 返回结果</span></span><br><span class="line">        <span class="comment">// 最终执行结果的参数，需要将bindArgs，args使用concat合并</span></span><br><span class="line">        <span class="comment">// bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，this指向fBound，但传入的参数依然生效</span></span><br><span class="line">        <span class="keyword">return</span> that.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fBound ? <span class="keyword">this</span> : context, bindArgs.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span></span><br><span class="line">    <span class="comment">// 直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype</span></span><br><span class="line">    <span class="comment">// fBound.prototype = this.prototype;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过一个空函数来进行中转</span></span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/12</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>call和apply的模拟实现</title>
    <url>/2019-10-12/Javascript/call%E5%92%8Capply%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="call的特点"><a href="#call的特点" class="headerlink" title="call的特点"></a>call的特点</h2><ul>
<li>可以改变当前函数的this指向</li>
<li>让当前函数执行</li>
</ul><h2 id="call模拟实现"><a href="#call模拟实现" class="headerlink" title="call模拟实现"></a>call模拟实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;<span class="comment">// 兼容context，Object(context)兼容context为string的情况</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>; <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">//获取参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    <span class="comment">// args 会自动调用 Array.toString() 这个方法</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args +<span class="string">')'</span>);</span><br><span class="line">    <span class="comment">// 删除该函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h2 id="apply-模拟实现"><a href="#apply-模拟实现" class="headerlink" title="apply 模拟实现"></a>apply 模拟实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>;<span class="comment">// 兼容context，Object(context)兼容context为string的情况</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>; <span class="comment">// 将函数设为对象的属性</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (!args) &#123;</span><br><span class="line">        <span class="comment">// 没有传参直接直接函数</span></span><br><span class="line">        result = context.fn()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = args.length; i &lt; len; i++) &#123;</span><br><span class="line">            arr.push(<span class="string">'args['</span> + i + <span class="string">']'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// arr 会自动调用 Array.toString() 这个方法</span></span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + arr + <span class="string">')'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除该函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用let、var和const创建变量有什么区别？</title>
    <url>/2019-10-12/Javascript/%E4%BD%BF%E7%94%A8let%E3%80%81var%E5%92%8Cconst%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<p>用<strong><em>var</em></strong>声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。<strong><em>let</em></strong>和<strong><em>const</em></strong>是块级作用域，意味着它们只能在最近的一组花括号<strong><em>（function、if-else 代码块或 for 循环中）</em></strong>中访问。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 所有变量在函数中都可访问</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">'bar'</span>;</span><br><span class="line">  <span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line">  <span class="keyword">const</span> qux = <span class="string">'qux'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// bar</span></span><br><span class="line">  <span class="built_in">console</span>.log(baz); <span class="comment">// baz</span></span><br><span class="line">  <span class="built_in">console</span>.log(qux); <span class="comment">// qux</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// ReferenceError: bar is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// ReferenceError: baz is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(qux); <span class="comment">// ReferenceError: qux is not defined</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">'bar'</span>;</span><br><span class="line">  <span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line">  <span class="keyword">const</span> qux = <span class="string">'qux'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 var 声明的变量在函数作用域上都可访问</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// let 和 const 定义的变量在它们被定义的语句块之外不可访问</span></span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// ReferenceError: baz is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(qux); <span class="comment">// ReferenceError: qux is not defined</span></span><br></pre></td></tr></table></figure>

<p><strong><em>var</em></strong>会使变量提升，这意味着变量可以在声明之前使用。<strong><em>let</em></strong>和<strong><em>const</em></strong>不会使变量提升，提前使用会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// ReferenceError: can't access lexical declaration 'baz' before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// ReferenceError: can't access lexical declaration 'bar' before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">'bar'</span>;</span><br></pre></td></tr></table></figure>

<p>用<strong><em>var</em></strong>重复声明不会报错，但<strong><em>let</em></strong>和<strong><em>const</em></strong>会。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// "bar"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">'baz'</span>;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">'qux'</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'baz' has already been declared</span></span><br></pre></td></tr></table></figure>

<p><strong><em>let</em></strong>和<strong><em>const</em></strong>的区别在于：<strong><em>let</em></strong>允许多次赋值，而<strong><em>const</em></strong>只允许一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样不会报错。</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">'foo'</span>;</span><br><span class="line">foo = <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样会报错。</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="string">'baz'</span>;</span><br><span class="line">baz = <span class="string">'qux'</span>;</span><br></pre></td></tr></table></figure>

<p>全局作用域下，使用<strong><em>var</em></strong>声明的变量会挂载到<strong><em>window</em></strong>对象上，使用<strong><em>let</em></strong>，<strong><em>const</em></strong>声明的变量不会挂载到<strong><em>window</em></strong>对象上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> c =<span class="number">30</span>;</span><br><span class="line"><span class="built_in">window</span>.a; <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">window</span>.b; <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">window</span>.c; <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>null、undefined和未声明变量之间有什么区别？如何检查判断这些状态值？</title>
    <url>/2019-10-12/Javascript/null%E3%80%81undefined%E5%92%8C%E6%9C%AA%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E5%88%A4%E6%96%AD%E8%BF%99%E4%BA%9B%E7%8A%B6%E6%80%81%E5%80%BC%EF%BC%9F/</url>
    <content><![CDATA[<p>当你没有提前使用<strong><em>var</em></strong>、<strong><em>let</em></strong>或<strong><em>const</em></strong>声明变量，就为一个变量赋值时，该变量是未声明变量<strong><em>（undeclared variables）</em></strong>。未声明变量会脱离当前作用域，成为全局作用域下定义的变量。<strong><em>在严格模式下</em></strong>，给未声明的变量赋值，会抛出<strong><em>ReferenceError</em></strong>错误。和使用全局变量一样，使用未声明变量也是非常不好的做法，应当尽可能避免。要检查判断它们，需要将用到它们的代码放在<strong><em>try/catch</em></strong>语句中。</p><a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  x = <span class="number">1</span>; <span class="comment">// 在严格模式下，抛出 ReferenceError 错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>当一个变量已经声明，但没有赋值时，该变量的值是<strong><em>undefined</em></strong>。如果一个函数的执行结果被赋值给一个变量，但是这个函数却没有返回任何值，那么该变量的值是<strong><em>undefined</em></strong>。要检查它，需要使用严格相等（===）；或者使用<strong><em>typeof</em></strong>，它会返回<strong><em>‘undefined’</em></strong>字符串。请注意，不能使用非严格相等（==）来检查，因为如果变量值为<strong><em>null</em></strong>，使用非严格相等也会返回<strong><em>true</em></strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo === <span class="string">'undefined'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo == <span class="literal">null</span>); <span class="comment">// true. 错误，不要使用非严格相等！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> baz = bar();</span><br><span class="line"><span class="built_in">console</span>.log(baz); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong><em>null</em></strong> 只能被显式赋值给变量。它表示空值，与被显式赋值 <strong><em>undefined</em></strong> 的意义不同。要检查判断<strong><em>null</em></strong>值，需要使用严格相等运算符。请注意，和前面一样，不能使用非严格相等（==）来检查，因为如果变量值为<strong><em>undefined</em></strong>，使用非严格相等也会返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo == <span class="literal">undefined</span>); <span class="comment">// true. 错误，不要使用非严格相等！</span></span><br></pre></td></tr></table></figure>

<p>作为一种个人习惯，我从不使用未声明变量。如果定义了暂时没有用到的变量，我会在声明后明确地给它们赋值为<strong><em>null</em></strong>。</p>
<ul>
<li>null：表示一个值被定义了，定义为“空值”；</li>
<li>undefined：表示根本不存在定义。</li>
</ul>
<p>所以设置一个值为 <strong><em>null</em></strong> 是合理的，如<br><strong><em>objA.valueA = null</em></strong>;</p>
<p>但设置一个值为 <strong><em>undefined</em></strong> 是不合理的</p>
<p><strong><em>null</em></strong> 表示”没有对象”，即该处不应该有值。典型用法是：</p>
<ul>
<li>1.作为函数的参数，表示该函数的参数不是对象。</li>
<li>2.作为对象原型链的终点。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)<span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p><code>undefined</code> 表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<ul>
<li>1.变量被声明了，但没有赋值时，就等于undefined。</li>
<li>2.调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>
<li>3.对象没有赋值的属性，该属性的值为undefined。</li>
<li>4.函数没有返回值时，默认返回undefined。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/questions/javascript-questions.md#nullundefined%E5%92%8C%E6%9C%AA%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E5%88%A4%E6%96%AD%E8%BF%99%E4%BA%9B%E7%8A%B6%E6%80%81%E5%80%BC" target="_blank" rel="noopener">https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/questions/javascript-questions.md#nullundefined%E5%92%8C%E6%9C%AA%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E5%88%A4%E6%96%AD%E8%BF%99%E4%BA%9B%E7%8A%B6%E6%80%81%E5%80%BC</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2019-10-12/Javascript/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>把接收多个参数的函数变换成接收一个单一参数（最初函数的第一个参数）的函数，并返回接受剩余的参数而且返回结果的新函数的技术。</p><p>简单的说，柯里化函数持续地返回一个新函数直到所有的参数用尽为止。这些参数全部保持“活着”的状态（通过闭包），然后当柯里化链中的最后一个函数被返回和执行时会全部被用来执行。</p><a id="more"></a>

<p>提高函数的适用性，同时降低函数的通用性；其实现方式就是固定一些可以预期的参数，然后返回一个特定的函数</p>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的add函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingAdd</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)           <span class="comment">// 3</span></span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>)   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="函数柯里化的好处"><a href="#函数柯里化的好处" class="headerlink" title="函数柯里化的好处"></a>函数柯里化的好处</h2><ul>
<li>参数复用：提前绑定好函数里面的某些参数,达到参数复用的效果,提高了适用性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常正则验证字符串 reg.test(txt)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数封装后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg, txt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check(<span class="regexp">/\d+/g</span>, <span class="string">'test'</span>)       <span class="comment">//false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>, <span class="string">'test'</span>)    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = curryingCheck(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line"></span><br><span class="line">hasNumber(<span class="string">'test1'</span>)      <span class="comment">// true</span></span><br><span class="line">hasNumber(<span class="string">'testtest'</span>)   <span class="comment">// false</span></span><br><span class="line">hasLetter(<span class="string">'21212'</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>提前返回<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//兼容现代浏览器以及IE浏览器的事件添加方法</span></span><br><span class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.attachEvent(<span class="string">'on'</span> + event, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上面的方法有什么问题呢？很显然，我们每次使用addEvent为元素添加事件的时候，会走一遍if…else if …，其实只要一次判定就可以了，怎么做？–柯里化。它相对一第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了浏览器支持的事件绑定，避免每次都进行判断。改为下面这样子的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.attachEvent(<span class="string">'on'</span> + event, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ul>
<li>延迟运行</li>
</ul>
<p>与 <strong><em>call/apply</em></strong> 方法直接执行不同，bind 方法将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数， 这符合柯里化特点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(target, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006096034" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006096034</a></p>
<p><a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">https://www.jianshu.com/p/2975c25e4d71</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数节流和防抖</title>
    <url>/2019-10-12/Javascript/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/</url>
    <content><![CDATA[<h1 id="函数节流和防抖"><a href="#函数节流和防抖" class="headerlink" title="函数节流和防抖"></a>函数节流和防抖</h1><p>窗口的resize、scroll、输入框内容校验等操作时，如果这些操作处理函数是较为复杂或页面频繁重渲染等操作时，在这种情况下如果事件触发的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用<strong><em>debounce（防抖）</em></strong>和<strong><em>throttle（节流）</em></strong>的方式来<strong><em>减少触发的频率</em></strong>，同时又不影响实际效果。</p><a id="more"></a>
<h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h2><p>当持续触发事件时，<strong><em>debounce</em></strong> 会合并事件且不会去触发事件，当一定时间内没有触发再这个事件时，才真正去触发事件，只会触发最后一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> timer = <span class="literal">null</span>, context, args;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = debounce(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"触发滚动"</span>, e)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<h3 id="立刻执行"><a href="#立刻执行" class="headerlink" title="立刻执行"></a>立刻执行</h3><p>不希望非要等到事件停止触发后才执行，希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。</p>
<p>加个 immediate 参数判断是否是立刻执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>, context, args;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 判断绑定的函数是否已经执行了 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> didRun = !timer;</span><br><span class="line">            <span class="keyword">if</span> (didRun) &#123;</span><br><span class="line">                <span class="comment">//没有执行过，立刻执行</span></span><br><span class="line">                callback.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>此时注意一点，就是绑定的函数可能是有返回值的，所以我们也要返回函数的执行结果，但是当 <strong><em>immediate</em></strong> 为 false 的时候，因为使用了 <strong><em>setTimeout</em></strong> ，我们将 <strong><em>func.apply(context, args)</em></strong> 的返回值赋给变量，最后再<strong><em>return</em></strong> 的时候，值将会一直是<strong><em>undefined</em></strong>，所以我们只在 <strong><em>immediate</em></strong> 为 <strong><em>true</em></strong> 的时候返回函数的执行结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>, context, args;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 判断绑定的函数是否已经执行了 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> didRun = !timer;</span><br><span class="line">            <span class="keyword">if</span> (didRun) &#123;</span><br><span class="line">                <span class="comment">//没有执行过，立刻执行</span></span><br><span class="line">                result = callback.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><p>最后我们再思考一个小需求，我希望能<strong><em>取消 debounce</em></strong> 函数，比如说我 <strong><em>debounce</em></strong> 的时间间隔是 10 秒钟，<strong><em>immediat</em></strong>e 为 <strong><em>true</em></strong>，这样的话，我只有等 10 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行啦。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, delay, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>, context, args;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 判断绑定的函数是否已经执行了 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> didRun = !timer;</span><br><span class="line">            <span class="keyword">if</span> (didRun) &#123;</span><br><span class="line">                <span class="comment">//没有执行过，立刻执行</span></span><br><span class="line">                result = callback.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback.apply(context, args)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消防抖</span></span><br><span class="line">    debounced.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 清除timeout</span></span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="comment">// 重置timeout</span></span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p>
<p>根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。</p>
<p>我们用 <strong><em>leading</em></strong> 代表首次是否执行，<strong><em>trailing</em></strong> 代表结束后是否再执行一次。</p>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<h3 id="使用时间戳"><a href="#使用时间戳" class="headerlink" title="使用时间戳"></a>使用时间戳</h3><p>使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> context, args;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">var</span>  now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; delay) &#123;</span><br><span class="line">            previous = now;</span><br><span class="line">            callback.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h3><p>接下来，我们讲讲第二种实现方式，使用定时器。</p>
<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，重置定时器，这样就可以设置下个定时器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 获取参数</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 重置定时器</span></span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                callback.apply(context, args)</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较使用时间戳，使用定时器两个方法：</p>
<p>第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行<br>第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件</p>
<h3 id="双剑合璧"><a href="#双剑合璧" class="headerlink" title="双剑合璧"></a>双剑合璧</h3><p>想要控制第一次是否立刻执行，事件停止触发后是否会再执行一次事件。</p>
<p>那我们设置个 <strong><em>options</em></strong> 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定:</p>
<ul>
<li>leading：false 表示禁用第一次执行</li>
<li>trailing: false 表示禁用停止触发的回调<br>默认会开启第一次立刻执行，事件停止触发后会再执行一次事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果禁用第一次立刻执行 设置previous为0，throttled函数remaining会确保大于0 throttled函数会执行else if条件语句里面的内容，从而达到节流的效果，如果没有禁用第一次立刻执行，需要重置previous为当前时间</span></span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="comment">// 执行完重置timeout</span></span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 执行函数</span></span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="comment">// 触发第一次操作时，默认会第一次立刻执行，第一次执行remaining会小于0，程序会执行 if条件语句的内容，快速执行第二次点击previous = now;remaining会大于0，会执行else if条件语句里面的内容</span></span><br><span class="line">        <span class="comment">// 触发第一次操作时，如果禁用第一次立刻执行，当前previous为0，将previous设置为now，remaining会大于0 程序会执行else if条件语句里面的内容</span></span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="comment">// 获取触发函数剩余的时间</span></span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        <span class="comment">// 绑定this</span></span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 绑定arguments</span></span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="comment">// 清除timeout</span></span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置时间</span></span><br><span class="line">            previous = now;</span><br><span class="line">            <span class="comment">// 执行函数</span></span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// 事件停止触发后会再执行一次事件</span></span><br><span class="line">            <span class="comment">// 通过计时器setTimeout，设置remaining时间后执行事件触发，达到节流</span></span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。</li>
<li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>debounce<ul>
<li>search搜索，用户在不断输入值时，用防抖来节约请求资源。</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ul>
</li>
<li>throttle<ul>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/post/5b8de829f265da43623c4261" target="_blank" rel="noopener">https://juejin.im/post/5b8de829f265da43623c4261</a></p>
<p><a href="https://juejin.im/post/5b7b88d46fb9a019e9767405?utm_medium=fe&amp;utm_source=weixinqun" target="_blank" rel="noopener">https://juejin.im/post/5b7b88d46fb9a019e9767405?utm_medium=fe&amp;utm_source=weixinqun</a></p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/22</a></p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/26</a></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>普通函数和箭头函数的区别</title>
    <url>/2019-10-12/Javascript/%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>1.箭头函数没有prototype(原型)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="params">()</span> =&gt;</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">a.__proto__===<span class="built_in">Function</span>.prototype;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>2.箭头函数的this指向它被创建时的上下文</p><a id="more"></a>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    id: <span class="number">22</span>,</span><br><span class="line">    print: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;,</span><br><span class="line">    print2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">    &#125;,</span><br><span class="line">    print3: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    print4: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.print(); <span class="comment">// undefined</span></span><br><span class="line">obj.print2(); <span class="comment">// 22</span></span><br><span class="line">obj.print3(); <span class="comment">// undefined</span></span><br><span class="line">obj.print4(); <span class="comment">// 22</span></span><br></pre></td></tr></table></figure>

<p>3.在构造函数里使用箭头函数的主要优点是它的 this 只与箭头函数创建时的 this 保持一致，并且不会修改。所以，当用构造函数去创建一个新的对象的时候，箭头函数的 this 总是指向新创建的对象。正常函数的 this 是可以在执行过程中被改变的，而箭头函数的 this 则会一直保持一致。所以在使用箭头函数的时候，你就不需要担心它的上下文被改变了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">firstName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">this</span>.sayName1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.firstName); &#125;;</span><br><span class="line">    <span class="keyword">this</span>.sayName2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.firstName); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> john = <span class="keyword">new</span> Person(<span class="string">'John'</span>);</span><br><span class="line"><span class="keyword">const</span> dave = <span class="keyword">new</span> Person(<span class="string">'Dave'</span>);</span><br><span class="line"></span><br><span class="line">john.sayName1(); <span class="comment">// John</span></span><br><span class="line">john.sayName2(); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数的 this 可以被修改，而箭头函数则不会</span></span><br><span class="line">john.sayName1.call(dave); <span class="comment">// Dave (因为 "this" 现在指向了 dave 对象)</span></span><br><span class="line">john.sayName2.call(dave); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line">john.sayName1.apply(dave); <span class="comment">// Dave (因为 "this" 现在指向了 dave 对象)</span></span><br><span class="line">john.sayName2.apply(dave); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line">john.sayName1.bind(dave)(); <span class="comment">// Dave (因为 "this" 现在指向了 dave 对象)</span></span><br><span class="line">john.sayName2.bind(dave)(); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sayNameFromWindow1 = john.sayName1;</span><br><span class="line">sayNameFromWindow1(); <span class="comment">// undefined (因为 "this" 现在指向了 Window 对象)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sayNameFromWindow2 = john.sayName2;</span><br><span class="line">sayNameFromWindow2(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>4.如果箭头函数外层没有普通函数，严格模式和非严格模式下它的this都会指向window(全局对象)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    print: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> obj.print(); <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>5.更简洁的语法</p>
<p>箭头函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于普通函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.不能使用new</p>
<p>箭头函数作为匿名函数,是不能作为构造函数的,不能使用new</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  value:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(); <span class="comment">//TypeError: B is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>7.不绑定arguments，用rest参数…解决</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*常规函数使用arguments*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);   <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*箭头函数不能使用arguments*/</span></span><br><span class="line"><span class="keyword">const</span> test2 = <span class="function">(<span class="params">a</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">arguments</span>)&#125;  <span class="comment">//ReferenceError: arguments is not defined</span></span><br><span class="line"><span class="comment">/*箭头函数使用reset参数...解决*/</span></span><br><span class="line"><span class="keyword">let</span> test3=<span class="function">(<span class="params">...a</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(a)&#125; <span class="comment">//22</span></span><br><span class="line"></span><br><span class="line">test1(<span class="number">1</span>);</span><br><span class="line">test2(<span class="number">2</span>);</span><br><span class="line">test3(<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>);</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数的注意事项："><a href="#箭头函数的注意事项：" class="headerlink" title="箭头函数的注意事项："></a>箭头函数的注意事项：</h2><p>1.不能简单返回对象字面量</p>
<p>如果要返回对象时需要用小括号包起来，因为大括号被占用解释为代码块了，正确写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;  <span class="comment">// undefined 想返回一个对象，大括号被占用解释为代码块，执行后返回undefined</span></span><br><span class="line"><span class="keyword">var</span> func2 = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);  <span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>2.箭头函数不能当做Generator函数，不能使用yield关键字</p>
<p>3.箭头函数不能换行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = ()</span><br><span class="line">          =&gt;<span class="number">1</span>; <span class="comment">//SyntaxError: Unexpected token =&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>call、apply 及 bind 函数的区别</title>
    <url>/2019-10-12/Javascript/call%E3%80%81apply-%E5%8F%8A-bind-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>call和apply都用于调用函数，第一个参数将用作函数内 this 的值。然而，call接受逗号分隔的参数作为后面的参数，而apply接受一个参数数组作为后面的参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p><code>bind()</code>方法返回一个新的函数, 新函数的<code>this</code>值指向传入的第一个参数，<code>this</code>被绑定了</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>简述JavaScript中的this</title>
    <url>/2019-10-12/Javascript/%E7%AE%80%E8%BF%B0JavaScript%E4%B8%AD%E7%9A%84this/</url>
    <content><![CDATA[<p>粗略地讲，函数的调用方式决定了<code>this</code>的值，谁调用的函数，<code>this</code>就指向谁。<code>this</code>取值符合以下规则：</p><p>1.如果函数作为构造函数用，那么其中的<code>this</code>就代表它即将<code>new</code>出来的对象。</p><p>2.如果<code>appl</code>、<code>call</code>或<code>bind</code>方法用于调用、创建一个函数，this的值就取传入的对象的值。</p><p>3.如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的<code>this</code>指向该对象。比如当<code>obj.method()</code>被调用时，函数内的 <code>this</code> 将绑定到<code>obj</code>对象。</p><a id="more"></a>



<p>4.如果调用函数不符合上述规则，那么<code>this</code>的值指向全局对象<code>（global object）</code>。浏览器环境下<code>this</code>的值指向<code>window</code>对象，但是在严格模式下<code>(&#39;use strict&#39;)</code>，<code>this</code>的值为<code>undefined</code>。</p>
<p>5.如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定<code>this</code>的值。</p>
<p>6.如果该函数是 ES2015 中的<code>箭头函数</code>，将忽略上面的所有规则，<code>this</code>被设置为它被<code>创建时的上下文</code>。</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
